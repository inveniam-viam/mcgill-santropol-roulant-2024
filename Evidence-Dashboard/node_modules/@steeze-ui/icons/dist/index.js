import{createWriteStream as v,existsSync as a,lstatSync as O,mkdirSync as g,readdirSync as d,readFileSync as y,rmSync as b,writeFileSync as F}from"fs";import{parse as P}from"html-parse-stringify";import{EOL as T}from"os";import{extname as D,join as o}from"path";function S(m){return m.replace(/(?!^)([A-Z\u00C0-\u00D6])/g,function(t){return"-"+t.toLowerCase()})}var j=/[\s\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]+/;function x(m){for(var t=m.split(j),s=t.length,e=new Array(s),i=0;i<s;i++){var u=t[i];u!==""&&(e[i]=u[0].toUpperCase()+u.slice(1))}return e.join("")}var E={sources:{inputRaw:"",outputThemes:"./themes"},lib:{output:"./src/lib",exportsFileName:"index.ts",typesInputFile:"./node_modules/@steeze-ui/icons/shared/types/types.d.ts"}},k=class{constructor(t){this.unrecognizedSuffixes=[];this.sourceDict={};this.typesOutputFile="types.d.ts";t.lib=Object.assign(E.lib,t.lib),t.sources=Object.assign(E.sources,t.sources),this.props=t,this.exportsFilePath=o(t.lib.output,t.lib.exportsFileName)}build(){let{outputThemes:t,collectFromDir:s,collectFromSuffix:e}=this.props.sources;if(s&&(console.log("Collecting Sources from directory"),this.collectFromDir()),e&&(console.log("Collecting Sources from suffix"),this.collectFromSuffix()),!a(t)){console.log("No themes directory found");return}if(!a(o(t,"default"))){console.log("No default theme found");return}a(this.props.lib.output)||g(this.props.lib.output,{recursive:!0}),a(this.exportsFilePath)&&b(this.exportsFilePath,{recursive:!0}),d(t).forEach(i=>{this.getIconsFromTheme(i)}),this.writeExportsFile(),this.copyTypesFile()}copyTypesFile(){let t=o(this.props.lib.output,this.typesOutputFile);if(!a(o(this.props.lib.typesInputFile))){console.log("No types file found");return}a(t)&&b(t,{recursive:!0});let s=y(o(this.props.lib.typesInputFile)).toString(),e=v(t,{flags:"a"});e.write(s),e.write(T),e.end()}getIconsFromTheme(t){let s={};d(o(this.props.sources.outputThemes,t)).forEach(e=>{let i=e.replace(".svg",""),u=y(o(this.props.sources.outputThemes,t,e)).toString(),l=P(u)[0];this.sourceDict[i]||(this.sourceDict[i]={}),this.sourceDict[i][t]={a:l.attrs},this.props.lib.excludeSvgAttributes&&this.props.lib.excludeSvgAttributes.forEach(r=>{delete this.sourceDict[i][t].a[r]}),this.props.lib.extendSvgAttributes&&(this.sourceDict[i][t].a=Object.assign(this.sourceDict[i][t].a,this.props.lib.extendSvgAttributes));let h=l.children.filter(r=>r.type!="text"),n={};h.forEach(r=>{if(r.name==="g"){let p=Object.keys(r.attrs).length>0;r.children.filter(c=>c.type!="text").forEach(c=>{p&&Object.assign(c.attrs,r.attrs),n[c.name]||(n[c.name]=[]),n[c.name].push(c.attrs)})}else if(r.name==="switch"){let p=Object.keys(r.attrs).length>0;r.children.filter(c=>c.type!="text").forEach(c=>{c.name==="g"?c.children.filter(f=>f.type!="text").forEach(f=>{p&&Object.assign(f.attrs,r.attrs),n[f.name]||(n[f.name]=[]),n[f.name].push(f.attrs)}):(p&&Object.assign(c.attrs,r.attrs),n[c.name]||(n[c.name]=[]),n[c.name].push(c.attrs))})}else n[r.name]||(n[r.name]=[]),n[r.name].push(r.attrs)}),this.sourceDict[i][t]=Object.assign(this.sourceDict[i][t],n),Object.keys(n).forEach(r=>{s[r]||(s[r]=[]),n[r].forEach(p=>{Object.keys(p).forEach(c=>{s[r].includes(c)||s[r].push(c)})})})}),Object.keys(s).forEach(e=>{console.log("theme:",t),console.log(`   <${e}>`,s[e])}),console.log("")}writeExportsFile(){let t=v(this.exportsFilePath,{flags:"a"});t.write(`import type {IconSource} from "./types.js" 
export {IconSource} 
`);let s=Object.keys(this.sourceDict).map(e=>`export const ${this.normalizeLibName(e)}=${JSON.stringify(this.sourceDict[e],null,0)} as IconSource`).join(`
`);t.write(s),t.write(T),t.end()}collectFromDir(){let t=o(this.props.sources.outputThemes),{inputRaw:s}=this.props.sources,{collectFromDir:e}=this.props.sources;if(!e){console.log("No Themes Map found! Please add 'collectFromDir' to your config.");return}if(!a(o(this.props.sources.inputRaw))){console.log("No input directory found");return}a(t)&&b(t,{recursive:!0}),g(t),Object.keys(e).forEach(i=>{if(!a(o(s,i))){console.log(`No input directory for theme ${i} found`);return}let u=e?.[i];u&&d(o(s,i)).forEach(l=>{if(D(l)===".svg"){let n=y(o(s,i,l)).toString();a(o(t,u))||g(o(t,u)),F(o(t,u,this.normalizeSourceName(l,i)),n)}})})}collectFromSuffix(){let{inputRaw:t,outputThemes:s,collectFromSuffix:e}=this.props.sources;if(!e){console.log("No Suffix Map found! Please add 'collectFromSuffix' to your config.");return}if(!a(o(t))){console.log("No input directory found");return}a(o(s))&&b(o(s),{recursive:!0}),g(o(s)),this.unrecognizedSuffixes=[],this.traverse(t),this.unrecognizedSuffixes.length>0&&console.log("Unrecognized files:",this.unrecognizedSuffixes.join(", "))}traverse(t){d(o(t)).forEach(s=>{let e=o(t,s);if(O(e).isDirectory())this.traverse(e);else if(D(e)!=".svg")console.log("Unrecognized file:",e),this.unrecognizedSuffixes.push(e);else{let{collectFromSuffix:u,outputThemes:l,fallbackTheme:h}=this.props.sources;if(!u){console.log("No Suffix Map found! Please add 'collectFromSuffix' to your config.");return}let n=Object.keys(u).find(r=>s.includes(r))||"";if(n||h){let r=u?.[n]||h;if(r){let p=y(o(e)).toString();a(o(l,r))||g(o(l,r)),n&&(s=s.replace(n,"")),F(o(l,r,this.normalizeSourceName(s,r)),p)}else console.log(t,e)}else this.unrecognizedSuffixes.push(s)}})}normalizeSourceName(t,s){let e=t;if(this.props.sources.endsWithThemeName){let i="-"+s+".svg";t.endsWith(i)&&(e=e.slice(0,e.length-i.length)+".svg")}return S(e)}normalizeLibName(t){return t=x(t),/^\d/.test(t)&&(t="_"+t),t}};export{k as ThemeBuilder};
