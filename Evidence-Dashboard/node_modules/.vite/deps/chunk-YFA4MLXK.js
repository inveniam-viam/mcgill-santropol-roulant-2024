import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  __spreadArray,
  init_tslib_es6
} from "./chunk-AZKN4JKF.js";
import {
  require_md5
} from "./chunk-VNIEHZB3.js";
import {
  require_lib
} from "./chunk-KB32ZGF7.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS
} from "./chunk-BYPFWIQ6.js";

// ../../node_modules/@lukeed/csprng/browser/index.js
var require_browser = __commonJS({
  "../../node_modules/@lukeed/csprng/browser/index.js"(exports) {
    function random(len) {
      return crypto.getRandomValues(new Uint8Array(len));
    }
    exports.random = random;
  }
});

// ../../node_modules/@lukeed/uuid/secure/index.js
var require_secure = __commonJS({
  "../../node_modules/@lukeed/uuid/secure/index.js"(exports) {
    var { random } = require_browser();
    var SIZE = 4096;
    var HEX2 = [];
    var IDX2 = 0;
    var BUFFER2;
    for (; IDX2 < 256; IDX2++) {
      HEX2[IDX2] = (IDX2 + 256).toString(16).substring(1);
    }
    function v42() {
      if (!BUFFER2 || IDX2 + 16 > SIZE) {
        BUFFER2 = random(SIZE);
        IDX2 = 0;
      }
      var i = 0, tmp, out = "";
      for (; i < 16; i++) {
        tmp = BUFFER2[IDX2 + i];
        if (i == 6)
          out += HEX2[tmp & 15 | 64];
        else if (i == 8)
          out += HEX2[tmp & 63 | 128];
        else
          out += HEX2[tmp];
        if (i & 1 && i > 1 && i < 11)
          out += "-";
      }
      IDX2 += 16;
      return out;
    }
    exports.v4 = v42;
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/emitter/interface.js
var init_interface = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/emitter/interface.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/plugins/index.js
var init_plugins = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/plugins/index.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/events/interfaces.js
var init_interfaces = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/events/interfaces.js"() {
  }
});

// ../../node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}
var init_dist = __esm({
  "../../node_modules/dset/dist/index.mjs"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/utils/pick.js
var pickBy;
var init_pick = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/utils/pick.js"() {
    pickBy = function(obj, fn) {
      return Object.keys(obj).filter(function(k) {
        return fn(k, obj[k]);
      }).reduce(function(acc, key) {
        return acc[key] = obj[key], acc;
      }, {});
    };
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/validation/errors.js
var ValidationError;
var init_errors = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/validation/errors.js"() {
    init_tslib_es6();
    ValidationError = /** @class */
    function(_super) {
      __extends(ValidationError2, _super);
      function ValidationError2(field, message2) {
        var _this = _super.call(this, "".concat(field, " ").concat(message2)) || this;
        _this.field = field;
        return _this;
      }
      return ValidationError2;
    }(Error);
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/validation/helpers.js
function isString(obj) {
  return typeof obj === "string";
}
function exists(val) {
  return val !== void 0 && val !== null;
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() === "object";
}
var init_helpers = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/validation/helpers.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/validation/assertions.js
function assertUserIdentity(event) {
  var USER_FIELD_NAME = ".userId/anonymousId/previousId/groupId";
  var getAnyUserId = function(event2) {
    var _a2, _b2, _c;
    return (_c = (_b2 = (_a2 = event2.userId) !== null && _a2 !== void 0 ? _a2 : event2.anonymousId) !== null && _b2 !== void 0 ? _b2 : event2.groupId) !== null && _c !== void 0 ? _c : event2.previousId;
  };
  var id = getAnyUserId(event);
  if (!exists(id)) {
    throw new ValidationError(USER_FIELD_NAME, nilError);
  } else if (!isString(id)) {
    throw new ValidationError(USER_FIELD_NAME, stringError);
  }
}
function assertEventExists(event) {
  if (!exists(event)) {
    throw new ValidationError("Event", nilError);
  }
  if (typeof event !== "object") {
    throw new ValidationError("Event", objError);
  }
}
function assertEventType(event) {
  if (!isString(event.type)) {
    throw new ValidationError(".type", stringError);
  }
}
function assertTrackEventName(event) {
  if (!isString(event.event)) {
    throw new ValidationError(".event", stringError);
  }
}
function assertTrackEventProperties(event) {
  if (!isPlainObject(event.properties)) {
    throw new ValidationError(".properties", objError);
  }
}
function assertTraits(event) {
  if (!isPlainObject(event.traits)) {
    throw new ValidationError(".traits", objError);
  }
}
function assertMessageId(event) {
  if (!isString(event.messageId)) {
    throw new ValidationError(".messageId", stringError);
  }
}
function validateEvent(event) {
  assertEventExists(event);
  assertEventType(event);
  assertMessageId(event);
  if (event.type === "track") {
    assertTrackEventName(event);
    assertTrackEventProperties(event);
  }
  if (["group", "identify"].includes(event.type)) {
    assertTraits(event);
  }
}
var stringError, objError, nilError;
var init_assertions = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/validation/assertions.js"() {
    init_errors();
    init_helpers();
    stringError = "is not a string";
    objError = "is not an object";
    nilError = "is nil";
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/events/index.js
var InternalEventFactorySettings, CoreEventFactory;
var init_events = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/events/index.js"() {
    init_tslib_es6();
    init_interfaces();
    init_dist();
    init_pick();
    init_assertions();
    InternalEventFactorySettings = /** @class */
    /* @__PURE__ */ function() {
      function InternalEventFactorySettings2(settings) {
        var _a2, _b2;
        this.settings = settings;
        this.createMessageId = settings.createMessageId;
        this.onEventMethodCall = (_a2 = settings.onEventMethodCall) !== null && _a2 !== void 0 ? _a2 : function() {
        };
        this.onFinishedEvent = (_b2 = settings.onFinishedEvent) !== null && _b2 !== void 0 ? _b2 : function() {
        };
      }
      return InternalEventFactorySettings2;
    }();
    CoreEventFactory = /** @class */
    function() {
      function CoreEventFactory2(settings) {
        this.settings = new InternalEventFactorySettings(settings);
      }
      CoreEventFactory2.prototype.track = function(event, properties, options, globalIntegrations) {
        this.settings.onEventMethodCall({ type: "track", options });
        return this.normalize(__assign(__assign({}, this.baseEvent()), { event, type: "track", properties: properties !== null && properties !== void 0 ? properties : {}, options: __assign({}, options), integrations: __assign({}, globalIntegrations) }));
      };
      CoreEventFactory2.prototype.page = function(category, page, properties, options, globalIntegrations) {
        var _a2;
        this.settings.onEventMethodCall({ type: "page", options });
        var event = {
          type: "page",
          properties: __assign({}, properties),
          options: __assign({}, options),
          integrations: __assign({}, globalIntegrations)
        };
        if (category !== null) {
          event.category = category;
          event.properties = (_a2 = event.properties) !== null && _a2 !== void 0 ? _a2 : {};
          event.properties.category = category;
        }
        if (page !== null) {
          event.name = page;
        }
        return this.normalize(__assign(__assign({}, this.baseEvent()), event));
      };
      CoreEventFactory2.prototype.screen = function(category, screen, properties, options, globalIntegrations) {
        this.settings.onEventMethodCall({ type: "screen", options });
        var event = {
          type: "screen",
          properties: __assign({}, properties),
          options: __assign({}, options),
          integrations: __assign({}, globalIntegrations)
        };
        if (category !== null) {
          event.category = category;
        }
        if (screen !== null) {
          event.name = screen;
        }
        return this.normalize(__assign(__assign({}, this.baseEvent()), event));
      };
      CoreEventFactory2.prototype.identify = function(userId, traits, options, globalIntegrations) {
        this.settings.onEventMethodCall({ type: "identify", options });
        return this.normalize(__assign(__assign({}, this.baseEvent()), { type: "identify", userId, traits: traits !== null && traits !== void 0 ? traits : {}, options: __assign({}, options), integrations: globalIntegrations }));
      };
      CoreEventFactory2.prototype.group = function(groupId, traits, options, globalIntegrations) {
        this.settings.onEventMethodCall({ type: "group", options });
        return this.normalize(__assign(__assign({}, this.baseEvent()), {
          type: "group",
          traits: traits !== null && traits !== void 0 ? traits : {},
          options: __assign({}, options),
          integrations: __assign({}, globalIntegrations),
          //
          groupId
        }));
      };
      CoreEventFactory2.prototype.alias = function(to, from, options, globalIntegrations) {
        this.settings.onEventMethodCall({ type: "alias", options });
        var base = {
          userId: to,
          type: "alias",
          options: __assign({}, options),
          integrations: __assign({}, globalIntegrations)
        };
        if (from !== null) {
          base.previousId = from;
        }
        if (to === void 0) {
          return this.normalize(__assign(__assign({}, base), this.baseEvent()));
        }
        return this.normalize(__assign(__assign({}, this.baseEvent()), base));
      };
      CoreEventFactory2.prototype.baseEvent = function() {
        return {
          integrations: {},
          options: {}
        };
      };
      CoreEventFactory2.prototype.context = function(options) {
        var _a2;
        var eventOverrideKeys = [
          "userId",
          "anonymousId",
          "timestamp",
          "messageId"
        ];
        delete options["integrations"];
        var providedOptionsKeys = Object.keys(options);
        var context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : {};
        var eventOverrides = {};
        providedOptionsKeys.forEach(function(key) {
          if (key === "context") {
            return;
          }
          if (eventOverrideKeys.includes(key)) {
            dset(eventOverrides, key, options[key]);
          } else {
            dset(context, key, options[key]);
          }
        });
        return [context, eventOverrides];
      };
      CoreEventFactory2.prototype.normalize = function(event) {
        var _a2, _b2;
        var integrationBooleans = Object.keys((_a2 = event.integrations) !== null && _a2 !== void 0 ? _a2 : {}).reduce(function(integrationNames, name) {
          var _a3;
          var _b3;
          return __assign(__assign({}, integrationNames), (_a3 = {}, _a3[name] = Boolean((_b3 = event.integrations) === null || _b3 === void 0 ? void 0 : _b3[name]), _a3));
        }, {});
        event.options = pickBy(event.options || {}, function(_, value) {
          return value !== void 0;
        });
        var allIntegrations = __assign(__assign({}, integrationBooleans), (_b2 = event.options) === null || _b2 === void 0 ? void 0 : _b2.integrations);
        var _c = event.options ? this.context(event.options) : [], context = _c[0], overrides = _c[1];
        var options = event.options, rest = __rest(event, ["options"]);
        var evt = __assign(__assign(__assign(__assign({ timestamp: /* @__PURE__ */ new Date() }, rest), { context, integrations: allIntegrations }), overrides), { messageId: options.messageId || this.settings.createMessageId() });
        this.settings.onFinishedEvent(evt);
        validateEvent(evt);
        return evt;
      };
      return CoreEventFactory2;
    }();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/callback/index.js
function pTimeout(promise, timeout) {
  return new Promise(function(resolve, reject) {
    var timeoutId = setTimeout(function() {
      reject(Error("Promise timed out"));
    }, timeout);
    promise.then(function(val) {
      clearTimeout(timeoutId);
      return resolve(val);
    }).catch(reject);
  });
}
function sleep(timeoutInMs) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, timeoutInMs);
  });
}
function invokeCallback(ctx, callback, delay) {
  var cb = function() {
    try {
      return Promise.resolve(callback(ctx));
    } catch (err) {
      return Promise.reject(err);
    }
  };
  return sleep(delay).then(function() {
    return pTimeout(cb(), 1e3);
  }).catch(function(err) {
    ctx === null || ctx === void 0 ? void 0 : ctx.log("warn", "Callback Error", { error: err });
    ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment("callback_error");
  }).then(function() {
    return ctx;
  });
}
var init_callback = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/callback/index.js"() {
  }
});

// ../../node_modules/@segment/analytics-generic-utils/dist/esm/create-deferred/create-deferred.js
var createDeferred;
var init_create_deferred = __esm({
  "../../node_modules/@segment/analytics-generic-utils/dist/esm/create-deferred/create-deferred.js"() {
    createDeferred = function() {
      var resolve;
      var reject;
      var settled = false;
      var promise = new Promise(function(_resolve, _reject) {
        resolve = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          settled = true;
          _resolve.apply(void 0, args);
        };
        reject = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          settled = true;
          _reject.apply(void 0, args);
        };
      });
      return {
        resolve,
        reject,
        promise,
        isSettled: function() {
          return settled;
        }
      };
    };
  }
});

// ../../node_modules/@segment/analytics-generic-utils/dist/esm/create-deferred/index.js
var init_create_deferred2 = __esm({
  "../../node_modules/@segment/analytics-generic-utils/dist/esm/create-deferred/index.js"() {
    init_create_deferred();
  }
});

// ../../node_modules/@segment/analytics-generic-utils/dist/esm/emitter/emitter.js
var Emitter;
var init_emitter = __esm({
  "../../node_modules/@segment/analytics-generic-utils/dist/esm/emitter/emitter.js"() {
    Emitter = /** @class */
    function() {
      function Emitter2(options) {
        var _a2;
        this.callbacks = {};
        this.warned = false;
        this.maxListeners = (_a2 = options === null || options === void 0 ? void 0 : options.maxListeners) !== null && _a2 !== void 0 ? _a2 : 10;
      }
      Emitter2.prototype.warnIfPossibleMemoryLeak = function(event) {
        if (this.warned) {
          return;
        }
        if (this.maxListeners && this.callbacks[event].length > this.maxListeners) {
          console.warn("Event Emitter: Possible memory leak detected; ".concat(String(event), " has exceeded ").concat(this.maxListeners, " listeners."));
          this.warned = true;
        }
      };
      Emitter2.prototype.on = function(event, callback) {
        if (!this.callbacks[event]) {
          this.callbacks[event] = [callback];
        } else {
          this.callbacks[event].push(callback);
          this.warnIfPossibleMemoryLeak(event);
        }
        return this;
      };
      Emitter2.prototype.once = function(event, callback) {
        var _this = this;
        var on = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          _this.off(event, on);
          callback.apply(_this, args);
        };
        this.on(event, on);
        return this;
      };
      Emitter2.prototype.off = function(event, callback) {
        var _a2;
        var fns = (_a2 = this.callbacks[event]) !== null && _a2 !== void 0 ? _a2 : [];
        var without = fns.filter(function(fn) {
          return fn !== callback;
        });
        this.callbacks[event] = without;
        return this;
      };
      Emitter2.prototype.emit = function(event) {
        var _this = this;
        var _a2;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var callbacks = (_a2 = this.callbacks[event]) !== null && _a2 !== void 0 ? _a2 : [];
        callbacks.forEach(function(callback) {
          callback.apply(_this, args);
        });
        return this;
      };
      return Emitter2;
    }();
  }
});

// ../../node_modules/@segment/analytics-generic-utils/dist/esm/emitter/index.js
var init_emitter2 = __esm({
  "../../node_modules/@segment/analytics-generic-utils/dist/esm/emitter/index.js"() {
    init_emitter();
  }
});

// ../../node_modules/@segment/analytics-generic-utils/dist/esm/index.js
var init_esm = __esm({
  "../../node_modules/@segment/analytics-generic-utils/dist/esm/index.js"() {
    init_create_deferred2();
    init_emitter2();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/priority-queue/backoff.js
function backoff(params) {
  var random = Math.random() + 1;
  var _a2 = params.minTimeout, minTimeout = _a2 === void 0 ? 500 : _a2, _b2 = params.factor, factor = _b2 === void 0 ? 2 : _b2, attempt2 = params.attempt, _c = params.maxTimeout, maxTimeout = _c === void 0 ? Infinity : _c;
  return Math.min(random * minTimeout * Math.pow(factor, attempt2), maxTimeout);
}
var init_backoff = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/priority-queue/backoff.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/priority-queue/index.js
var ON_REMOVE_FROM_FUTURE, PriorityQueue;
var init_priority_queue = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/priority-queue/index.js"() {
    init_tslib_es6();
    init_esm();
    init_backoff();
    ON_REMOVE_FROM_FUTURE = "onRemoveFromFuture";
    PriorityQueue = /** @class */
    function(_super) {
      __extends(PriorityQueue2, _super);
      function PriorityQueue2(maxAttempts, queue, seen) {
        var _this = _super.call(this) || this;
        _this.future = [];
        _this.maxAttempts = maxAttempts;
        _this.queue = queue;
        _this.seen = seen !== null && seen !== void 0 ? seen : {};
        return _this;
      }
      PriorityQueue2.prototype.push = function() {
        var _this = this;
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          items[_i] = arguments[_i];
        }
        var accepted = items.map(function(operation) {
          var attempts = _this.updateAttempts(operation);
          if (attempts > _this.maxAttempts || _this.includes(operation)) {
            return false;
          }
          _this.queue.push(operation);
          return true;
        });
        this.queue = this.queue.sort(function(a, b) {
          return _this.getAttempts(a) - _this.getAttempts(b);
        });
        return accepted;
      };
      PriorityQueue2.prototype.pushWithBackoff = function(item) {
        var _this = this;
        if (this.getAttempts(item) === 0) {
          return this.push(item)[0];
        }
        var attempt2 = this.updateAttempts(item);
        if (attempt2 > this.maxAttempts || this.includes(item)) {
          return false;
        }
        var timeout = backoff({ attempt: attempt2 - 1 });
        setTimeout(function() {
          _this.queue.push(item);
          _this.future = _this.future.filter(function(f) {
            return f.id !== item.id;
          });
          _this.emit(ON_REMOVE_FROM_FUTURE);
        }, timeout);
        this.future.push(item);
        return true;
      };
      PriorityQueue2.prototype.getAttempts = function(item) {
        var _a2;
        return (_a2 = this.seen[item.id]) !== null && _a2 !== void 0 ? _a2 : 0;
      };
      PriorityQueue2.prototype.updateAttempts = function(item) {
        this.seen[item.id] = this.getAttempts(item) + 1;
        return this.getAttempts(item);
      };
      PriorityQueue2.prototype.includes = function(item) {
        return this.queue.includes(item) || this.future.includes(item) || Boolean(this.queue.find(function(i) {
          return i.id === item.id;
        })) || Boolean(this.future.find(function(i) {
          return i.id === item.id;
        }));
      };
      PriorityQueue2.prototype.pop = function() {
        return this.queue.shift();
      };
      Object.defineProperty(PriorityQueue2.prototype, "length", {
        get: function() {
          return this.queue.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PriorityQueue2.prototype, "todo", {
        get: function() {
          return this.queue.length + this.future.length;
        },
        enumerable: false,
        configurable: true
      });
      return PriorityQueue2;
    }(Emitter);
  }
});

// ../../node_modules/@lukeed/uuid/dist/index.mjs
function v4() {
  var i = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i = 256);
    while (i--)
      BUFFER[i] = 256 * Math.random() | 0;
    i = IDX = 0;
  }
  for (; i < 16; i++) {
    num = BUFFER[IDX + i];
    if (i == 6)
      out += HEX[num & 15 | 64];
    else if (i == 8)
      out += HEX[num & 63 | 128];
    else
      out += HEX[num];
    if (i & 1 && i > 1 && i < 11)
      out += "-";
  }
  IDX++;
  return out;
}
var IDX, HEX, BUFFER;
var init_dist2 = __esm({
  "../../node_modules/@lukeed/uuid/dist/index.mjs"() {
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/logger/index.js
var CoreLogger;
var init_logger = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/logger/index.js"() {
    init_tslib_es6();
    CoreLogger = /** @class */
    function() {
      function CoreLogger2() {
        this._logs = [];
      }
      CoreLogger2.prototype.log = function(level, message2, extras) {
        var time = /* @__PURE__ */ new Date();
        this._logs.push({
          level,
          message: message2,
          time,
          extras
        });
      };
      Object.defineProperty(CoreLogger2.prototype, "logs", {
        get: function() {
          return this._logs;
        },
        enumerable: false,
        configurable: true
      });
      CoreLogger2.prototype.flush = function() {
        if (this.logs.length > 1) {
          var formatted = this._logs.reduce(function(logs, log) {
            var _a2;
            var _b2, _c;
            var line = __assign(__assign({}, log), { json: JSON.stringify(log.extras, null, " "), extras: log.extras });
            delete line["time"];
            var key = (_c = (_b2 = log.time) === null || _b2 === void 0 ? void 0 : _b2.toISOString()) !== null && _c !== void 0 ? _c : "";
            if (logs[key]) {
              key = "".concat(key, "-").concat(Math.random());
            }
            return __assign(__assign({}, logs), (_a2 = {}, _a2[key] = line, _a2));
          }, {});
          if (console.table) {
            console.table(formatted);
          } else {
            console.log(formatted);
          }
        } else {
          this.logs.forEach(function(logEntry) {
            var level = logEntry.level, message2 = logEntry.message, extras = logEntry.extras;
            if (level === "info" || level === "debug") {
              console.log(message2, extras !== null && extras !== void 0 ? extras : "");
            } else {
              console[level](message2, extras !== null && extras !== void 0 ? extras : "");
            }
          });
        }
        this._logs = [];
      };
      return CoreLogger2;
    }();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/stats/index.js
var compactMetricType, CoreStats, NullStats;
var init_stats = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/stats/index.js"() {
    init_tslib_es6();
    compactMetricType = function(type) {
      var enums = {
        gauge: "g",
        counter: "c"
      };
      return enums[type];
    };
    CoreStats = /** @class */
    function() {
      function CoreStats2() {
        this.metrics = [];
      }
      CoreStats2.prototype.increment = function(metric, by, tags) {
        if (by === void 0) {
          by = 1;
        }
        this.metrics.push({
          metric,
          value: by,
          tags: tags !== null && tags !== void 0 ? tags : [],
          type: "counter",
          timestamp: Date.now()
        });
      };
      CoreStats2.prototype.gauge = function(metric, value, tags) {
        this.metrics.push({
          metric,
          value,
          tags: tags !== null && tags !== void 0 ? tags : [],
          type: "gauge",
          timestamp: Date.now()
        });
      };
      CoreStats2.prototype.flush = function() {
        var formatted = this.metrics.map(function(m) {
          return __assign(__assign({}, m), { tags: m.tags.join(",") });
        });
        if (console.table) {
          console.table(formatted);
        } else {
          console.log(formatted);
        }
        this.metrics = [];
      };
      CoreStats2.prototype.serialize = function() {
        return this.metrics.map(function(m) {
          return {
            m: m.metric,
            v: m.value,
            t: m.tags,
            k: compactMetricType(m.type),
            e: m.timestamp
          };
        });
      };
      return CoreStats2;
    }();
    NullStats = /** @class */
    function(_super) {
      __extends(NullStats2, _super);
      function NullStats2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NullStats2.prototype.gauge = function() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          _args[_i] = arguments[_i];
        }
      };
      NullStats2.prototype.increment = function() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          _args[_i] = arguments[_i];
        }
      };
      NullStats2.prototype.flush = function() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          _args[_i] = arguments[_i];
        }
      };
      NullStats2.prototype.serialize = function() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          _args[_i] = arguments[_i];
        }
        return [];
      };
      return NullStats2;
    }(CoreStats);
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/context/index.js
var ContextCancelation, CoreContext;
var init_context = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/context/index.js"() {
    init_dist2();
    init_dist();
    init_logger();
    init_stats();
    ContextCancelation = /** @class */
    /* @__PURE__ */ function() {
      function ContextCancelation2(options) {
        var _a2, _b2, _c;
        this.retry = (_a2 = options.retry) !== null && _a2 !== void 0 ? _a2 : true;
        this.type = (_b2 = options.type) !== null && _b2 !== void 0 ? _b2 : "plugin Error";
        this.reason = (_c = options.reason) !== null && _c !== void 0 ? _c : "";
      }
      return ContextCancelation2;
    }();
    CoreContext = /** @class */
    function() {
      function CoreContext2(event, id, stats, logger) {
        if (id === void 0) {
          id = v4();
        }
        if (stats === void 0) {
          stats = new NullStats();
        }
        if (logger === void 0) {
          logger = new CoreLogger();
        }
        this.attempts = 0;
        this.event = event;
        this._id = id;
        this.logger = logger;
        this.stats = stats;
      }
      CoreContext2.system = function() {
      };
      CoreContext2.prototype.isSame = function(other) {
        return other.id === this.id;
      };
      CoreContext2.prototype.cancel = function(error) {
        if (error) {
          throw error;
        }
        throw new ContextCancelation({ reason: "Context Cancel" });
      };
      CoreContext2.prototype.log = function(level, message2, extras) {
        this.logger.log(level, message2, extras);
      };
      Object.defineProperty(CoreContext2.prototype, "id", {
        get: function() {
          return this._id;
        },
        enumerable: false,
        configurable: true
      });
      CoreContext2.prototype.updateEvent = function(path, val) {
        var _a2;
        if (path.split(".")[0] === "integrations") {
          var integrationName = path.split(".")[1];
          if (((_a2 = this.event.integrations) === null || _a2 === void 0 ? void 0 : _a2[integrationName]) === false) {
            return this.event;
          }
        }
        dset(this.event, path, val);
        return this.event;
      };
      CoreContext2.prototype.failedDelivery = function() {
        return this._failedDelivery;
      };
      CoreContext2.prototype.setFailedDelivery = function(options) {
        this._failedDelivery = options;
      };
      CoreContext2.prototype.logs = function() {
        return this.logger.logs;
      };
      CoreContext2.prototype.flush = function() {
        this.logger.flush();
        this.stats.flush();
      };
      CoreContext2.prototype.toJSON = function() {
        return {
          id: this._id,
          event: this.event,
          logs: this.logger.logs,
          metrics: this.stats.metrics
        };
      };
      return CoreContext2;
    }();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/utils/group-by.js
function groupBy(collection, grouper) {
  var results = {};
  collection.forEach(function(item) {
    var _a2;
    var key = void 0;
    if (typeof grouper === "string") {
      var suggestedKey = item[grouper];
      key = typeof suggestedKey !== "string" ? JSON.stringify(suggestedKey) : suggestedKey;
    } else if (grouper instanceof Function) {
      key = grouper(item);
    }
    if (key === void 0) {
      return;
    }
    results[key] = __spreadArray(__spreadArray([], (_a2 = results[key]) !== null && _a2 !== void 0 ? _a2 : [], true), [item], false);
  });
  return results;
}
var init_group_by = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/utils/group-by.js"() {
    init_tslib_es6();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/utils/is-thenable.js
var isThenable;
var init_is_thenable = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/utils/is-thenable.js"() {
    isThenable = function(value) {
      return typeof value === "object" && value !== null && "then" in value && typeof value.then === "function";
    };
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/task/task-group.js
var createTaskGroup;
var init_task_group = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/task/task-group.js"() {
    init_is_thenable();
    createTaskGroup = function() {
      var taskCompletionPromise;
      var resolvePromise;
      var count = 0;
      return {
        done: function() {
          return taskCompletionPromise;
        },
        run: function(op) {
          var returnValue = op();
          if (isThenable(returnValue)) {
            if (++count === 1) {
              taskCompletionPromise = new Promise(function(res) {
                return resolvePromise = res;
              });
            }
            returnValue.finally(function() {
              return --count === 0 && resolvePromise();
            });
          }
          return returnValue;
        }
      };
    };
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/queue/delivery.js
function tryAsync(fn) {
  return __awaiter(this, void 0, void 0, function() {
    var err_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 2, , 3]);
          return [4, fn()];
        case 1:
          return [2, _a2.sent()];
        case 2:
          err_1 = _a2.sent();
          return [2, Promise.reject(err_1)];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function attempt(ctx, plugin) {
  ctx.log("debug", "plugin", { plugin: plugin.name });
  var start = (/* @__PURE__ */ new Date()).getTime();
  var hook = plugin[ctx.event.type];
  if (hook === void 0) {
    return Promise.resolve(ctx);
  }
  var newCtx = tryAsync(function() {
    return hook.apply(plugin, [ctx]);
  }).then(function(ctx2) {
    var done = (/* @__PURE__ */ new Date()).getTime() - start;
    ctx2.stats.gauge("plugin_time", done, ["plugin:".concat(plugin.name)]);
    return ctx2;
  }).catch(function(err) {
    if (err instanceof ContextCancelation && err.type === "middleware_cancellation") {
      throw err;
    }
    if (err instanceof ContextCancelation) {
      ctx.log("warn", err.type, {
        plugin: plugin.name,
        error: err
      });
      return err;
    }
    ctx.log("error", "plugin Error", {
      plugin: plugin.name,
      error: err
    });
    ctx.stats.increment("plugin_error", 1, ["plugin:".concat(plugin.name)]);
    return err;
  });
  return newCtx;
}
function ensure(ctx, plugin) {
  return attempt(ctx, plugin).then(function(newContext) {
    if (newContext instanceof CoreContext) {
      return newContext;
    }
    ctx.log("debug", "Context canceled");
    ctx.stats.increment("context_canceled");
    ctx.cancel(newContext);
  });
}
var init_delivery = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/queue/delivery.js"() {
    init_tslib_es6();
    init_context();
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/queue/event-queue.js
var CoreEventQueue;
var init_event_queue = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/queue/event-queue.js"() {
    init_tslib_es6();
    init_group_by();
    init_priority_queue();
    init_context();
    init_esm();
    init_task_group();
    init_delivery();
    CoreEventQueue = /** @class */
    function(_super) {
      __extends(CoreEventQueue2, _super);
      function CoreEventQueue2(priorityQueue) {
        var _this = _super.call(this) || this;
        _this.criticalTasks = createTaskGroup();
        _this.plugins = [];
        _this.failedInitializations = [];
        _this.flushing = false;
        _this.queue = priorityQueue;
        _this.queue.on(ON_REMOVE_FROM_FUTURE, function() {
          _this.scheduleFlush(0);
        });
        return _this;
      }
      CoreEventQueue2.prototype.register = function(ctx, plugin, instance) {
        return __awaiter(this, void 0, void 0, function() {
          var handleLoadError, err_1;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.plugins.push(plugin);
                handleLoadError = function(err) {
                  _this.failedInitializations.push(plugin.name);
                  _this.emit("initialization_failure", plugin);
                  console.warn(plugin.name, err);
                  ctx.log("warn", "Failed to load destination", {
                    plugin: plugin.name,
                    error: err
                  });
                  _this.plugins = _this.plugins.filter(function(p) {
                    return p !== plugin;
                  });
                };
                if (!(plugin.type === "destination" && plugin.name !== "Segment.io"))
                  return [3, 1];
                plugin.load(ctx, instance).catch(handleLoadError);
                return [3, 4];
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, plugin.load(ctx, instance)];
              case 2:
                _a2.sent();
                return [3, 4];
              case 3:
                err_1 = _a2.sent();
                handleLoadError(err_1);
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CoreEventQueue2.prototype.deregister = function(ctx, plugin, instance) {
        return __awaiter(this, void 0, void 0, function() {
          var e_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 3, , 4]);
                if (!plugin.unload)
                  return [3, 2];
                return [4, Promise.resolve(plugin.unload(ctx, instance))];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                this.plugins = this.plugins.filter(function(p) {
                  return p.name !== plugin.name;
                });
                return [3, 4];
              case 3:
                e_1 = _a2.sent();
                ctx.log("warn", "Failed to unload destination", {
                  plugin: plugin.name,
                  error: e_1
                });
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CoreEventQueue2.prototype.dispatch = function(ctx) {
        return __awaiter(this, void 0, void 0, function() {
          var willDeliver;
          return __generator(this, function(_a2) {
            ctx.log("debug", "Dispatching");
            ctx.stats.increment("message_dispatched");
            this.queue.push(ctx);
            willDeliver = this.subscribeToDelivery(ctx);
            this.scheduleFlush(0);
            return [2, willDeliver];
          });
        });
      };
      CoreEventQueue2.prototype.subscribeToDelivery = function(ctx) {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a2) {
            return [2, new Promise(function(resolve) {
              var onDeliver = function(flushed, delivered) {
                if (flushed.isSame(ctx)) {
                  _this.off("flush", onDeliver);
                  if (delivered) {
                    resolve(flushed);
                  } else {
                    resolve(flushed);
                  }
                }
              };
              _this.on("flush", onDeliver);
            })];
          });
        });
      };
      CoreEventQueue2.prototype.dispatchSingle = function(ctx) {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a2) {
            ctx.log("debug", "Dispatching");
            ctx.stats.increment("message_dispatched");
            this.queue.updateAttempts(ctx);
            ctx.attempts = 1;
            return [2, this.deliver(ctx).catch(function(err) {
              var accepted = _this.enqueuRetry(err, ctx);
              if (!accepted) {
                ctx.setFailedDelivery({ reason: err });
                return ctx;
              }
              return _this.subscribeToDelivery(ctx);
            })];
          });
        });
      };
      CoreEventQueue2.prototype.isEmpty = function() {
        return this.queue.length === 0;
      };
      CoreEventQueue2.prototype.scheduleFlush = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = 500;
        }
        if (this.flushing) {
          return;
        }
        this.flushing = true;
        setTimeout(function() {
          _this.flush().then(function() {
            setTimeout(function() {
              _this.flushing = false;
              if (_this.queue.length) {
                _this.scheduleFlush(0);
              }
            }, 0);
          });
        }, timeout);
      };
      CoreEventQueue2.prototype.deliver = function(ctx) {
        return __awaiter(this, void 0, void 0, function() {
          var start, done, err_2, error;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.criticalTasks.done()];
              case 1:
                _a2.sent();
                start = Date.now();
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 4, , 5]);
                return [4, this.flushOne(ctx)];
              case 3:
                ctx = _a2.sent();
                done = Date.now() - start;
                this.emit("delivery_success", ctx);
                ctx.stats.gauge("delivered", done);
                ctx.log("debug", "Delivered", ctx.event);
                return [2, ctx];
              case 4:
                err_2 = _a2.sent();
                error = err_2;
                ctx.log("error", "Failed to deliver", error);
                this.emit("delivery_failure", ctx, error);
                ctx.stats.increment("delivery_failed");
                throw err_2;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CoreEventQueue2.prototype.enqueuRetry = function(err, ctx) {
        var retriable = !(err instanceof ContextCancelation) || err.retry;
        if (!retriable) {
          return false;
        }
        return this.queue.pushWithBackoff(ctx);
      };
      CoreEventQueue2.prototype.flush = function() {
        return __awaiter(this, void 0, void 0, function() {
          var ctx, err_3, accepted;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (this.queue.length === 0) {
                  return [2, []];
                }
                ctx = this.queue.pop();
                if (!ctx) {
                  return [2, []];
                }
                ctx.attempts = this.queue.getAttempts(ctx);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.deliver(ctx)];
              case 2:
                ctx = _a2.sent();
                this.emit("flush", ctx, true);
                return [3, 4];
              case 3:
                err_3 = _a2.sent();
                accepted = this.enqueuRetry(err_3, ctx);
                if (!accepted) {
                  ctx.setFailedDelivery({ reason: err_3 });
                  this.emit("flush", ctx, false);
                }
                return [2, []];
              case 4:
                return [2, [ctx]];
            }
          });
        });
      };
      CoreEventQueue2.prototype.isReady = function() {
        return true;
      };
      CoreEventQueue2.prototype.availableExtensions = function(denyList) {
        var available = this.plugins.filter(function(p) {
          var _a3, _b3, _c2;
          if (p.type !== "destination" && p.name !== "Segment.io") {
            return true;
          }
          var alternativeNameMatch = void 0;
          (_a3 = p.alternativeNames) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(name) {
            if (denyList[name] !== void 0) {
              alternativeNameMatch = denyList[name];
            }
          });
          return (_c2 = (_b3 = denyList[p.name]) !== null && _b3 !== void 0 ? _b3 : alternativeNameMatch) !== null && _c2 !== void 0 ? _c2 : (p.name === "Segment.io" ? true : denyList.All) !== false;
        });
        var _a2 = groupBy(available, "type"), _b2 = _a2.before, before = _b2 === void 0 ? [] : _b2, _c = _a2.enrichment, enrichment = _c === void 0 ? [] : _c, _d = _a2.destination, destination = _d === void 0 ? [] : _d, _e = _a2.after, after = _e === void 0 ? [] : _e;
        return {
          before,
          enrichment,
          destinations: destination,
          after
        };
      };
      CoreEventQueue2.prototype.flushOne = function(ctx) {
        var _a2, _b2;
        return __awaiter(this, void 0, void 0, function() {
          var _c, before, enrichment, _i, before_1, beforeWare, temp, _d, enrichment_1, enrichmentWare, temp, _e, destinations, after, afterCalls;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                if (!this.isReady()) {
                  throw new Error("Not ready");
                }
                if (ctx.attempts > 1) {
                  this.emit("delivery_retry", ctx);
                }
                _c = this.availableExtensions((_a2 = ctx.event.integrations) !== null && _a2 !== void 0 ? _a2 : {}), before = _c.before, enrichment = _c.enrichment;
                _i = 0, before_1 = before;
                _f.label = 1;
              case 1:
                if (!(_i < before_1.length))
                  return [3, 4];
                beforeWare = before_1[_i];
                return [4, ensure(ctx, beforeWare)];
              case 2:
                temp = _f.sent();
                if (temp instanceof CoreContext) {
                  ctx = temp;
                }
                this.emit("message_enriched", ctx, beforeWare);
                _f.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                _d = 0, enrichment_1 = enrichment;
                _f.label = 5;
              case 5:
                if (!(_d < enrichment_1.length))
                  return [3, 8];
                enrichmentWare = enrichment_1[_d];
                return [4, attempt(ctx, enrichmentWare)];
              case 6:
                temp = _f.sent();
                if (temp instanceof CoreContext) {
                  ctx = temp;
                }
                this.emit("message_enriched", ctx, enrichmentWare);
                _f.label = 7;
              case 7:
                _d++;
                return [3, 5];
              case 8:
                _e = this.availableExtensions((_b2 = ctx.event.integrations) !== null && _b2 !== void 0 ? _b2 : {}), destinations = _e.destinations, after = _e.after;
                return [4, new Promise(function(resolve, reject) {
                  setTimeout(function() {
                    var attempts = destinations.map(function(destination) {
                      return attempt(ctx, destination);
                    });
                    Promise.all(attempts).then(resolve).catch(reject);
                  }, 0);
                })];
              case 9:
                _f.sent();
                ctx.stats.increment("message_delivered");
                this.emit("message_delivered", ctx);
                afterCalls = after.map(function(after2) {
                  return attempt(ctx, after2);
                });
                return [4, Promise.all(afterCalls)];
              case 10:
                _f.sent();
                return [2, ctx];
            }
          });
        });
      };
      return CoreEventQueue2;
    }(Emitter);
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/analytics/index.js
var init_analytics = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/analytics/index.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/analytics/dispatch.js
function dispatch(ctx, queue, emitter, options) {
  return __awaiter(this, void 0, void 0, function() {
    var startTime, dispatched;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          emitter.emit("dispatch_start", ctx);
          startTime = Date.now();
          if (!queue.isEmpty())
            return [3, 2];
          return [4, queue.dispatchSingle(ctx)];
        case 1:
          dispatched = _a2.sent();
          return [3, 4];
        case 2:
          return [4, queue.dispatch(ctx)];
        case 3:
          dispatched = _a2.sent();
          _a2.label = 4;
        case 4:
          if (!(options === null || options === void 0 ? void 0 : options.callback))
            return [3, 6];
          return [4, invokeCallback(dispatched, options.callback, getDelay(startTime, options.timeout))];
        case 5:
          dispatched = _a2.sent();
          _a2.label = 6;
        case 6:
          if (options === null || options === void 0 ? void 0 : options.debug) {
            dispatched.flush();
          }
          return [2, dispatched];
      }
    });
  });
}
var getDelay;
var init_dispatch = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/analytics/dispatch.js"() {
    init_tslib_es6();
    init_callback();
    getDelay = function(startTimeInEpochMS, timeoutInMS) {
      var elapsedTime = Date.now() - startTimeInEpochMS;
      return Math.max((timeoutInMS !== null && timeoutInMS !== void 0 ? timeoutInMS : 300) - elapsedTime, 0);
    };
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/utils/bind-all.js
function bindAll(obj) {
  var proto = obj.constructor.prototype;
  for (var _i = 0, _a2 = Object.getOwnPropertyNames(proto); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (key !== "constructor") {
      var desc = Object.getOwnPropertyDescriptor(obj.constructor.prototype, key);
      if (!!desc && typeof desc.value === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  return obj;
}
var init_bind_all = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/utils/bind-all.js"() {
  }
});

// ../../node_modules/@segment/analytics-core/dist/esm/index.js
var init_esm2 = __esm({
  "../../node_modules/@segment/analytics-core/dist/esm/index.js"() {
    init_interface();
    init_plugins();
    init_interfaces();
    init_events();
    init_callback();
    init_priority_queue();
    init_backoff();
    init_context();
    init_event_queue();
    init_analytics();
    init_dispatch();
    init_helpers();
    init_errors();
    init_assertions();
    init_bind_all();
    init_stats();
    init_logger();
    init_delivery();
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/settings.js
var validateSettings;
var init_settings = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/settings.js"() {
    init_esm2();
    validateSettings = (settings) => {
      if (!settings.writeKey) {
        throw new ValidationError("writeKey", "writeKey is missing.");
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/generated/version.js
var version;
var init_version = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/generated/version.js"() {
    version = "2.1.2";
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/create-url.js
var stripTrailingSlash, tryCreateFormattedUrl;
var init_create_url = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/create-url.js"() {
    stripTrailingSlash = (str) => str.replace(/\/$/, "");
    tryCreateFormattedUrl = (host, path) => {
      return stripTrailingSlash(new URL(path || "", host).href);
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/uuid.js
var init_uuid = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/uuid.js"() {
    init_dist2();
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/context-batch.js
var MAX_EVENT_SIZE_IN_KB, MAX_BATCH_SIZE_IN_KB, ContextBatch;
var init_context_batch = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/context-batch.js"() {
    init_uuid();
    MAX_EVENT_SIZE_IN_KB = 32;
    MAX_BATCH_SIZE_IN_KB = 480;
    ContextBatch = class {
      constructor(maxEventCount) {
        __publicField(this, "id", v4());
        __publicField(this, "items", []);
        __publicField(this, "sizeInBytes", 0);
        __publicField(this, "maxEventCount");
        this.maxEventCount = Math.max(1, maxEventCount);
      }
      tryAdd(item) {
        if (this.length === this.maxEventCount)
          return {
            success: false,
            message: `Event limit of ${this.maxEventCount} has been exceeded.`
          };
        const eventSize = this.calculateSize(item.context);
        if (eventSize > MAX_EVENT_SIZE_IN_KB * 1024) {
          return {
            success: false,
            message: `Event exceeds maximum event size of ${MAX_EVENT_SIZE_IN_KB} KB`
          };
        }
        if (this.sizeInBytes + eventSize > MAX_BATCH_SIZE_IN_KB * 1024) {
          return {
            success: false,
            message: `Event has caused batch size to exceed ${MAX_BATCH_SIZE_IN_KB} KB`
          };
        }
        this.items.push(item);
        this.sizeInBytes += eventSize;
        return { success: true };
      }
      get length() {
        return this.items.length;
      }
      calculateSize(ctx) {
        return encodeURI(JSON.stringify(ctx.event)).split(/%..|i/).length;
      }
      getEvents() {
        const events = this.items.map(({ context }) => context.event);
        return events;
      }
      getContexts() {
        return this.items.map((item) => item.context);
      }
      resolveEvents() {
        this.items.forEach(({ resolver, context }) => resolver(context));
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "../../node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// ../../node_modules/jose/dist/browser/runtime/digest.js
var init_digest = __esm({
  "../../node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
  }
});

// ../../node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "../../node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest();
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// ../../node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode, decodeBase64, decode;
var init_base64url = __esm({
  "../../node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors2 = __esm({
  "../../node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        var _a2;
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "../../node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// ../../node_modules/jose/dist/browser/lib/iv.js
var init_iv = __esm({
  "../../node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors2();
    init_random();
  }
});

// ../../node_modules/jose/dist/browser/lib/check_iv_length.js
var init_check_iv_length = __esm({
  "../../node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors2();
    init_iv();
  }
});

// ../../node_modules/jose/dist/browser/runtime/check_cek_length.js
var init_check_cek_length = __esm({
  "../../node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var init_timing_safe_equal = __esm({
  "../../node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
  }
});

// ../../node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "../../node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// ../../node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  var _a2;
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if ((_a2 = actual.constructor) == null ? void 0 : _a2.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "../../node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});

// ../../node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "../../node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});

// ../../node_modules/jose/dist/browser/runtime/decrypt.js
var init_decrypt = __esm({
  "../../node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors2();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "../../node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// ../../node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "../../node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// ../../node_modules/jose/dist/browser/runtime/bogus.js
var init_bogus = __esm({
  "../../node_modules/jose/dist/browser/runtime/bogus.js"() {
  }
});

// ../../node_modules/jose/dist/browser/runtime/aeskw.js
var init_aeskw = __esm({
  "../../node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/runtime/ecdhes.js
var init_ecdhes = __esm({
  "../../node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/lib/check_p2s.js
var init_check_p2s = __esm({
  "../../node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/pbes2kw.js
var init_pbes2kw = __esm({
  "../../node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/runtime/subtle_rsaes.js
var init_subtle_rsaes = __esm({
  "../../node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "../../node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/runtime/rsaes.js
var init_rsaes = __esm({
  "../../node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/lib/cek.js
var init_cek = __esm({
  "../../node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors2();
    init_random();
  }
});

// ../../node_modules/jose/dist/browser/lib/format_pem.js
var init_format_pem = __esm({
  "../../node_modules/jose/dist/browser/lib/format_pem.js"() {
  }
});

// ../../node_modules/jose/dist/browser/runtime/asn1.js
var findOid, getNamedCurve2, genericImport, fromPKCS8;
var init_asn1 = __esm({
  "../../node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors2();
    init_is_key_like();
    findOid = (keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      const i = keyData.indexOf(oid[0], from);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (options == null ? void 0 : options.extractable) ?? false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
  }
});

// ../../node_modules/jose/dist/browser/runtime/jwk_to_key.js
var init_jwk_to_key = __esm({
  "../../node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/key/import.js
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
var init_import = __esm({
  "../../node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors2();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "../../node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// ../../node_modules/jose/dist/browser/runtime/encrypt.js
var init_encrypt = __esm({
  "../../node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_iv();
    init_errors2();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/lib/aesgcmkw.js
var init_aesgcmkw = __esm({
  "../../node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_base64url();
  }
});

// ../../node_modules/jose/dist/browser/lib/decrypt_key_management.js
var init_decrypt_key_management = __esm({
  "../../node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors2();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
  }
});

// ../../node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && (protectedHeader == null ? void 0 : protectedHeader.crit) === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "../../node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors2();
    validate_crit_default = validateCrit;
  }
});

// ../../node_modules/jose/dist/browser/lib/validate_algorithms.js
var init_validate_algorithms = __esm({
  "../../node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
  }
});

// ../../node_modules/jose/dist/browser/jwe/flattened/decrypt.js
var init_decrypt2 = __esm({
  "../../node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_errors2();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// ../../node_modules/jose/dist/browser/jwe/compact/decrypt.js
var init_decrypt3 = __esm({
  "../../node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors2();
    init_buffer_utils();
  }
});

// ../../node_modules/jose/dist/browser/jwe/general/decrypt.js
var init_decrypt4 = __esm({
  "../../node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors2();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/runtime/key_to_jwk.js
var init_key_to_jwk = __esm({
  "../../node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/key/export.js
var init_export = __esm({
  "../../node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// ../../node_modules/jose/dist/browser/lib/encrypt_key_management.js
var init_encrypt_key_management = __esm({
  "../../node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors2();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
  }
});

// ../../node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected;
var init_encrypt2 = __esm({
  "../../node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_encrypt_key_management();
    init_errors2();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
  }
});

// ../../node_modules/jose/dist/browser/jwe/general/encrypt.js
var init_encrypt3 = __esm({
  "../../node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors2();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
  }
});

// ../../node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "../../node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "../../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// ../../node_modules/jose/dist/browser/runtime/verify.js
var init_verify = __esm({
  "../../node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
  }
});

// ../../node_modules/jose/dist/browser/jws/flattened/verify.js
var init_verify2 = __esm({
  "../../node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors2();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// ../../node_modules/jose/dist/browser/jws/compact/verify.js
var init_verify3 = __esm({
  "../../node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors2();
    init_buffer_utils();
  }
});

// ../../node_modules/jose/dist/browser/jws/general/verify.js
var init_verify4 = __esm({
  "../../node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors2();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "../../node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// ../../node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "../../node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched || matched[4] && matched[1]) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[2]);
      const unit = matched[3].toLowerCase();
      let numericDate;
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          numericDate = Math.round(value);
          break;
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          numericDate = Math.round(value * minute);
          break;
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          numericDate = Math.round(value * hour);
          break;
        case "day":
        case "days":
        case "d":
          numericDate = Math.round(value * day);
          break;
        case "week":
        case "weeks":
        case "w":
          numericDate = Math.round(value * week);
          break;
        default:
          numericDate = Math.round(value * year);
          break;
      }
      if (matched[1] === "-" || matched[4] === "ago") {
        return -numericDate;
      }
      return numericDate;
    };
  }
});

// ../../node_modules/jose/dist/browser/lib/jwt_claims_set.js
var init_jwt_claims_set = __esm({
  "../../node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors2();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/jwt/verify.js
var init_verify5 = __esm({
  "../../node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/jwt/decrypt.js
var init_decrypt5 = __esm({
  "../../node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/jwe/compact/encrypt.js
var init_encrypt4 = __esm({
  "../../node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "../../node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// ../../node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "../../node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors2();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options == null ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "../../node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/jws/general/sign.js
var init_sign4 = __esm({
  "../../node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var ProduceJWT;
var init_produce = __esm({
  "../../node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload = {}) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
        } else if (typeof input === "string") {
          this._payload = {
            ...this._payload,
            iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
          };
        } else {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
        }
        return this;
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "../../node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors2();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a2;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a2 = this._protectedHeader) == null ? void 0 : _a2.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// ../../node_modules/jose/dist/browser/jwt/encrypt.js
var init_encrypt5 = __esm({
  "../../node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
  }
});

// ../../node_modules/jose/dist/browser/jwk/thumbprint.js
var init_thumbprint = __esm({
  "../../node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest();
    init_base64url();
    init_errors2();
    init_buffer_utils();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/jwk/embedded.js
var init_embedded = __esm({
  "../../node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/jwks/local.js
var init_local = __esm({
  "../../node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors2();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/runtime/fetch_jwks.js
var init_fetch_jwks = __esm({
  "../../node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT, _a, _b;
var init_remote = __esm({
  "../../node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors2();
    init_local();
    if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
      const NAME = "jose";
      const VERSION = "v5.4.1";
      USER_AGENT = `${NAME}/${VERSION}`;
    }
  }
});

// ../../node_modules/jose/dist/browser/jwt/unsecured.js
var init_unsecured = __esm({
  "../../node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors2();
    init_jwt_claims_set();
    init_produce();
  }
});

// ../../node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2, decode2;
var init_base64url2 = __esm({
  "../../node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
    encode2 = encode;
    decode2 = decode;
  }
});

// ../../node_modules/jose/dist/browser/util/decode_protected_header.js
var init_decode_protected_header = __esm({
  "../../node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// ../../node_modules/jose/dist/browser/util/decode_jwt.js
var init_decode_jwt = __esm({
  "../../node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors2();
  }
});

// ../../node_modules/jose/dist/browser/runtime/generate.js
var init_generate = __esm({
  "../../node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors2();
    init_random();
  }
});

// ../../node_modules/jose/dist/browser/key/generate_key_pair.js
var init_generate_key_pair = __esm({
  "../../node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// ../../node_modules/jose/dist/browser/key/generate_secret.js
var init_generate_secret = __esm({
  "../../node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});

// ../../node_modules/jose/dist/browser/runtime/runtime.js
var init_runtime = __esm({
  "../../node_modules/jose/dist/browser/runtime/runtime.js"() {
  }
});

// ../../node_modules/jose/dist/browser/util/runtime.js
var init_runtime2 = __esm({
  "../../node_modules/jose/dist/browser/util/runtime.js"() {
    init_runtime();
  }
});

// ../../node_modules/jose/dist/browser/index.js
var init_browser = __esm({
  "../../node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors2();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/token-manager.js
function convertHeaders(headers) {
  const lowercaseHeaders = {};
  if (!headers)
    return {};
  if (isHeaders(headers)) {
    for (const [name, value] of headers.entries()) {
      lowercaseHeaders[name.toLowerCase()] = value;
    }
    return lowercaseHeaders;
  }
  for (const [name, value] of Object.entries(headers)) {
    lowercaseHeaders[name.toLowerCase()] = value;
  }
  return lowercaseHeaders;
}
function isHeaders(thing) {
  if (typeof thing === "object" && thing !== null && "entries" in Object(thing) && typeof Object(thing).entries === "function") {
    return true;
  }
  return false;
}
var isAccessToken, isValidCustomResponse, TokenManager;
var init_token_manager = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/token-manager.js"() {
    init_uuid();
    init_browser();
    init_esm2();
    init_esm();
    isAccessToken = (thing) => {
      return Boolean(thing && typeof thing === "object" && "access_token" in thing && "expires_in" in thing && typeof thing.access_token === "string" && typeof thing.expires_in === "number");
    };
    isValidCustomResponse = (response) => {
      return typeof response.text === "function";
    };
    TokenManager = class {
      constructor(props) {
        __publicField(this, "alg", "RS256");
        __publicField(this, "grantType", "client_credentials");
        __publicField(this, "clientAssertionType", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
        __publicField(this, "clientId");
        __publicField(this, "clientKey");
        __publicField(this, "keyId");
        __publicField(this, "scope");
        __publicField(this, "authServer");
        __publicField(this, "httpClient");
        __publicField(this, "maxRetries");
        __publicField(this, "clockSkewInSeconds", 0);
        __publicField(this, "accessToken");
        __publicField(this, "tokenEmitter", new Emitter());
        __publicField(this, "retryCount");
        __publicField(this, "pollerTimer");
        this.keyId = props.keyId;
        this.clientId = props.clientId;
        this.clientKey = props.clientKey;
        this.authServer = props.authServer ?? "https://oauth2.segment.io";
        this.scope = props.scope ?? "tracking_api:write";
        this.httpClient = props.httpClient;
        this.maxRetries = props.maxRetries;
        this.tokenEmitter.on("access_token", (event) => {
          if ("token" in event) {
            this.accessToken = event.token;
          }
        });
        this.retryCount = 0;
      }
      stopPoller() {
        clearTimeout(this.pollerTimer);
      }
      async pollerLoop() {
        let timeUntilRefreshInMs = 25;
        let response;
        try {
          response = await this.requestAccessToken();
        } catch (err) {
          return this.handleTransientError({ error: err });
        }
        if (!isValidCustomResponse(response)) {
          return this.handleInvalidCustomResponse();
        }
        const headers = convertHeaders(response.headers);
        if (headers["date"]) {
          this.updateClockSkew(Date.parse(headers["date"]));
        }
        if (response.status === 200) {
          try {
            const body = await response.text();
            const token = JSON.parse(body);
            if (!isAccessToken(token)) {
              throw new Error("Response did not contain a valid access_token and expires_in");
            }
            token.expires_at = Math.round(Date.now() / 1e3) + token.expires_in;
            this.tokenEmitter.emit("access_token", { token });
            this.retryCount = 0;
            timeUntilRefreshInMs = token.expires_in / 2 * 1e3;
            return this.queueNextPoll(timeUntilRefreshInMs);
          } catch (err) {
            return this.handleTransientError({ error: err, forceEmitError: true });
          }
        } else if (response.status === 429) {
          return await this.handleRateLimited(response, headers, timeUntilRefreshInMs);
        } else if ([400, 401, 415].includes(response.status)) {
          return this.handleUnrecoverableErrors(response);
        } else {
          return this.handleTransientError({
            error: new Error(`[${response.status}] ${response.statusText}`)
          });
        }
      }
      handleTransientError({ error, forceEmitError }) {
        this.incrementRetries({ error, forceEmitError });
        const timeUntilRefreshInMs = backoff({
          attempt: this.retryCount,
          minTimeout: 25,
          maxTimeout: 1e3
        });
        this.queueNextPoll(timeUntilRefreshInMs);
      }
      handleInvalidCustomResponse() {
        this.tokenEmitter.emit("access_token", {
          error: new Error("HTTPClient does not implement response.text method")
        });
      }
      async handleRateLimited(response, headers, timeUntilRefreshInMs) {
        this.incrementRetries({
          error: new Error(`[${response.status}] ${response.statusText}`)
        });
        if (headers["x-ratelimit-reset"]) {
          const rateLimitResetTimestamp = parseInt(headers["x-ratelimit-reset"], 10);
          if (isFinite(rateLimitResetTimestamp)) {
            timeUntilRefreshInMs = rateLimitResetTimestamp - Date.now() + this.clockSkewInSeconds * 1e3;
          } else {
            timeUntilRefreshInMs = 5 * 1e3;
          }
          await sleep(timeUntilRefreshInMs);
          timeUntilRefreshInMs = 0;
        }
        this.queueNextPoll(timeUntilRefreshInMs);
      }
      handleUnrecoverableErrors(response) {
        this.retryCount = 0;
        this.tokenEmitter.emit("access_token", {
          error: new Error(`[${response.status}] ${response.statusText}`)
        });
        this.stopPoller();
      }
      updateClockSkew(dateInMs) {
        this.clockSkewInSeconds = (Date.now() - dateInMs) / 1e3;
      }
      incrementRetries({ error, forceEmitError }) {
        this.retryCount++;
        if (forceEmitError || this.retryCount % this.maxRetries === 0) {
          this.retryCount = 0;
          this.tokenEmitter.emit("access_token", { error });
        }
      }
      queueNextPoll(timeUntilRefreshInMs) {
        this.pollerTimer = setTimeout(() => this.pollerLoop(), timeUntilRefreshInMs);
        if (this.pollerTimer.unref) {
          this.pollerTimer.unref();
        }
      }
      /**
       * Solely responsible for building the HTTP request and calling the token service.
       */
      async requestAccessToken() {
        const ISSUED_AT_BUFFER_IN_SECONDS = 5;
        const MAX_EXPIRY_IN_SECONDS = 60;
        const EXPIRY_IN_SECONDS = MAX_EXPIRY_IN_SECONDS - ISSUED_AT_BUFFER_IN_SECONDS;
        const jti = v4();
        const currentUTCInSeconds = Math.round(Date.now() / 1e3) - this.clockSkewInSeconds;
        const jwtBody = {
          iss: this.clientId,
          sub: this.clientId,
          aud: this.authServer,
          iat: currentUTCInSeconds - ISSUED_AT_BUFFER_IN_SECONDS,
          exp: currentUTCInSeconds + EXPIRY_IN_SECONDS,
          jti
        };
        const key = await importPKCS8(this.clientKey, "RS256");
        const signedJwt = await new SignJWT(jwtBody).setProtectedHeader({ alg: this.alg, kid: this.keyId, typ: "JWT" }).sign(key);
        const requestBody = `grant_type=${this.grantType}&client_assertion_type=${this.clientAssertionType}&client_assertion=${signedJwt}&scope=${this.scope}`;
        const accessTokenEndpoint = `${this.authServer}/token`;
        const requestOptions = {
          method: "POST",
          url: accessTokenEndpoint,
          body: requestBody,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          httpRequestTimeout: 1e4
        };
        return this.httpClient.makeRequest(requestOptions);
      }
      async getAccessToken() {
        if (this.isValidToken(this.accessToken)) {
          return this.accessToken;
        }
        this.stopPoller();
        this.pollerLoop().catch(() => {
        });
        return new Promise((resolve, reject) => {
          this.tokenEmitter.once("access_token", (event) => {
            if ("token" in event) {
              resolve(event.token);
            } else {
              reject(event.error);
            }
          });
        });
      }
      clearToken() {
        this.accessToken = void 0;
      }
      isValidToken(token) {
        return typeof token !== "undefined" && token !== null && token.expires_in < Date.now() / 1e3;
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/publisher.js
function sleep2(timeoutInMs) {
  return new Promise((resolve) => setTimeout(resolve, timeoutInMs));
}
function noop() {
}
function resolveFailedBatch(batch, reason) {
  batch.getContexts().forEach((ctx) => ctx.setFailedDelivery({ reason }));
  batch.resolveEvents();
}
var Publisher;
var init_publisher = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/publisher.js"() {
    init_esm2();
    init_create_url();
    init_esm();
    init_context_batch();
    init_token_manager();
    Publisher = class {
      constructor({ host, path, maxRetries, flushAt, flushInterval, writeKey, httpRequestTimeout, httpClient, disable, oauthSettings }, emitter) {
        __publicField(this, "pendingFlushTimeout");
        __publicField(this, "_batch");
        __publicField(this, "_flushInterval");
        __publicField(this, "_flushAt");
        __publicField(this, "_maxRetries");
        __publicField(this, "_url");
        __publicField(this, "_flushPendingItemsCount");
        __publicField(this, "_httpRequestTimeout");
        __publicField(this, "_emitter");
        __publicField(this, "_disable");
        __publicField(this, "_httpClient");
        __publicField(this, "_writeKey");
        __publicField(this, "_tokenManager");
        this._emitter = emitter;
        this._maxRetries = maxRetries;
        this._flushAt = Math.max(flushAt, 1);
        this._flushInterval = flushInterval;
        this._url = tryCreateFormattedUrl(host ?? "https://api.segment.io", path ?? "/v1/batch");
        this._httpRequestTimeout = httpRequestTimeout ?? 1e4;
        this._disable = Boolean(disable);
        this._httpClient = httpClient;
        this._writeKey = writeKey;
        if (oauthSettings) {
          this._tokenManager = new TokenManager({
            ...oauthSettings,
            httpClient: oauthSettings.httpClient ?? httpClient,
            maxRetries: oauthSettings.maxRetries ?? maxRetries
          });
        }
      }
      createBatch() {
        this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout);
        const batch = new ContextBatch(this._flushAt);
        this._batch = batch;
        this.pendingFlushTimeout = setTimeout(() => {
          if (batch === this._batch) {
            this._batch = void 0;
          }
          this.pendingFlushTimeout = void 0;
          if (batch.length) {
            this.send(batch).catch(noop);
          }
        }, this._flushInterval);
        return batch;
      }
      clearBatch() {
        this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout);
        this._batch = void 0;
      }
      flush(pendingItemsCount) {
        if (!pendingItemsCount) {
          if (this._tokenManager) {
            this._tokenManager.stopPoller();
          }
          return;
        }
        this._flushPendingItemsCount = pendingItemsCount;
        if (!this._batch)
          return;
        const isExpectingNoMoreItems = this._batch.length === pendingItemsCount;
        if (isExpectingNoMoreItems) {
          this.send(this._batch).catch(noop).finally(() => {
            if (this._tokenManager) {
              this._tokenManager.stopPoller();
            }
          });
          this.clearBatch();
        }
      }
      /**
       * Enqueues the context for future delivery.
       * @param ctx - Context containing a Segment event.
       * @returns a promise that resolves with the context after the event has been delivered.
       */
      enqueue(ctx) {
        const batch = this._batch ?? this.createBatch();
        const { promise: ctxPromise, resolve } = createDeferred();
        const pendingItem = {
          context: ctx,
          resolver: resolve
        };
        const addStatus = batch.tryAdd(pendingItem);
        if (addStatus.success) {
          const isExpectingNoMoreItems = batch.length === this._flushPendingItemsCount;
          const isFull = batch.length === this._flushAt;
          if (isFull || isExpectingNoMoreItems) {
            this.send(batch).catch(noop);
            this.clearBatch();
          }
          return ctxPromise;
        }
        if (batch.length) {
          this.send(batch).catch(noop);
          this.clearBatch();
        }
        const fallbackBatch = this.createBatch();
        const fbAddStatus = fallbackBatch.tryAdd(pendingItem);
        if (fbAddStatus.success) {
          const isExpectingNoMoreItems = fallbackBatch.length === this._flushPendingItemsCount;
          if (isExpectingNoMoreItems) {
            this.send(fallbackBatch).catch(noop);
            this.clearBatch();
          }
          return ctxPromise;
        } else {
          ctx.setFailedDelivery({
            reason: new Error(fbAddStatus.message)
          });
          return Promise.resolve(ctx);
        }
      }
      async send(batch) {
        if (this._flushPendingItemsCount) {
          this._flushPendingItemsCount -= batch.length;
        }
        const events = batch.getEvents();
        const maxAttempts = this._maxRetries + 1;
        let currentAttempt = 0;
        while (currentAttempt < maxAttempts) {
          currentAttempt++;
          let failureReason;
          try {
            if (this._disable) {
              return batch.resolveEvents();
            }
            let authString = void 0;
            if (this._tokenManager) {
              const token = await this._tokenManager.getAccessToken();
              if (token && token.access_token) {
                authString = `Bearer ${token.access_token}`;
              }
            }
            const headers = {
              "Content-Type": "application/json",
              "User-Agent": "analytics-node-next/latest",
              ...authString ? { Authorization: authString } : {}
            };
            const request = {
              url: this._url,
              method: "POST",
              headers,
              body: JSON.stringify({
                batch: events,
                writeKey: this._writeKey,
                sentAt: /* @__PURE__ */ new Date()
              }),
              httpRequestTimeout: this._httpRequestTimeout
            };
            this._emitter.emit("http_request", {
              body: request.body,
              method: request.method,
              url: request.url,
              headers: request.headers
            });
            const response = await this._httpClient.makeRequest(request);
            if (response.status >= 200 && response.status < 300) {
              batch.resolveEvents();
              return;
            } else if (this._tokenManager && (response.status === 400 || response.status === 401 || response.status === 403)) {
              this._tokenManager.clearToken();
              failureReason = new Error(`[${response.status}] ${response.statusText}`);
            } else if (response.status === 400) {
              resolveFailedBatch(batch, new Error(`[${response.status}] ${response.statusText}`));
              return;
            } else {
              failureReason = new Error(`[${response.status}] ${response.statusText}`);
            }
          } catch (err) {
            failureReason = err;
          }
          if (currentAttempt === maxAttempts) {
            resolveFailedBatch(batch, failureReason);
            return;
          }
          await sleep2(backoff({
            attempt: currentAttempt,
            minTimeout: 25,
            maxTimeout: 1e3
          }));
        }
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/env.js
var detectRuntime;
var init_env = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/env.js"() {
    detectRuntime = () => {
      if (typeof process === "object" && process && typeof process.env === "object" && process.env && typeof process.version === "string") {
        return "node";
      }
      if (typeof window === "object") {
        return "browser";
      }
      if (typeof WebSocketPair !== "undefined") {
        return "cloudflare-worker";
      }
      if (typeof EdgeRuntime === "string") {
        return "vercel-edge";
      }
      if (
        // @ts-ignore
        typeof WorkerGlobalScope !== "undefined" && // @ts-ignore
        typeof importScripts === "function"
      ) {
        return "web-worker";
      }
      return "unknown";
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/index.js
function normalizeEvent(ctx) {
  ctx.updateEvent("context.library.name", "@segment/analytics-node");
  ctx.updateEvent("context.library.version", version);
  const runtime = detectRuntime();
  if (runtime === "node") {
    ctx.updateEvent("_metadata.nodeVersion", process.version);
  }
  ctx.updateEvent("_metadata.jsRuntime", runtime);
}
function createNodePlugin(publisher) {
  function action(ctx) {
    normalizeEvent(ctx);
    return publisher.enqueue(ctx);
  }
  return {
    name: "Segment.io",
    type: "destination",
    version: "1.0.0",
    isLoaded: () => true,
    load: () => Promise.resolve(),
    alias: action,
    group: action,
    identify: action,
    page: action,
    screen: action,
    track: action
  };
}
var createConfiguredNodePlugin;
var init_segmentio = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/plugins/segmentio/index.js"() {
    init_publisher();
    init_version();
    init_env();
    createConfiguredNodePlugin = (props, emitter) => {
      const publisher = new Publisher(props, emitter);
      return {
        publisher,
        plugin: createNodePlugin(publisher)
      };
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/get-message-id.js
var createMessageId;
var init_get_message_id = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/get-message-id.js"() {
    init_uuid();
    createMessageId = () => {
      return `node-next-${Date.now()}-${v4()}`;
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/event-factory.js
var NodeEventFactory;
var init_event_factory = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/event-factory.js"() {
    init_esm2();
    init_get_message_id();
    NodeEventFactory = class extends CoreEventFactory {
      constructor() {
        super({
          createMessageId,
          onFinishedEvent: (event) => {
            assertUserIdentity(event);
          }
        });
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/context.js
var Context;
var init_context2 = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/context.js"() {
    init_esm2();
    Context = class extends CoreContext {
      static system() {
        return new this({ type: "track", event: "system" });
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/dispatch-emit.js
var normalizeDispatchCb, dispatchAndEmit;
var init_dispatch_emit = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/dispatch-emit.js"() {
    init_esm2();
    init_context2();
    normalizeDispatchCb = (cb) => (ctx) => {
      const failedDelivery = ctx.failedDelivery();
      return failedDelivery ? cb(failedDelivery.reason, ctx) : cb(void 0, ctx);
    };
    dispatchAndEmit = async (event, queue, emitter, callback) => {
      try {
        const context = new Context(event);
        const ctx = await dispatch(context, queue, emitter, {
          ...callback ? { callback: normalizeDispatchCb(callback) } : {}
        });
        const failedDelivery = ctx.failedDelivery();
        if (failedDelivery) {
          emitter.emit("error", {
            code: "delivery_failure",
            reason: failedDelivery.reason,
            ctx
          });
        } else {
          emitter.emit(event.type, ctx);
        }
      } catch (err) {
        emitter.emit("error", {
          code: "unknown",
          reason: err
        });
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/emitter.js
var NodeEmitter;
var init_emitter3 = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/emitter.js"() {
    init_esm();
    NodeEmitter = class extends Emitter {
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/event-queue.js
var NodePriorityQueue, NodeEventQueue;
var init_event_queue2 = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/event-queue.js"() {
    init_esm2();
    NodePriorityQueue = class extends PriorityQueue {
      constructor() {
        super(1, []);
      }
      // do not use an internal "seen" map
      getAttempts(ctx) {
        return ctx.attempts ?? 0;
      }
      updateAttempts(ctx) {
        ctx.attempts = this.getAttempts(ctx) + 1;
        return this.getAttempts(ctx);
      }
    };
    NodeEventQueue = class extends CoreEventQueue {
      constructor() {
        super(new NodePriorityQueue());
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/abort.js
var AbortSignal, AbortController2, abortSignalAfterTimeout;
var init_abort = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/abort.js"() {
    init_esm();
    init_env();
    AbortSignal = class {
      constructor() {
        __publicField(this, "onabort", null);
        __publicField(this, "aborted", false);
        __publicField(this, "eventEmitter", new Emitter());
      }
      toString() {
        return "[object AbortSignal]";
      }
      get [Symbol.toStringTag]() {
        return "AbortSignal";
      }
      removeEventListener(...args) {
        this.eventEmitter.off(...args);
      }
      addEventListener(...args) {
        this.eventEmitter.on(...args);
      }
      dispatchEvent(type) {
        const event = { type, target: this };
        const handlerName = `on${type}`;
        if (typeof this[handlerName] === "function") {
          ;
          this[handlerName](event);
        }
        this.eventEmitter.emit(type, event);
      }
    };
    AbortController2 = class {
      constructor() {
        __publicField(this, "signal", new AbortSignal());
      }
      abort() {
        if (this.signal.aborted)
          return;
        this.signal.aborted = true;
        this.signal.dispatchEvent("abort");
      }
      toString() {
        return "[object AbortController]";
      }
      get [Symbol.toStringTag]() {
        return "AbortController";
      }
    };
    abortSignalAfterTimeout = (timeoutMs) => {
      var _a2;
      if (detectRuntime() === "cloudflare-worker") {
        return [];
      }
      const ac = new (globalThis.AbortController || AbortController2)();
      const timeoutId = setTimeout(() => {
        ac.abort();
      }, timeoutMs);
      (_a2 = timeoutId == null ? void 0 : timeoutId.unref) == null ? void 0 : _a2.call(timeoutId);
      return [ac.signal, timeoutId];
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/fetch.js
var fetch2;
var init_fetch = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/fetch.js"() {
    fetch2 = async (...args) => {
      if (globalThis.fetch) {
        return globalThis.fetch(...args);
      } else if (typeof EdgeRuntime !== "string") {
        return (await import("./lib-XLM2PD22.js")).default(...args);
      } else {
        throw new Error("Invariant: an edge runtime that does not support fetch should not exist");
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/lib/http-client.js
var FetchHTTPClient;
var init_http_client = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/lib/http-client.js"() {
    init_abort();
    init_fetch();
    FetchHTTPClient = class {
      constructor(fetchFn) {
        __publicField(this, "_fetch");
        this._fetch = fetchFn ?? fetch2;
      }
      async makeRequest(options) {
        const [signal, timeoutId] = abortSignalAfterTimeout(options.httpRequestTimeout);
        const requestInit = {
          url: options.url,
          method: options.method,
          headers: options.headers,
          body: options.body,
          signal
        };
        return this._fetch(options.url, requestInit).finally(() => clearTimeout(timeoutId));
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/app/analytics-node.js
var Analytics;
var init_analytics_node = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/app/analytics-node.js"() {
    init_esm2();
    init_settings();
    init_version();
    init_segmentio();
    init_event_factory();
    init_dispatch_emit();
    init_emitter3();
    init_context2();
    init_event_queue2();
    init_http_client();
    Analytics = class extends NodeEmitter {
      constructor(settings) {
        super();
        __publicField(this, "_eventFactory");
        __publicField(this, "_isClosed", false);
        __publicField(this, "_pendingEvents", 0);
        __publicField(this, "_closeAndFlushDefaultTimeout");
        __publicField(this, "_publisher");
        __publicField(this, "_isFlushing", false);
        __publicField(this, "_queue");
        __publicField(this, "ready");
        validateSettings(settings);
        this._eventFactory = new NodeEventFactory();
        this._queue = new NodeEventQueue();
        const flushInterval = settings.flushInterval ?? 1e4;
        this._closeAndFlushDefaultTimeout = flushInterval * 1.25;
        const { plugin, publisher } = createConfiguredNodePlugin({
          writeKey: settings.writeKey,
          host: settings.host,
          path: settings.path,
          maxRetries: settings.maxRetries ?? 3,
          flushAt: settings.flushAt ?? settings.maxEventsInBatch ?? 15,
          httpRequestTimeout: settings.httpRequestTimeout,
          disable: settings.disable,
          flushInterval,
          httpClient: typeof settings.httpClient === "function" ? new FetchHTTPClient(settings.httpClient) : settings.httpClient ?? new FetchHTTPClient(),
          oauthSettings: settings.oauthSettings
        }, this);
        this._publisher = publisher;
        this.ready = this.register(plugin).then(() => void 0);
        this.emit("initialize", settings);
        bindAll(this);
      }
      get VERSION() {
        return version;
      }
      /**
       * Call this method to stop collecting new events and flush all existing events.
       * This method also waits for any event method-specific callbacks to be triggered,
       * and any of their subsequent promises to be resolved/rejected.
       */
      closeAndFlush({ timeout = this._closeAndFlushDefaultTimeout } = {}) {
        return this.flush({ timeout, close: true });
      }
      /**
       * Call this method to flush all existing events..
       * This method also waits for any event method-specific callbacks to be triggered,
       * and any of their subsequent promises to be resolved/rejected.
       */
      async flush({ timeout, close = false } = {}) {
        if (this._isFlushing) {
          console.warn("Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again");
          return;
        } else {
          this._isFlushing = true;
        }
        if (close) {
          this._isClosed = true;
        }
        this._publisher.flush(this._pendingEvents);
        const promise = new Promise((resolve) => {
          if (!this._pendingEvents) {
            resolve();
          } else {
            this.once("drained", () => {
              resolve();
            });
          }
        }).finally(() => {
          this._isFlushing = false;
        });
        return timeout ? pTimeout(promise, timeout).catch(() => void 0) : promise;
      }
      _dispatch(segmentEvent, callback) {
        if (this._isClosed) {
          this.emit("call_after_close", segmentEvent);
          return void 0;
        }
        this._pendingEvents++;
        dispatchAndEmit(segmentEvent, this._queue, this, callback).catch((ctx) => ctx).finally(() => {
          this._pendingEvents--;
          if (!this._pendingEvents) {
            this.emit("drained");
          }
        });
      }
      /**
       * Combines two unassociated user identities.
       * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#alias
       */
      alias({ userId, previousId, context, timestamp, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.alias(userId, previousId, {
          context,
          integrations,
          timestamp,
          messageId
        });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * Associates an identified user with a collective.
       *  @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#group
       */
      group({ timestamp, groupId, userId, anonymousId, traits = {}, context, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.group(groupId, traits, {
          context,
          anonymousId,
          userId,
          timestamp,
          integrations,
          messageId
        });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * Includes a unique userId and (maybe anonymousId) and any optional traits you know about them.
       * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#identify
       */
      identify({ userId, anonymousId, traits = {}, context, timestamp, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.identify(userId, traits, {
          context,
          anonymousId,
          userId,
          timestamp,
          integrations,
          messageId
        });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * The page method lets you record page views on your website, along with optional extra information about the page being viewed.
       * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#page
       */
      page({ userId, anonymousId, category, name, properties, context, timestamp, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.page(category ?? null, name ?? null, properties, { context, anonymousId, userId, timestamp, integrations, messageId });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * Records screen views on your app, along with optional extra information
       * about the screen viewed by the user.
       *
       * TODO: This is not documented on the segment docs ATM (for node).
       */
      screen({ userId, anonymousId, category, name, properties, context, timestamp, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.screen(category ?? null, name ?? null, properties, { context, anonymousId, userId, timestamp, integrations, messageId });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * Records actions your users perform.
       * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#track
       */
      track({ userId, anonymousId, event, properties, context, timestamp, integrations, messageId }, callback) {
        const segmentEvent = this._eventFactory.track(event, properties, {
          context,
          userId,
          anonymousId,
          timestamp,
          integrations,
          messageId
        });
        this._dispatch(segmentEvent, callback);
      }
      /**
       * Registers one or more plugins to augment Analytics functionality.
       * @param plugins
       */
      register(...plugins) {
        return this._queue.criticalTasks.run(async () => {
          const ctx = Context.system();
          const registrations = plugins.map((xt) => this._queue.register(ctx, xt, this));
          await Promise.all(registrations);
          this.emit("register", plugins.map((el) => el.name));
        });
      }
      /**
       * Deregisters one or more plugins based on their names.
       * @param pluginNames - The names of one or more plugins to deregister.
       */
      async deregister(...pluginNames) {
        const ctx = Context.system();
        const deregistrations = pluginNames.map((pl) => {
          const plugin = this._queue.plugins.find((p) => p.name === pl);
          if (plugin) {
            return this._queue.deregister(ctx, plugin, this);
          } else {
            ctx.log("warn", `plugin ${pl} not found`);
          }
        });
        await Promise.all(deregistrations);
        this.emit("deregister", pluginNames);
      }
    };
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/index.common.js
var init_index_common = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/index.common.js"() {
    init_analytics_node();
    init_context2();
    init_http_client();
  }
});

// ../../node_modules/@segment/analytics-node/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Analytics: () => Analytics,
  Context: () => Context,
  FetchHTTPClient: () => FetchHTTPClient,
  default: () => esm_default
});
var esm_default;
var init_esm3 = __esm({
  "../../node_modules/@segment/analytics-node/dist/esm/index.js"() {
    init_index_common();
    init_index_common();
    esm_default = Analytics;
  }
});

// ../../node_modules/@evidence-dev/telemetry/index.cjs
var require_telemetry = __commonJS({
  "../../node_modules/@evidence-dev/telemetry/index.cjs"(exports, module) {
    var secure = require_secure();
    var md5 = require_md5();
    var { readJSONSync, writeJSONSync, pathExistsSync, copySync } = require_lib();
    var wK = "ydlp5unBbi75doGz89jC3P1Llb4QjYkM";
    var { Analytics: Analytics2 } = (init_esm3(), __toCommonJS(esm_exports));
    var PROFILES_PATH = "../customization/.profile.json";
    var LEGACY_PROFILES_PATH = "./.profile.json";
    var initializeProfile = async () => {
      const projectProfile = {
        anonymousId: secure.v4(),
        traits: {
          projectCreated: /* @__PURE__ */ new Date()
        }
      };
      writeJSONSync(PROFILES_PATH, projectProfile);
      const analytics = new Analytics2({ writeKey: wK });
      analytics.identify(projectProfile);
      return projectProfile;
    };
    var getProfile = async () => {
      if (!pathExistsSync(PROFILES_PATH) && !maybeMigrateProfile()) {
        const profile = await initializeProfile();
        return profile;
      } else {
        let profile = readJSONSync(PROFILES_PATH);
        if (profile.anonymousId === "b958769d-6b88-43f3-978a-b970a146ffd2") {
          profile = await initializeProfile();
        }
        return profile;
      }
    };
    var logEvent = async (eventName, dev, settings, databaseName = void 0, sourceName = void 0, queryName = void 0) => {
      var _a2;
      try {
        let usageStats = settings ? settings.send_anonymous_usage_stats ?? "yes" : process.env["SEND_ANONYMOUS_USAGE_STATS"] ?? process.env["send_anonymous_usage_stats"] ?? "yes";
        let repo;
        let database;
        let demoDb;
        if (settings) {
          if (settings.gitRepo) {
            repo = md5(settings.gitRepo);
          }
          if (databaseName) {
            database = databaseName;
          } else if (settings.database) {
            database = settings.database;
          }
          if ((_a2 = settings.credentials) == null ? void 0 : _a2.filename) {
            demoDb = md5(settings.credentials.filename) === md5("needful_things.duckdb");
          }
        }
        let homeDirectory = void 0;
        let codespaces = false;
        if (process.env) {
          const { HOME, CODESPACES } = process.env;
          homeDirectory = HOME;
          if (CODESPACES) {
            codespaces = CODESPACES === "true";
          }
        }
        if (usageStats === "yes") {
          const projectProfile = await getProfile();
          const analytics = new Analytics2({ writeKey: wK });
          const payload = {
            anonymousId: projectProfile.anonymousId,
            event: eventName,
            properties: {
              devMode: dev,
              repoHash: repo,
              database,
              // logs database type (postgres, snowflake, etc.)
              sourceNameHash: sourceName ? md5(sourceName) : void 0,
              //logs the hashed name of the source this is associated with (e.g md5('pet-store')))
              queryNameHash: queryName ? md5(queryName) : void 0,
              //logs the hashed name of the query this is associated with (e.g md5('pet-store')))
              operatingSystem: process.platform,
              // logs operating system name
              nodeVersion: process.version,
              // logs active version of NodeJS
              arch: process.arch,
              directoryHash: homeDirectory ? md5(homeDirectory) : void 0,
              demoDb,
              codespaces,
              postUSQL: true
            }
          };
          analytics.track(payload);
        }
      } catch {
      }
    };
    var logQueryEvent = async (eventName, databaseName, sourceName, queryName, dev = false) => {
      try {
        await logEvent(eventName, dev, loadSettings(), databaseName, sourceName, queryName);
      } catch (e) {
      }
    };
    function loadSettings() {
      let settings = {};
      try {
        settings = readJSONSync("evidence.settings.json");
      } catch (e) {
      }
      return settings;
    }
    function maybeMigrateProfile() {
      if (pathExistsSync(LEGACY_PROFILES_PATH)) {
        copySync(LEGACY_PROFILES_PATH, PROFILES_PATH);
        return true;
      } else {
        return false;
      }
    }
    module.exports = {
      logEvent,
      logQueryEvent
    };
  }
});

export {
  require_telemetry
};
//# sourceMappingURL=chunk-YFA4MLXK.js.map
