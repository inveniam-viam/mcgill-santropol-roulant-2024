{
  "version": 3,
  "sources": ["../../perfect-debounce/dist/index.mjs", "../../@evidence-dev/sdk/src/utils/batchUp.js"],
  "sourcesContent": ["const DEBOUNCE_DEFAULTS = {\n  trailing: true\n};\nfunction debounce(fn, wait = 25, options = {}) {\n  options = { ...DEBOUNCE_DEFAULTS, ...options };\n  if (!Number.isFinite(wait)) {\n    throw new TypeError(\"Expected `wait` to be a finite number\");\n  }\n  let leadingValue;\n  let timeout;\n  let resolveList = [];\n  let currentPromise;\n  let trailingArgs;\n  const applyFn = (_this, args) => {\n    currentPromise = _applyPromised(fn, _this, args);\n    currentPromise.finally(() => {\n      currentPromise = null;\n      if (options.trailing && trailingArgs && !timeout) {\n        const promise = applyFn(_this, trailingArgs);\n        trailingArgs = null;\n        return promise;\n      }\n    });\n    return currentPromise;\n  };\n  return function(...args) {\n    if (currentPromise) {\n      if (options.trailing) {\n        trailingArgs = args;\n      }\n      return currentPromise;\n    }\n    return new Promise((resolve) => {\n      const shouldCallNow = !timeout && options.leading;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        timeout = null;\n        const promise = options.leading ? leadingValue : applyFn(this, args);\n        for (const _resolve of resolveList) {\n          _resolve(promise);\n        }\n        resolveList = [];\n      }, wait);\n      if (shouldCallNow) {\n        leadingValue = applyFn(this, args);\n        resolve(leadingValue);\n      } else {\n        resolveList.push(resolve);\n      }\n    });\n  };\n}\nasync function _applyPromised(fn, _this, args) {\n  return await fn.apply(_this, args);\n}\n\nexport { debounce };\n", "import { debounce } from 'perfect-debounce';\n\n/**\n * @template Input\n * @param {(inputs: Input[]) => unknown} fn\n * @param {number} [timeout=200]\n * @returns {(i: Input) => unknown}\n */\nexport const batchUp = (fn, timeout = 200) => {\n\t/** @type {Input[]} */\n\tconst collected = [];\n\n\tconst finalize = debounce(() => {\n\t\tfn([...collected]); // clone collected array before resetting it\n\t\tcollected.length = 0;\n\t}, timeout);\n\n\treturn (...i) => {\n\t\tcollected.push(...i);\n\t\treturn finalize();\n\t};\n};\n"],
  "mappings": ";AAAA,IAAM,oBAAoB;AAAA,EACxB,UAAU;AACZ;AACA,SAAS,SAAS,IAAI,OAAO,IAAI,UAAU,CAAC,GAAG;AAC7C,YAAU,EAAE,GAAG,mBAAmB,GAAG,QAAQ;AAC7C,MAAI,CAAC,OAAO,SAAS,IAAI,GAAG;AAC1B,UAAM,IAAI,UAAU,uCAAuC;AAAA,EAC7D;AACA,MAAI;AACJ,MAAI;AACJ,MAAI,cAAc,CAAC;AACnB,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU,CAAC,OAAO,SAAS;AAC/B,qBAAiB,eAAe,IAAI,OAAO,IAAI;AAC/C,mBAAe,QAAQ,MAAM;AAC3B,uBAAiB;AACjB,UAAI,QAAQ,YAAY,gBAAgB,CAAC,SAAS;AAChD,cAAM,UAAU,QAAQ,OAAO,YAAY;AAC3C,uBAAe;AACf,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AACA,SAAO,YAAY,MAAM;AACvB,QAAI,gBAAgB;AAClB,UAAI,QAAQ,UAAU;AACpB,uBAAe;AAAA,MACjB;AACA,aAAO;AAAA,IACT;AACA,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,YAAM,gBAAgB,CAAC,WAAW,QAAQ;AAC1C,mBAAa,OAAO;AACpB,gBAAU,WAAW,MAAM;AACzB,kBAAU;AACV,cAAM,UAAU,QAAQ,UAAU,eAAe,QAAQ,MAAM,IAAI;AACnE,mBAAW,YAAY,aAAa;AAClC,mBAAS,OAAO;AAAA,QAClB;AACA,sBAAc,CAAC;AAAA,MACjB,GAAG,IAAI;AACP,UAAI,eAAe;AACjB,uBAAe,QAAQ,MAAM,IAAI;AACjC,gBAAQ,YAAY;AAAA,MACtB,OAAO;AACL,oBAAY,KAAK,OAAO;AAAA,MAC1B;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,eAAe,eAAe,IAAI,OAAO,MAAM;AAC7C,SAAO,MAAM,GAAG,MAAM,OAAO,IAAI;AACnC;;;AC9CO,IAAM,UAAU,CAAC,IAAI,UAAU,QAAQ;AAE7C,QAAM,YAAY,CAAC;AAEnB,QAAM,WAAW,SAAS,MAAM;AAC/B,OAAG,CAAC,GAAG,SAAS,CAAC;AACjB,cAAU,SAAS;AAAA,EACpB,GAAG,OAAO;AAEV,SAAO,IAAI,MAAM;AAChB,cAAU,KAAK,GAAG,CAAC;AACnB,WAAO,SAAS;AAAA,EACjB;AACD;",
  "names": []
}
