{
  "version": 3,
  "sources": ["../../@uwdata/mosaic-sql/src/ref.js", "../../@uwdata/mosaic-sql/src/to-sql.js", "../../@uwdata/mosaic-sql/src/expression.js", "../../@uwdata/mosaic-sql/src/desc.js", "../../@uwdata/mosaic-sql/src/literal.js", "../../@uwdata/mosaic-sql/src/operators.js", "../../@uwdata/mosaic-sql/src/repeat.js", "../../@uwdata/mosaic-sql/src/functions.js", "../../@uwdata/mosaic-sql/src/windows.js", "../../@uwdata/mosaic-sql/src/aggregates.js", "../../@uwdata/mosaic-sql/src/cast.js", "../../@uwdata/mosaic-sql/src/datetime.js", "../../@uwdata/mosaic-sql/src/Query.js", "../../@uwdata/mosaic-sql/src/load/create.js", "../../@uwdata/mosaic-sql/src/load/sql-from.js", "../../@uwdata/mosaic-sql/src/load/load.js"],
  "sourcesContent": ["/**\n * Class representing a table and/or column reference.\n */\nexport class Ref {\n  /**\n   * Create a new Ref instance.\n   * @param {string|Ref|null} table The table name.\n   * @param {string|null} column The column name.\n   */\n  constructor(table, column) {\n    if (table) this.table = String(table);\n    if (column) this.column = column;\n  }\n\n  /**\n   * Get the list of referenced columns. Either a single element array\n   * if column is non-null, otherwise an empty array.\n   */\n  get columns() {\n    return this.column ? [this.column] : [];\n  }\n\n  /**\n   * Generate a SQL string for this reference.\n   * @returns {string} The SQL string.\n   */\n  toString() {\n    const { table, column } = this;\n    if (column) {\n      const col = column.startsWith('*') ? column : `\"${column}\"`;\n      return `${table ? `${quoteTableName(table)}.` : ''}${col}`;\n    } else {\n      return table ? quoteTableName(table) : 'NULL';\n    }\n  }\n}\n\n/**\n * Quote a table name. For example, `foo.bar` becomes `\"foo\".\"bar\".\n * @param {string} table the name of the table which may contain a database reference\n * @returns The quoted table name.\n */\nfunction quoteTableName(table) {\n  const pieces = table.split('.');\n  return pieces.map(p => `\"${p}\"`).join('.');\n}\n\n/**\n * Test is a reference refers to a given column name.\n * @param {*} ref The reference to test.\n * @param {string} name The column name to check for.\n * @returns {boolean} True if ref is a Ref instance that refers to\n *  the given column name. False otherwise.\n */\nexport function isColumnRefFor(ref, name) {\n  return ref instanceof Ref && ref.column === name;\n}\n\n/**\n * Interpret a value, defaulting to a column reference.\n * @param {*} value The value to interpret. If string-typed,\n *  a new column reference will be returned.\n * @returns {*} A column reference or the input value.\n */\nexport function asColumn(value) {\n  return typeof value === 'string' ? column(value) : value;\n}\n\n/**\n * Interpret a value, defaulting to a table (relation) reference.\n * @param {*} value The value to interpret. If string-typed,\n *  a new table (relation) reference will be returned.\n * @returns {*} A table reference or the input value.\n */\nexport function asRelation(value) {\n  return typeof value === 'string' ? relation(value) : value;\n}\n\n/**\n * Create a table (relation) reference.\n * @param {string} name The table (relation) name.\n * @returns {Ref} The generated table reference.\n */\nexport function relation(name) {\n  return new Ref(name);\n}\n\n/**\n * Create a column reference.\n * @param {string} [table] The table name (optional).\n * @param {string} column The column name.\n * @returns {Ref} The generated column reference.\n */\nexport function column(table, column) {\n  if (arguments.length === 1) {\n    column = table;\n    table = null;\n  }\n  return new Ref(table, column);\n}\n\n/**\n * Create a reference to all columns in a table (relation).\n * @param {string} table The table name.\n * @returns {Ref} The generated reference.\n */\nexport function all(table) {\n  return new Ref(table, '*');\n}\n", "/**\n * Convert a value to a corresponding SQL string.\n * Input string values are assumed to be column references,\n * otherwise the logic of literalToSQL applies.\n * @param {*} value The value to convert to SQL.\n * @returns {string} A SQL string.\n */\nexport function toSQL(value) {\n  return typeof value === 'string'\n    ? `\"${value}\"` // strings as column refs\n    : literalToSQL(value);\n}\n\n/**\n * Convert a literal value to a corresponding SQL string.\n * The values null, undefined, Infinity, NaN, and invalid\n * dates are converted to SQL NULL values.\n * UTC dates map to the SQL Date type, otherwise JavaScript\n * date values map to the SQL Timestamp type.\n * Values that are not JavaScript Date, RegExp, or primitive types\n * are coerced to strings, relying on a defined toString method.\n * @param {*} value The literal value.\n * @returns {string} A SQL string.\n */\nexport function literalToSQL(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return value ? 'TRUE' : 'FALSE';\n    case 'string':\n      return `'${value}'`;\n    case 'number':\n      return Number.isFinite(value) ? String(value) : 'NULL';\n    default:\n      if (value == null) {\n        return 'NULL';\n      } else if (value instanceof Date) {\n        const ts = +value;\n        if (Number.isNaN(ts)) return 'NULL';\n        const y = value.getUTCFullYear();\n        const m = value.getUTCMonth();\n        const d = value.getUTCDate();\n        return ts === Date.UTC(y, m, d)\n          ? `MAKE_DATE(${y}, ${m+1}, ${d})` // utc date\n          : `EPOCH_MS(${ts})`; // timestamp\n      } else if (value instanceof RegExp) {\n        return `'${value.source}'`;\n      } else {\n        // otherwise rely on string coercion\n        return String(value);\n      }\n  }\n}\n", "import { literalToSQL } from './to-sql.js';\n\n/**\n * Test if a value is parameter-like. Parameters have addEventListener methods.\n * @param {*} value The value to test.\n * @returns True if the value is param-like, false otherwise.\n */\nexport const isParamLike = value => typeof value?.addEventListener === 'function';\n\n/**\n * Test if a value is a SQL expression instance.\n * @param {*} value The value to test.\n * @returns {boolean} True if value is a SQL expression, false otherwise.\n */\nexport function isSQLExpression(value) {\n  return value instanceof SQLExpression;\n}\n\n/**\n * Base class for all SQL expressions. Most callers should use the `sql`\n * template tag rather than instantiate this class.\n */\nexport class SQLExpression {\n\n  /**\n   * Create a new SQL expression instance.\n   * @param {(string|SQLExpression|Ref)[]} parts The parts of the expression.\n   * @param {string[]} [columns=[]] The column dependencies\n   * @param {object} [props] Additional properties for this expression.\n   */\n  constructor(parts, columns, props) {\n    this._expr = Array.isArray(parts) ? parts : [parts];\n    this._deps = columns || [];\n    this.annotate(props);\n\n    const params = this._expr.filter(part => isParamLike(part));\n    if (params.length > 0) {\n      this._params = Array.from(new Set(params));\n      this._params.forEach(param => {\n        param.addEventListener('value', () => update(this, this.map?.get('value')));\n      });\n    } else {\n      // do not support event listeners if not needed\n      // this causes the expression instance to NOT be param-like\n      this.addEventListener = undefined;\n    }\n  }\n\n  /**\n   * A reference to this expression.\n   * Provides compatibility with param-like objects.\n   */\n  get value() {\n    return this;\n  }\n\n  /**\n   * The column dependencies of this expression.\n   * @returns {string[]} The columns dependencies.\n   */\n  get columns() {\n    const { _params, _deps } = this;\n    if (_params) {\n      // pull latest dependencies, as they may change across updates\n      const pset = new Set(_params.flatMap(p => {\n        const cols = p.value?.columns;\n        return Array.isArray(cols) ? cols : [];\n      }));\n      if (pset.size) {\n        const set = new Set(_deps);\n        pset.forEach(col => set.add(col));\n        return Array.from(set);\n      }\n    }\n    // if no params, return fixed dependencies\n    return _deps;\n  }\n\n  /**\n   * The first column dependency in this expression, or undefined if none.\n   * @returns {string} The first column dependency.\n   */\n  get column() {\n    return this._deps.length ? this._deps[0] : this.columns[0];\n  }\n\n  /**\n   * Annotate this expression instance with additional properties.\n   * @param {object[]} [props] One or more objects with properties to add.\n   * @returns {this} This SQL expression.\n   */\n  annotate(...props) {\n    return Object.assign(this, ...props);\n  }\n\n  /**\n   * Generate a SQL code string corresponding to this expression.\n   * @returns {string} A SQL code string.\n   */\n  toString() {\n    return this._expr\n      .map(p => isParamLike(p) && !isSQLExpression(p) ? literalToSQL(p.value) : p)\n      .join('');\n  }\n\n  /**\n   * Add an event listener callback for the provided event type.\n   * @param {string} type The event type to listen for (for example, \"value\").\n   * @param {(a: SQLExpression) => Promise?} callback The callback function to\n   *  invoke upon updates. A callback may optionally return a Promise that\n   *  upstream listeners may await before proceeding.\n   */\n  addEventListener(type, callback) {\n    const map = this.map || (this.map = new Map());\n    const set = map.get(type) || (map.set(type, new Set), map.get(type));\n    set.add(callback);\n  }\n}\n\nfunction update(expr, callbacks) {\n  if (callbacks?.size) {\n    return Promise.allSettled(Array.from(callbacks, fn => fn(expr)));\n  }\n}\n\nexport function parseSQL(strings, exprs) {\n  const spans = [strings[0]];\n  const cols = new Set;\n  const n = exprs.length;\n  for (let i = 0, k = 0; i < n;) {\n    const e = exprs[i];\n    if (isParamLike(e)) {\n      spans[++k] = e;\n    } else {\n      if (Array.isArray(e?.columns)) {\n        e.columns.forEach(col => cols.add(col));\n      }\n      spans[k] += typeof e === 'string' ? e : literalToSQL(e);\n    }\n    const s = strings[++i];\n    if (isParamLike(spans[k])) {\n      spans[++k] = s;\n    } else {\n      spans[k] += s;\n    }\n  }\n\n  return { spans, cols: Array.from(cols) };\n}\n\n/**\n * Tag function for SQL expressions. Interpolated values\n * may be strings, other SQL expression objects (such as column\n * references), or parameterized values.\n */\nexport function sql(strings, ...exprs) {\n  const { spans, cols } = parseSQL(strings, exprs);\n  return new SQLExpression(spans, cols);\n}\n", "import { sql } from './expression.js';\nimport { asColumn } from './ref.js';\n\n/**\n * Annotate an expression to indicate descending sort order.\n * Null values are ordered last.\n * @param {SQLExpression|string} expr A SQL expression or column name string.\n * @returns {SQLExpression} An expression with descending order.\n */\nexport function desc(expr) {\n  const e = asColumn(expr);\n  return sql`${e} DESC NULLS LAST`.annotate({ label: e?.label, desc: true });\n}\n", "import { literalToSQL } from './to-sql.js';\n\nexport const literal = value => ({\n  value,\n  toString: () => literalToSQL(value)\n});\n", "import { sql } from './expression.js';\nimport { asColumn } from './ref.js';\n\nfunction visit(callback) {\n  callback(this.op, this);\n  this.children?.forEach(v => v.visit(callback));\n}\n\nfunction logical(op, clauses) {\n  const children = clauses.filter(x => x != null).map(asColumn);\n  const strings = children.map((c, i) => i ? ` ${op} ` : '');\n  if (children.length === 1) {\n    strings.push('')\n  } else if (children.length > 1) {\n    strings[0] = '(';\n    strings.push(')');\n  }\n  return sql(strings, ...children).annotate({ op, children, visit });\n}\n\nexport const and = (...clauses) => logical('AND', clauses.flat());\nexport const or = (...clauses) => logical('OR', clauses.flat());\n\nconst unaryOp = op => a => sql`(${op} ${asColumn(a)})`.annotate({ op, a, visit });\n\nexport const not = unaryOp('NOT');\n\nconst unaryPostOp = op => a => sql`(${asColumn(a)} ${op})`.annotate({ op, a, visit });\n\nexport const isNull = unaryPostOp('IS NULL');\nexport const isNotNull = unaryPostOp('IS NOT NULL');\n\nconst binaryOp = op => (a, b) => sql`(${asColumn(a)} ${op} ${asColumn(b)})`.annotate({ op, a, b, visit });\n\nexport const eq = binaryOp('=');\nexport const neq = binaryOp('<>');\nexport const lt = binaryOp('<');\nexport const gt = binaryOp('>');\nexport const lte = binaryOp('<=');\nexport const gte = binaryOp('>=');\nexport const isDistinct = binaryOp('IS DISTINCT FROM');\nexport const isNotDistinct = binaryOp('IS NOT DISTINCT FROM');\n\nfunction rangeOp(op, a, range, exclusive) {\n  a = asColumn(a);\n  const prefix = op.startsWith('NOT ') ? 'NOT ' : '';\n  const expr = !range ? sql``\n    : exclusive ? sql`${prefix}(${range[0]} <= ${a} AND ${a} < ${range[1]})`\n    : sql`(${a} ${op} ${range[0]} AND ${range[1]})`;\n  return expr.annotate({ op, visit, field: a, range });\n}\n\nexport const isBetween = (a, range, exclusive) => rangeOp('BETWEEN', a, range, exclusive);\nexport const isNotBetween = (a, range, exclusive) => rangeOp('NOT BETWEEN', a, range, exclusive);\n", "export function repeat(length, str) {\n  return Array.from({ length }, () => str);\n}\n", "import { sql } from './expression.js';\nimport { asColumn } from './ref.js';\nimport { repeat } from './repeat.js';\n\nexport function functionCall(op, type) {\n  return (...values) => {\n    const args = values.map(asColumn);\n    const cast = type ? `::${type}` : '';\n    const expr = args.length\n      ? sql([`${op}(`, ...repeat(args.length - 1, ', '), `)${cast}`], ...args)\n      : sql`${op}()${cast}`;\n    return expr.annotate({ func: op, args });\n  }\n}\n\nexport const regexp_matches = functionCall('REGEXP_MATCHES');\nexport const contains = functionCall('CONTAINS');\nexport const prefix = functionCall('PREFIX');\nexport const suffix = functionCall('SUFFIX');\nexport const lower = functionCall('LOWER');\nexport const upper = functionCall('UPPER');\nexport const length = functionCall('LENGTH');\nexport const isNaN = functionCall('ISNAN');\nexport const isFinite = functionCall('ISFINITE');\nexport const isInfinite = functionCall('ISINF');\n", "import { SQLExpression, isParamLike, sql } from './expression.js';\nimport { functionCall } from './functions.js';\nimport { asColumn } from './ref.js';\nimport { repeat } from './repeat.js';\n\n/**\n * Base class for individual window functions.\n * Most callers should use a dedicated window function\n * rather than instantiate this class.\n */\nexport class WindowFunction extends SQLExpression {\n  constructor(op, func, type, name, group = '', order = '', frame = '') {\n    // build and parse expression\n    let expr;\n    const noWindowParams = !(group || order || frame);\n    if (name && noWindowParams) {\n      expr = name ? sql`${func} OVER \"${name}\"` : sql`${func} OVER ()`;\n    } else {\n      const s1 = group && order ? ' ' : '';\n      const s2 = (group || order) && frame ? ' ' : '';\n      expr = sql`${func} OVER (${name ? `\"${name}\" ` : ''}${group}${s1}${order}${s2}${frame})`;\n    }\n    if (type) {\n      expr = sql`(${expr})::${type}`;\n    }\n    const { _expr, _deps } = expr;\n    super(_expr, _deps, { window: op, func, type, name, group, order, frame });\n  }\n\n  get basis() {\n    return this.column;\n  }\n\n  get label() {\n    const { func } = this;\n    return func.label ?? func.toString();\n  }\n\n  over(name) {\n    const { window: op, func, type, group, order, frame } = this;\n    return new WindowFunction(op, func, type, name, group, order, frame);\n  }\n\n  partitionby(...expr) {\n    const exprs = expr.flat().filter(x => x).map(asColumn);\n    const group = sql(\n      ['PARTITION BY ', repeat(exprs.length - 1, ', '), ''],\n      ...exprs\n    );\n    const { window: op, func, type, name, order, frame } = this;\n    return new WindowFunction(op, func, type, name, group, order, frame);\n  }\n\n  orderby(...expr) {\n    const exprs = expr.flat().filter(x => x).map(asColumn);\n    const order = sql(\n      ['ORDER BY ', repeat(exprs.length - 1, ', '), ''],\n      ...exprs\n    );\n    const { window: op, func, type, name, group, frame } = this;\n    return new WindowFunction(op, func, type, name, group, order, frame);\n  }\n\n  rows(expr) {\n    const frame = windowFrame('ROWS', expr);\n    const { window: op, func, type, name, group, order } = this;\n    return new WindowFunction(op, func, type, name, group, order, frame);\n  }\n\n  range(expr) {\n    const frame = windowFrame('RANGE', expr);\n    const { window: op, func, type, name, group, order } = this;\n    return new WindowFunction(op, func, type, name, group, order, frame);\n  }\n}\n\nfunction windowFrame(type, frame) {\n  if (isParamLike(frame)) {\n    const expr = sql`${frame}`;\n    expr.toString = () => `${type} ${frameToSQL(frame.value)}`;\n    return expr;\n  }\n  return `${type} ${frameToSQL(frame)}`;\n}\n\nfunction frameToSQL(frame) {\n  const [prev, next] = frame;\n  const a = prev === 0 ? 'CURRENT ROW'\n    : Number.isFinite(prev) ? `${Math.abs(prev)} PRECEDING`\n    : 'UNBOUNDED PRECEDING';\n  const b = next === 0 ? 'CURRENT ROW'\n    : Number.isFinite(next) ? `${Math.abs(next)} FOLLOWING`\n    : 'UNBOUNDED FOLLOWING';\n  return `BETWEEN ${a} AND ${b}`;\n}\n\nexport function winf(op, type) {\n  return (...values) => {\n    const func = functionCall(op)(...values);\n    return new WindowFunction(op, func, type);\n  };\n}\n\n/**\n * Create a window function that returns the number of the current row\n * within the partition, counting from 1.\n * @returns {WindowFunction} The generated window function.\n */\nexport const row_number = winf('ROW_NUMBER', 'INTEGER');\n\n/**\n * Create a window function that returns the rank of the current row with gaps.\n * This is the same as the row_number of its first peer.\n * @returns {WindowFunction} The generated window function.\n */\nexport const rank = winf('RANK', 'INTEGER');\n\n/**\n * Create a window function that returns the rank of the current row without gaps,\n * The function counts peer groups.\n * @returns {WindowFunction} The generated window function.\n */\nexport const dense_rank = winf('DENSE_RANK', 'INTEGER');\n\n/**\n * Create a window function that returns the relative rank of the current row.\n * (rank() - 1) / (total partition rows - 1).\n * @returns {WindowFunction} The generated window function.\n */\nexport const percent_rank = winf('PERCENT_RANK');\n\n/**\n * Create a window function that returns the cumulative distribution.\n * (number of preceding or peer partition rows) / total partition rows.\n * @returns {WindowFunction} The generated window function.\n */\nexport const cume_dist = winf('CUME_DIST');\n\n/**\n * Create a window function that r an integer ranging from 1 to the argument\n * value, dividing the partition as equally as possible.\n * @param {number|SQLExpression} num_buckets The number of quantile buckets.\n * @returns {WindowFunction} The generated window function.\n */\nexport const ntile = winf('NTILE');\n\n/**\n * Create a window function that returns the expression evaluated at the row\n * that is offset rows before the current row within the partition.\n * If there is no such row, instead return default (which must be of the same\n * type as the expression). Both offset and default are evaluated with respect\n * to the current row. If omitted, offset defaults to 1 and default to null.\n * @param {string|SQLExpression} expr The expression to evaluate.\n * @param {number|SQLExpression} offset The row offset.\n * @param {*} default The default value.\n * @returns {WindowFunction} The generated window function.\n */\nexport const lag = winf('LAG');\n\n/**\n * Create a window function that returns the expression evaluated at the row\n * that is offset rows after the current row within the partition.\n * If there is no such row, instead return default (which must be of the same\n * type as the expression). Both offset and default are evaluated with respect\n * to the current row. If omitted, offset defaults to 1 and default to null.\n * @param {string|SQLExpression} expr The expression to evaluate.\n * @param {number|SQLExpression} offset The row offset.\n * @param {*} default The default value.\n * @returns {WindowFunction} The generated window function.\n */\nexport const lead = winf('LEAD');\n\n/**\n * Create a window function that returns the expression evaluated at the row\n * that is the first row of the window frame.\n * @param {string|SQLExpression} expr The expression to evaluate.\n * @returns {WindowFunction} The generated window function.\n */\nexport const first_value = winf('FIRST_VALUE');\n\n/**\n * Create a window function that returns the expression evaluated at the row\n * that is the last row of the window frame.\n * @param {string|SQLExpression} expr The expression to evaluate.\n * @returns {WindowFunction} The generated window function.\n */\n\nexport const last_value = winf('LAST_VALUE');\n\n/**\n * Create a window function that returns the expression evaluated at the\n * nth row of the window frame (counting from 1), or null if no such row.\n * @param {string|SQLExpression} expr The expression to evaluate.\n * @param {number|SQLExpression} nth The 1-based window frame index.\n * @returns {WindowFunction} The generated window function.\n */\nexport const nth_value = winf('NTH_VALUE');\n", "import { SQLExpression, parseSQL, sql } from './expression.js';\nimport { asColumn } from './ref.js';\nimport { repeat } from './repeat.js';\nimport { literalToSQL } from './to-sql.js';\nimport { WindowFunction } from './windows.js';\n\n/**\n * Tag function for SQL aggregate expressions. Interpolated values\n * may be strings, other SQL expression objects (such as column\n * references), or parameterized values.\n */\nexport function agg(strings, ...exprs) {\n  return sql(strings, ...exprs).annotate({ aggregate: true });\n}\n\n/**\n * Base class for individual aggregate functions.\n * Most callers should use a dedicated aggregate function\n * rather than instantiate this class.\n */\nexport class AggregateFunction extends SQLExpression {\n  constructor(op, args, type, isDistinct, filter) {\n    args = (args || []).map(asColumn);\n    const { strings, exprs } = aggExpr(op, args, type, isDistinct, filter);\n    const { spans, cols } = parseSQL(strings, exprs);\n    super(spans, cols, { aggregate: op, args, type, isDistinct, filter });\n  }\n\n  get basis() {\n    return this.column;\n  }\n\n  get label() {\n    const { aggregate: op, args, isDistinct } = this;\n    const dist = isDistinct ? 'DISTINCT' + (args.length ? ' ' : '') : '';\n    const tail = args.length ? `(${dist}${args.map(unquoted).join(', ')})` : '';\n    return `${op.toLowerCase()}${tail}`;\n  }\n\n  distinct() {\n    const { aggregate: op, args, type, filter } = this;\n    return new AggregateFunction(op, args, type, true, filter);\n  }\n\n  where(filter) {\n    const { aggregate: op, args, type, isDistinct } = this;\n    return new AggregateFunction(op, args, type, isDistinct, filter);\n  }\n\n  window() {\n    const { aggregate: op, args, type, isDistinct } = this;\n    const func = new AggregateFunction(op, args, null, isDistinct);\n    return new WindowFunction(op, func, type);\n  }\n\n  partitionby(...expr) {\n    return this.window().partitionby(...expr);\n  }\n\n  orderby(...expr) {\n    return this.window().orderby(...expr);\n  }\n\n  rows(prev, next) {\n    return this.window().rows(prev, next);\n  }\n\n  range(prev, next) {\n    return this.window().range(prev, next);\n  }\n}\n\nfunction aggExpr(op, args, type, isDistinct, filter) {\n  const close = `)${type ? `::${type}` : ''}`;\n  let strings = [`${op}(${isDistinct ? 'DISTINCT ' :''}`];\n  let exprs = [];\n  if (args.length) {\n    strings = strings.concat([\n      ...repeat(args.length - 1, ', '),\n      `${close}${filter ? ' FILTER (WHERE ' : ''}`,\n      ...(filter ? [')'] : [])\n    ]);\n    exprs = [...args, ...(filter ? [filter] : [])];\n  } else {\n    strings[0] += '*' + close;\n  }\n  return { exprs, strings };\n}\n\nfunction unquoted(value) {\n  const s = literalToSQL(value);\n  return s && s.startsWith('\"') && s.endsWith('\"') ? s.slice(1, -1) : s\n}\n\nfunction aggf(op, type) {\n  return (...args) => new AggregateFunction(op, args, type);\n}\n\nexport const count = aggf('COUNT', 'INTEGER');\nexport const avg = aggf('AVG');\nexport const mean = aggf('AVG');\nexport const mad = aggf('MAD');\nexport const max = aggf('MAX');\nexport const min = aggf('MIN');\nexport const sum = aggf('SUM', 'DOUBLE');\nexport const product = aggf('PRODUCT');\nexport const median = aggf('MEDIAN');\nexport const quantile = aggf('QUANTILE');\nexport const mode = aggf('MODE');\n\nexport const variance = aggf('VARIANCE');\nexport const stddev = aggf('STDDEV');\nexport const skewness = aggf('SKEWNESS');\nexport const kurtosis = aggf('KURTOSIS');\nexport const entropy = aggf('ENTROPY');\nexport const varPop = aggf('VAR_POP');\nexport const stddevPop = aggf('STDDEV_POP');\n\nexport const corr = aggf('CORR');\nexport const covarPop = aggf('COVAR_POP');\nexport const regrIntercept = aggf('REGR_INTERCEPT');\nexport const regrSlope = aggf('REGR_SLOPE');\nexport const regrCount = aggf('REGR_COUNT');\nexport const regrR2 = aggf('REGR_R2');\nexport const regrSYY = aggf('REGR_SYY');\nexport const regrSXX = aggf('REGR_SXX');\nexport const regrSXY = aggf('REGR_SXY');\nexport const regrAvgX = aggf('REGR_AVGX');\nexport const regrAvgY = aggf('REGR_AVGY');\n\nexport const first = aggf('FIRST');\nexport const last = aggf('LAST');\n\nexport const argmin = aggf('ARG_MIN');\nexport const argmax = aggf('ARG_MAX');\n\nexport const stringAgg = aggf('STRING_AGG');\nexport const arrayAgg = aggf('ARRAY_AGG');\n", "import { sql } from './expression.js';\nimport { asColumn } from './ref.js';\n\nexport function cast(expr, type) {\n  const arg = asColumn(expr);\n  const e = sql`CAST(${arg} AS ${type})`;\n  Object.defineProperty(e, 'label', {\n    enumerable: true,\n    get() { return expr.label; }\n  });\n  Object.defineProperty(e, 'aggregate', {\n    enumerable: true,\n    get() { return expr.aggregate || false; }\n  });\n  return e;\n}\n\nexport const castDouble = expr => cast(expr, 'DOUBLE');\nexport const castInteger = expr => cast(expr, 'INTEGER');\n", "import { sql } from './expression.js';\nimport { asColumn } from './ref.js';\n\nexport const epoch_ms = expr => {\n  const d = asColumn(expr);\n  return sql`(1000 * (epoch(${d}) - second(${d})) + millisecond(${d}))::DOUBLE`;\n};\n\nexport const dateMonth = expr => {\n  const d = asColumn(expr);\n  return sql`MAKE_DATE(2012, MONTH(${d}), 1)`\n    .annotate({ label: 'month' });\n};\n\nexport const dateMonthDay = expr => {\n  const d = asColumn(expr);\n  return sql`MAKE_DATE(2012, MONTH(${d}), DAY(${d}))`\n    .annotate({ label: 'date' });\n};\n\nexport const dateDay = expr => {\n  const d = asColumn(expr);\n  return sql`MAKE_DATE(2012, 1, DAY(${d}))`\n    .annotate({ label: 'date' });\n};\n", "import { isSQLExpression } from './expression.js';\nimport { asColumn, asRelation, isColumnRefFor, Ref } from './ref.js';\n\nexport class Query {\n\n  static select(...expr) {\n    return new Query().select(...expr);\n  }\n\n  static from(...expr) {\n    return new Query().from(...expr);\n  }\n\n  static with(...expr) {\n    return new Query().with(...expr);\n  }\n\n  static union(...queries) {\n    return new SetOperation('UNION', queries.flat());\n  }\n\n  static unionAll(...queries) {\n    return new SetOperation('UNION ALL', queries.flat());\n  }\n\n  static intersect(...queries) {\n    return new SetOperation('INTERSECT', queries.flat());\n  }\n\n  static except(...queries) {\n    return new SetOperation('EXCEPT', queries.flat());\n  }\n\n  constructor() {\n    this.query = {\n      with: [],\n      select: [],\n      from: [],\n      where: [],\n      groupby: [],\n      having: [],\n      window: [],\n      qualify: [],\n      orderby: []\n    };\n  }\n\n  clone() {\n    const q = new Query();\n    q.query = { ...this.query };\n    return q;\n  }\n\n  with(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.with;\n    } else {\n      const list = [];\n      const add = (as, q) => {\n        const query = q.clone();\n        query.cteFor = this;\n        list.push({ as, query });\n      };\n      expr.flat().forEach(e => {\n        if (e == null) {\n          // do nothing\n        } else if (e.as && e.query) {\n          add(e.as, e.query);\n        } else {\n          for (const as in e) {\n            add(as, e[as]);\n          }\n        }\n      });\n      query.with = query.with.concat(list);\n      return this;\n    }\n  }\n\n  select(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.select;\n    } else {\n      const list = [];\n      for (const e of expr.flat()) {\n        if (e == null) {\n          // do nothing\n        } else if (typeof e === 'string') {\n          list.push({ as: e, expr: asColumn(e) });\n        } else if (e instanceof Ref) {\n          list.push({ as: e.column, expr: e });\n        } else if (Array.isArray(e)) {\n          list.push({ as: e[0], expr: e[1] });\n        } else {\n          for (const as in e) {\n            list.push({ as: unquote(as), expr: asColumn(e[as]) });\n          }\n        }\n      }\n      query.select = query.select.concat(list);\n      return this;\n    }\n  }\n\n  $select(...expr) {\n    this.query.select = [];\n    return this.select(...expr);\n  }\n\n  distinct(value = true) {\n    this.query.distinct = !!value;\n    return this;\n  }\n\n  from(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.from;\n    } else {\n      const list = [];\n      expr.flat().forEach(e => {\n        if (e == null) {\n          // do nothing\n        } else if (typeof e === 'string') {\n          list.push({ as: e, from: asRelation(e) });\n        } else if (e instanceof Ref) {\n          list.push({ as: e.table, from: e });\n        } else if (isQuery(e) || isSQLExpression(e)) {\n          list.push({ from: e });\n        } else if (Array.isArray(e)) {\n          list.push({ as: unquote(e[0]), from: asRelation(e[1]) });\n        } else {\n          for (const as in e) {\n            list.push({ as: unquote(as), from: asRelation(e[as]) });\n          }\n        }\n      });\n      query.from = query.from.concat(list);\n      return this;\n    }\n  }\n\n  $from(...expr) {\n    this.query.from = [];\n    return this.from(...expr);\n  }\n\n  sample(value, method) {\n    const { query } = this;\n    if (arguments.length === 0) {\n      return query.sample;\n    } else {\n      let spec = value;\n      if (typeof value === 'number') {\n        spec = value > 0 && value < 1\n            ? { perc: 100 * value, method }\n            : { rows: Math.round(value), method };\n      }\n      query.sample = spec;\n      return this;\n    }\n  }\n\n  where(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.where;\n    } else {\n      query.where = query.where.concat(\n        expr.flat().filter(x => x)\n      );\n      return this;\n    }\n  }\n\n  $where(...expr) {\n    this.query.where = [];\n    return this.where(...expr);\n  }\n\n  groupby(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.groupby;\n    } else {\n      query.groupby = query.groupby.concat(\n        expr.flat().filter(x => x).map(asColumn)\n      );\n      return this;\n    }\n  }\n\n  $groupby(...expr) {\n    this.query.groupby = [];\n    return this.groupby(...expr);\n  }\n\n  having(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.having;\n    } else {\n      query.having = query.having.concat(\n        expr.flat().filter(x => x)\n      );\n      return this;\n    }\n  }\n\n  window(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.window;\n    } else {\n      const list = [];\n      expr.flat().forEach(e => {\n        if (e == null) {\n          // do nothing\n        } else {\n          for (const as in e) {\n            list.push({ as: unquote(as), expr: e[as] });\n          }\n        }\n      });\n      query.window = query.window.concat(list);\n      return this;\n    }\n  }\n\n  qualify(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.qualify;\n    } else {\n      query.qualify = query.qualify.concat(\n        expr.flat().filter(x => x)\n      );\n      return this;\n    }\n  }\n\n  orderby(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.orderby;\n    } else {\n      query.orderby = query.orderby.concat(\n        expr.flat().filter(x => x).map(asColumn)\n      );\n      return this;\n    }\n  }\n\n  limit(value) {\n    const { query } = this;\n    if (arguments.length === 0) {\n      return query.limit;\n    } else {\n      query.limit = Number.isFinite(value) ? value : undefined;\n      return this;\n    }\n  }\n\n  offset(value) {\n    const { query } = this;\n    if (arguments.length === 0) {\n      return query.offset;\n    } else {\n      query.offset = Number.isFinite(value) ? value : undefined;\n      return this;\n    }\n  }\n\n  get subqueries() {\n    const { query, cteFor } = this;\n    const ctes = (cteFor?.query || query).with;\n    const cte = ctes?.reduce((o, {as, query}) => (o[as] = query, o), {});\n    const q = [];\n    query.from.forEach(({ from }) => {\n      if (isQuery(from)) {\n        q.push(from);\n      } else if (cte[from.table]) {\n        const sub = cte[from.table];\n        q.push(sub);\n      }\n    });\n    return q;\n  }\n\n  toString() {\n    const {\n      select, distinct, from, sample, where, groupby,\n      having, window, qualify, orderby, limit, offset, with: cte\n    } = this.query;\n\n    const sql = [];\n\n    // WITH\n    if (cte.length) {\n      const list = cte.map(({ as, query })=> `\"${as}\" AS (${query})`);\n      sql.push(`WITH ${list.join(', ')}`);\n    }\n\n    // SELECT\n    const sels = select.map(\n      ({ as, expr }) => isColumnRefFor(expr, as) && !expr.table\n        ? `${expr}`\n        : `${expr} AS \"${as}\"`\n    );\n    sql.push(`SELECT${distinct ? ' DISTINCT' : ''} ${sels.join(', ')}`);\n\n    // FROM\n    if (from.length) {\n      const rels = from.map(({ as, from }) => {\n        const rel = isQuery(from) ? `(${from})` : `${from}`;\n        return !as || as === from.table ? rel : `${rel} AS \"${as}\"`;\n      });\n      sql.push(`FROM ${rels.join(', ')}`);\n    }\n\n    // WHERE\n    if (where.length) {\n      const clauses = where.map(String).filter(x => x).join(' AND ');\n      if (clauses) sql.push(`WHERE ${clauses}`);\n    }\n\n    // SAMPLE\n    if (sample) {\n      const { rows, perc, method, seed } = sample;\n      const size = rows ? `${rows} ROWS` : `${perc} PERCENT`;\n      const how = method ? ` (${method}${seed != null ? `, ${seed}` : ''})` : '';\n      sql.push(`USING SAMPLE ${size}${how}`);\n    }\n\n    // GROUP BY\n    if (groupby.length) {\n      sql.push(`GROUP BY ${groupby.join(', ')}`);\n    }\n\n    // HAVING\n    if (having.length) {\n      const clauses = having.map(String).filter(x => x).join(' AND ');\n      if (clauses) sql.push(`HAVING ${clauses}`);\n    }\n\n    // WINDOW\n    if (window.length) {\n      const windows = window.map(({ as, expr }) => `\"${as}\" AS (${expr})`);\n      sql.push(`WINDOW ${windows.join(', ')}`);\n    }\n\n    // QUALIFY\n    if (qualify.length) {\n      const clauses = qualify.map(String).filter(x => x).join(' AND ');\n      if (clauses) sql.push(`QUALIFY ${clauses}`);\n    }\n\n    // ORDER BY\n    if (orderby.length) {\n      sql.push(`ORDER BY ${orderby.join(', ')}`);\n    }\n\n    // LIMIT\n    if (Number.isFinite(limit)) {\n      sql.push(`LIMIT ${limit}`);\n    }\n\n    // OFFSET\n    if (Number.isFinite(offset)) {\n      sql.push(`OFFSET ${offset}`);\n    }\n\n    return sql.join(' ');\n  }\n}\n\nexport class SetOperation {\n  constructor(op, queries) {\n    this.op = op;\n    this.queries = queries.map(q => q.clone());\n    this.query = { orderby: [] };\n  }\n\n  clone() {\n    const q = new SetOperation(this.op, this.queries);\n    q.query = { ...this.query };\n    return q;\n  }\n\n  orderby(...expr) {\n    const { query } = this;\n    if (expr.length === 0) {\n      return query.orderby;\n    } else {\n      query.orderby = query.orderby.concat(\n        expr.flat().filter(x => x).map(asColumn)\n      );\n      return this;\n    }\n  }\n\n  limit(value) {\n    const { query } = this;\n    if (arguments.length === 0) {\n      return query.limit;\n    } else {\n      query.limit = Number.isFinite(value) ? value : undefined;\n      return this;\n    }\n  }\n\n  offset(value) {\n    const { query } = this;\n    if (arguments.length === 0) {\n      return query.offset;\n    } else {\n      query.offset = Number.isFinite(value) ? value : undefined;\n      return this;\n    }\n  }\n\n  get subqueries() {\n    const { queries, cteFor } = this;\n    if (cteFor) queries.forEach(q => q.cteFor = cteFor);\n    return queries;\n  }\n\n  toString() {\n    const { op, queries, query: { orderby, limit, offset } } = this;\n\n    const sql = [ queries.join(` ${op} `) ];\n\n    // ORDER BY\n    if (orderby.length) {\n      sql.push(`ORDER BY ${orderby.join(', ')}`);\n    }\n\n    // LIMIT\n    if (Number.isFinite(limit)) {\n      sql.push(`LIMIT ${limit}`);\n    }\n\n    // OFFSET\n    if (Number.isFinite(offset)) {\n      sql.push(`OFFSET ${offset}`);\n    }\n\n    return sql.join(' ');\n  }\n}\n\nexport function isQuery(value) {\n  return value instanceof Query || value instanceof SetOperation;\n}\n\nfunction unquote(s) {\n  return isDoubleQuoted(s) ? s.slice(1, -1) : s;\n}\n\nfunction isDoubleQuoted(s) {\n  return s[0] === '\"' && s[s.length-1] === '\"';\n}\n", "export function create(name, query, {\n  replace = false,\n  temp = true,\n  view = false\n} = {}) {\n  return 'CREATE'\n    + (replace ? ' OR REPLACE ' : ' ')\n    + (temp ? 'TEMP ' : '')\n    + (view ? 'VIEW' : 'TABLE')\n    + (replace ? ' ' : ' IF NOT EXISTS ')\n    + name + ' AS ' + query;\n}\n", "import { literalToSQL } from '../to-sql.js';\n\nexport function sqlFrom(data, {\n  columns = Object.keys(data?.[0] || {})\n} = {}) {\n  let keys = [];\n  if (Array.isArray(columns)) {\n    keys = columns;\n    columns = keys.reduce((m, k) => (m[k] = k, m), {});\n  } else if (columns) {\n    keys = Object.keys(columns);\n  }\n  if (!keys.length) {\n    throw new Error('Can not create table from empty column set.');\n  }\n  const subq = [];\n  for (const datum of data) {\n    const sel = keys.map(k => `${literalToSQL(datum[k])} AS \"${columns[k]}\"`);\n    subq.push(`(SELECT ${sel.join(', ')})`);\n  }\n  return subq.join(' UNION ALL ');\n}\n", "import { create } from './create.js';\nimport { sqlFrom } from './sql-from.js';\n\nexport function load(method, tableName, fileName, options = {}, defaults = {}) {\n  const { select = ['*'], where, view, temp, replace, ...file } = options;\n  const params = parameters({ ...defaults, ...file });\n  const read = `${method}('${fileName}'${params ? ', ' + params : ''})`;\n  const filter = where ? ` WHERE ${where}` : '';\n  const query = `SELECT ${select.join(', ')} FROM ${read}${filter}`;\n  return create(tableName, query, { view, temp, replace });\n}\n\nexport function loadCSV(tableName, fileName, options) {\n  return load('read_csv', tableName, fileName, options, { auto_detect: true, sample_size: -1 });\n}\n\nexport function loadJSON(tableName, fileName, options) {\n  return load('read_json', tableName, fileName, options, { auto_detect: true, json_format: 'auto' });\n}\n\nexport function loadParquet(tableName, fileName, options) {\n  return load('read_parquet', tableName, fileName, options);\n}\n\nexport function loadObjects(tableName, data, options = {}) {\n  const { select = ['*'], ...opt } = options;\n  const values = sqlFrom(data);\n  const query = select.length === 1 && select[0] === '*'\n    ? values\n    : `SELECT ${select} FROM ${values}`;\n  return create(tableName, query, opt);\n}\n\nfunction parameters(options) {\n  return Object.entries(options)\n    .map(([key, value]) => `${key}=${toDuckDBValue(value)}`)\n    .join(', ');\n}\n\nfunction toDuckDBValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return String(value);\n    case 'string':\n      return `'${value}'`;\n    case 'undefined':\n    case 'object':\n      if (value == null) {\n        return 'NULL';\n      } else if (Array.isArray(value)) {\n        return '[' + value.map(v => toDuckDBValue(v)).join(', ') + ']';\n      } else {\n        return '{'\n          + Object.entries(value)\n              .map(([k, v]) => `'${k}': ${toDuckDBValue(v)}`)\n              .join(', ')\n          + '}';\n      }\n    default:\n      return value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["column", "prefix", "length", "cast", "isDistinct", "query", "sql", "from"]
}
