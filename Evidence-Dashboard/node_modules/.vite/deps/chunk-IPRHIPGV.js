import {
  sharedPromise
} from "./chunk-SYM22BZ5.js";
import {
  nanoid
} from "./chunk-SXJKXYHY.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-BYPFWIQ6.js";

// ../../node_modules/@evidence-dev/sdk/src/lib/debug.js
var isDebug = () => {
  if (typeof process !== "undefined")
    return Boolean(
      process.env.EVIDENCE_DEBUG || process.env.VITE_PUBLIC_EVIDENCE_DEBUG || false
    );
  if (typeof import.meta.env !== "undefined")
    return Boolean(import.meta.env.EVIDENCE_DEBUG) || Boolean(import.meta.env.VITE_PUBLIC_EVIDENCE_DEBUG);
};

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/ref.js
var Ref = class {
  /**
   * Create a new Ref instance.
   * @param {string|Ref|null} table The table name.
   * @param {string|null} column The column name.
   */
  constructor(table, column2) {
    if (table)
      this.table = String(table);
    if (column2)
      this.column = column2;
  }
  /**
   * Get the list of referenced columns. Either a single element array
   * if column is non-null, otherwise an empty array.
   */
  get columns() {
    return this.column ? [this.column] : [];
  }
  /**
   * Generate a SQL string for this reference.
   * @returns {string} The SQL string.
   */
  toString() {
    const { table, column: column2 } = this;
    if (column2) {
      const col = column2.startsWith("*") ? column2 : `"${column2}"`;
      return `${table ? `${quoteTableName(table)}.` : ""}${col}`;
    } else {
      return table ? quoteTableName(table) : "NULL";
    }
  }
};
function quoteTableName(table) {
  const pieces = table.split(".");
  return pieces.map((p) => `"${p}"`).join(".");
}
function isColumnRefFor(ref, name) {
  return ref instanceof Ref && ref.column === name;
}
function asColumn(value) {
  return typeof value === "string" ? column(value) : value;
}
function asRelation(value) {
  return typeof value === "string" ? relation(value) : value;
}
function relation(name) {
  return new Ref(name);
}
function column(table, column2) {
  if (arguments.length === 1) {
    column2 = table;
    table = null;
  }
  return new Ref(table, column2);
}

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/to-sql.js
function literalToSQL(value) {
  switch (typeof value) {
    case "boolean":
      return value ? "TRUE" : "FALSE";
    case "string":
      return `'${value}'`;
    case "number":
      return Number.isFinite(value) ? String(value) : "NULL";
    default:
      if (value == null) {
        return "NULL";
      } else if (value instanceof Date) {
        const ts = +value;
        if (Number.isNaN(ts))
          return "NULL";
        const y = value.getUTCFullYear();
        const m = value.getUTCMonth();
        const d = value.getUTCDate();
        return ts === Date.UTC(y, m, d) ? `MAKE_DATE(${y}, ${m + 1}, ${d})` : `EPOCH_MS(${ts})`;
      } else if (value instanceof RegExp) {
        return `'${value.source}'`;
      } else {
        return String(value);
      }
  }
}

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/expression.js
var isParamLike = (value) => typeof (value == null ? void 0 : value.addEventListener) === "function";
function isSQLExpression(value) {
  return value instanceof SQLExpression;
}
var SQLExpression = class {
  /**
   * Create a new SQL expression instance.
   * @param {(string|SQLExpression|Ref)[]} parts The parts of the expression.
   * @param {string[]} [columns=[]] The column dependencies
   * @param {object} [props] Additional properties for this expression.
   */
  constructor(parts, columns, props) {
    this._expr = Array.isArray(parts) ? parts : [parts];
    this._deps = columns || [];
    this.annotate(props);
    const params = this._expr.filter((part) => isParamLike(part));
    if (params.length > 0) {
      this._params = Array.from(new Set(params));
      this._params.forEach((param) => {
        param.addEventListener("value", () => {
          var _a;
          return update(this, (_a = this.map) == null ? void 0 : _a.get("value"));
        });
      });
    } else {
      this.addEventListener = void 0;
    }
  }
  /**
   * A reference to this expression.
   * Provides compatibility with param-like objects.
   */
  get value() {
    return this;
  }
  /**
   * The column dependencies of this expression.
   * @returns {string[]} The columns dependencies.
   */
  get columns() {
    const { _params, _deps } = this;
    if (_params) {
      const pset = new Set(_params.flatMap((p) => {
        var _a;
        const cols = (_a = p.value) == null ? void 0 : _a.columns;
        return Array.isArray(cols) ? cols : [];
      }));
      if (pset.size) {
        const set = new Set(_deps);
        pset.forEach((col) => set.add(col));
        return Array.from(set);
      }
    }
    return _deps;
  }
  /**
   * The first column dependency in this expression, or undefined if none.
   * @returns {string} The first column dependency.
   */
  get column() {
    return this._deps.length ? this._deps[0] : this.columns[0];
  }
  /**
   * Annotate this expression instance with additional properties.
   * @param {object[]} [props] One or more objects with properties to add.
   * @returns {this} This SQL expression.
   */
  annotate(...props) {
    return Object.assign(this, ...props);
  }
  /**
   * Generate a SQL code string corresponding to this expression.
   * @returns {string} A SQL code string.
   */
  toString() {
    return this._expr.map((p) => isParamLike(p) && !isSQLExpression(p) ? literalToSQL(p.value) : p).join("");
  }
  /**
   * Add an event listener callback for the provided event type.
   * @param {string} type The event type to listen for (for example, "value").
   * @param {(a: SQLExpression) => Promise?} callback The callback function to
   *  invoke upon updates. A callback may optionally return a Promise that
   *  upstream listeners may await before proceeding.
   */
  addEventListener(type, callback) {
    const map = this.map || (this.map = /* @__PURE__ */ new Map());
    const set = map.get(type) || (map.set(type, /* @__PURE__ */ new Set()), map.get(type));
    set.add(callback);
  }
};
function update(expr, callbacks) {
  if (callbacks == null ? void 0 : callbacks.size) {
    return Promise.allSettled(Array.from(callbacks, (fn) => fn(expr)));
  }
}
function parseSQL(strings, exprs) {
  const spans = [strings[0]];
  const cols = /* @__PURE__ */ new Set();
  const n = exprs.length;
  for (let i = 0, k = 0; i < n; ) {
    const e = exprs[i];
    if (isParamLike(e)) {
      spans[++k] = e;
    } else {
      if (Array.isArray(e == null ? void 0 : e.columns)) {
        e.columns.forEach((col) => cols.add(col));
      }
      spans[k] += typeof e === "string" ? e : literalToSQL(e);
    }
    const s = strings[++i];
    if (isParamLike(spans[k])) {
      spans[++k] = s;
    } else {
      spans[k] += s;
    }
  }
  return { spans, cols: Array.from(cols) };
}
function sql(strings, ...exprs) {
  const { spans, cols } = parseSQL(strings, exprs);
  return new SQLExpression(spans, cols);
}

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/operators.js
function visit(callback) {
  var _a;
  callback(this.op, this);
  (_a = this.children) == null ? void 0 : _a.forEach((v) => v.visit(callback));
}
var unaryOp = (op) => (a) => sql`(${op} ${asColumn(a)})`.annotate({ op, a, visit });
var not = unaryOp("NOT");
var unaryPostOp = (op) => (a) => sql`(${asColumn(a)} ${op})`.annotate({ op, a, visit });
var isNull = unaryPostOp("IS NULL");
var isNotNull = unaryPostOp("IS NOT NULL");
var binaryOp = (op) => (a, b) => sql`(${asColumn(a)} ${op} ${asColumn(b)})`.annotate({ op, a, b, visit });
var eq = binaryOp("=");
var neq = binaryOp("<>");
var lt = binaryOp("<");
var gt = binaryOp(">");
var lte = binaryOp("<=");
var gte = binaryOp(">=");
var isDistinct = binaryOp("IS DISTINCT FROM");
var isNotDistinct = binaryOp("IS NOT DISTINCT FROM");

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/repeat.js
function repeat(length2, str) {
  return Array.from({ length: length2 }, () => str);
}

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/functions.js
function functionCall(op, type) {
  return (...values) => {
    const args = values.map(asColumn);
    const cast2 = type ? `::${type}` : "";
    const expr = args.length ? sql([`${op}(`, ...repeat(args.length - 1, ", "), `)${cast2}`], ...args) : sql`${op}()${cast2}`;
    return expr.annotate({ func: op, args });
  };
}
var regexp_matches = functionCall("REGEXP_MATCHES");
var contains = functionCall("CONTAINS");
var prefix = functionCall("PREFIX");
var suffix = functionCall("SUFFIX");
var lower = functionCall("LOWER");
var upper = functionCall("UPPER");
var length = functionCall("LENGTH");
var isNaN = functionCall("ISNAN");
var isFinite = functionCall("ISFINITE");
var isInfinite = functionCall("ISINF");

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/windows.js
var WindowFunction = class _WindowFunction extends SQLExpression {
  constructor(op, func, type, name, group = "", order = "", frame = "") {
    let expr;
    const noWindowParams = !(group || order || frame);
    if (name && noWindowParams) {
      expr = name ? sql`${func} OVER "${name}"` : sql`${func} OVER ()`;
    } else {
      const s1 = group && order ? " " : "";
      const s2 = (group || order) && frame ? " " : "";
      expr = sql`${func} OVER (${name ? `"${name}" ` : ""}${group}${s1}${order}${s2}${frame})`;
    }
    if (type) {
      expr = sql`(${expr})::${type}`;
    }
    const { _expr, _deps } = expr;
    super(_expr, _deps, { window: op, func, type, name, group, order, frame });
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { func } = this;
    return func.label ?? func.toString();
  }
  over(name) {
    const { window: op, func, type, group, order, frame } = this;
    return new _WindowFunction(op, func, type, name, group, order, frame);
  }
  partitionby(...expr) {
    const exprs = expr.flat().filter((x) => x).map(asColumn);
    const group = sql(
      ["PARTITION BY ", repeat(exprs.length - 1, ", "), ""],
      ...exprs
    );
    const { window: op, func, type, name, order, frame } = this;
    return new _WindowFunction(op, func, type, name, group, order, frame);
  }
  orderby(...expr) {
    const exprs = expr.flat().filter((x) => x).map(asColumn);
    const order = sql(
      ["ORDER BY ", repeat(exprs.length - 1, ", "), ""],
      ...exprs
    );
    const { window: op, func, type, name, group, frame } = this;
    return new _WindowFunction(op, func, type, name, group, order, frame);
  }
  rows(expr) {
    const frame = windowFrame("ROWS", expr);
    const { window: op, func, type, name, group, order } = this;
    return new _WindowFunction(op, func, type, name, group, order, frame);
  }
  range(expr) {
    const frame = windowFrame("RANGE", expr);
    const { window: op, func, type, name, group, order } = this;
    return new _WindowFunction(op, func, type, name, group, order, frame);
  }
};
function windowFrame(type, frame) {
  if (isParamLike(frame)) {
    const expr = sql`${frame}`;
    expr.toString = () => `${type} ${frameToSQL(frame.value)}`;
    return expr;
  }
  return `${type} ${frameToSQL(frame)}`;
}
function frameToSQL(frame) {
  const [prev, next] = frame;
  const a = prev === 0 ? "CURRENT ROW" : Number.isFinite(prev) ? `${Math.abs(prev)} PRECEDING` : "UNBOUNDED PRECEDING";
  const b = next === 0 ? "CURRENT ROW" : Number.isFinite(next) ? `${Math.abs(next)} FOLLOWING` : "UNBOUNDED FOLLOWING";
  return `BETWEEN ${a} AND ${b}`;
}
function winf(op, type) {
  return (...values) => {
    const func = functionCall(op)(...values);
    return new WindowFunction(op, func, type);
  };
}
var row_number = winf("ROW_NUMBER", "INTEGER");
var rank = winf("RANK", "INTEGER");
var dense_rank = winf("DENSE_RANK", "INTEGER");
var percent_rank = winf("PERCENT_RANK");
var cume_dist = winf("CUME_DIST");
var ntile = winf("NTILE");
var lag = winf("LAG");
var lead = winf("LEAD");
var first_value = winf("FIRST_VALUE");
var last_value = winf("LAST_VALUE");
var nth_value = winf("NTH_VALUE");

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/aggregates.js
var AggregateFunction = class _AggregateFunction extends SQLExpression {
  constructor(op, args, type, isDistinct2, filter) {
    args = (args || []).map(asColumn);
    const { strings, exprs } = aggExpr(op, args, type, isDistinct2, filter);
    const { spans, cols } = parseSQL(strings, exprs);
    super(spans, cols, { aggregate: op, args, type, isDistinct: isDistinct2, filter });
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { aggregate: op, args, isDistinct: isDistinct2 } = this;
    const dist = isDistinct2 ? "DISTINCT" + (args.length ? " " : "") : "";
    const tail = args.length ? `(${dist}${args.map(unquoted).join(", ")})` : "";
    return `${op.toLowerCase()}${tail}`;
  }
  distinct() {
    const { aggregate: op, args, type, filter } = this;
    return new _AggregateFunction(op, args, type, true, filter);
  }
  where(filter) {
    const { aggregate: op, args, type, isDistinct: isDistinct2 } = this;
    return new _AggregateFunction(op, args, type, isDistinct2, filter);
  }
  window() {
    const { aggregate: op, args, type, isDistinct: isDistinct2 } = this;
    const func = new _AggregateFunction(op, args, null, isDistinct2);
    return new WindowFunction(op, func, type);
  }
  partitionby(...expr) {
    return this.window().partitionby(...expr);
  }
  orderby(...expr) {
    return this.window().orderby(...expr);
  }
  rows(prev, next) {
    return this.window().rows(prev, next);
  }
  range(prev, next) {
    return this.window().range(prev, next);
  }
};
function aggExpr(op, args, type, isDistinct2, filter) {
  const close = `)${type ? `::${type}` : ""}`;
  let strings = [`${op}(${isDistinct2 ? "DISTINCT " : ""}`];
  let exprs = [];
  if (args.length) {
    strings = strings.concat([
      ...repeat(args.length - 1, ", "),
      `${close}${filter ? " FILTER (WHERE " : ""}`,
      ...filter ? [")"] : []
    ]);
    exprs = [...args, ...filter ? [filter] : []];
  } else {
    strings[0] += "*" + close;
  }
  return { exprs, strings };
}
function unquoted(value) {
  const s = literalToSQL(value);
  return s && s.startsWith('"') && s.endsWith('"') ? s.slice(1, -1) : s;
}
function aggf(op, type) {
  return (...args) => new AggregateFunction(op, args, type);
}
var count = aggf("COUNT", "INTEGER");
var avg = aggf("AVG");
var mean = aggf("AVG");
var mad = aggf("MAD");
var max = aggf("MAX");
var min = aggf("MIN");
var sum = aggf("SUM", "DOUBLE");
var product = aggf("PRODUCT");
var median = aggf("MEDIAN");
var quantile = aggf("QUANTILE");
var mode = aggf("MODE");
var variance = aggf("VARIANCE");
var stddev = aggf("STDDEV");
var skewness = aggf("SKEWNESS");
var kurtosis = aggf("KURTOSIS");
var entropy = aggf("ENTROPY");
var varPop = aggf("VAR_POP");
var stddevPop = aggf("STDDEV_POP");
var corr = aggf("CORR");
var covarPop = aggf("COVAR_POP");
var regrIntercept = aggf("REGR_INTERCEPT");
var regrSlope = aggf("REGR_SLOPE");
var regrCount = aggf("REGR_COUNT");
var regrR2 = aggf("REGR_R2");
var regrSYY = aggf("REGR_SYY");
var regrSXX = aggf("REGR_SXX");
var regrSXY = aggf("REGR_SXY");
var regrAvgX = aggf("REGR_AVGX");
var regrAvgY = aggf("REGR_AVGY");
var first = aggf("FIRST");
var last = aggf("LAST");
var argmin = aggf("ARG_MIN");
var argmax = aggf("ARG_MAX");
var stringAgg = aggf("STRING_AGG");
var arrayAgg = aggf("ARRAY_AGG");

// ../../node_modules/@evidence-dev/sdk/node_modules/@uwdata/mosaic-sql/src/Query.js
var Query = class _Query2 {
  static select(...expr) {
    return new _Query2().select(...expr);
  }
  static from(...expr) {
    return new _Query2().from(...expr);
  }
  static with(...expr) {
    return new _Query2().with(...expr);
  }
  static union(...queries) {
    return new SetOperation("UNION", queries.flat());
  }
  static unionAll(...queries) {
    return new SetOperation("UNION ALL", queries.flat());
  }
  static intersect(...queries) {
    return new SetOperation("INTERSECT", queries.flat());
  }
  static except(...queries) {
    return new SetOperation("EXCEPT", queries.flat());
  }
  constructor() {
    this.query = {
      with: [],
      select: [],
      from: [],
      where: [],
      groupby: [],
      having: [],
      window: [],
      qualify: [],
      orderby: []
    };
  }
  clone() {
    const q = new _Query2();
    q.query = { ...this.query };
    return q;
  }
  with(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.with;
    } else {
      const list = [];
      const add = (as, q) => {
        const query2 = q.clone();
        query2.cteFor = this;
        list.push({ as, query: query2 });
      };
      expr.flat().forEach((e) => {
        if (e == null) {
        } else if (e.as && e.query) {
          add(e.as, e.query);
        } else {
          for (const as in e) {
            add(as, e[as]);
          }
        }
      });
      query.with = query.with.concat(list);
      return this;
    }
  }
  select(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.select;
    } else {
      const list = [];
      for (const e of expr.flat()) {
        if (e == null) {
        } else if (typeof e === "string") {
          list.push({ as: e, expr: asColumn(e) });
        } else if (e instanceof Ref) {
          list.push({ as: e.column, expr: e });
        } else if (Array.isArray(e)) {
          list.push({ as: e[0], expr: e[1] });
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), expr: asColumn(e[as]) });
          }
        }
      }
      query.select = query.select.concat(list);
      return this;
    }
  }
  $select(...expr) {
    this.query.select = [];
    return this.select(...expr);
  }
  distinct(value = true) {
    this.query.distinct = !!value;
    return this;
  }
  from(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.from;
    } else {
      const list = [];
      expr.flat().forEach((e) => {
        if (e == null) {
        } else if (typeof e === "string") {
          list.push({ as: e, from: asRelation(e) });
        } else if (e instanceof Ref) {
          list.push({ as: e.table, from: e });
        } else if (isQuery(e) || isSQLExpression(e)) {
          list.push({ from: e });
        } else if (Array.isArray(e)) {
          list.push({ as: unquote(e[0]), from: asRelation(e[1]) });
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), from: asRelation(e[as]) });
          }
        }
      });
      query.from = query.from.concat(list);
      return this;
    }
  }
  $from(...expr) {
    this.query.from = [];
    return this.from(...expr);
  }
  sample(value, method) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.sample;
    } else {
      let spec = value;
      if (typeof value === "number") {
        spec = value > 0 && value < 1 ? { perc: 100 * value, method } : { rows: Math.round(value), method };
      }
      query.sample = spec;
      return this;
    }
  }
  where(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.where;
    } else {
      query.where = query.where.concat(
        expr.flat().filter((x) => x)
      );
      return this;
    }
  }
  $where(...expr) {
    this.query.where = [];
    return this.where(...expr);
  }
  groupby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.groupby;
    } else {
      query.groupby = query.groupby.concat(
        expr.flat().filter((x) => x).map(asColumn)
      );
      return this;
    }
  }
  $groupby(...expr) {
    this.query.groupby = [];
    return this.groupby(...expr);
  }
  having(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.having;
    } else {
      query.having = query.having.concat(
        expr.flat().filter((x) => x)
      );
      return this;
    }
  }
  window(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.window;
    } else {
      const list = [];
      expr.flat().forEach((e) => {
        if (e == null) {
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), expr: e[as] });
          }
        }
      });
      query.window = query.window.concat(list);
      return this;
    }
  }
  qualify(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.qualify;
    } else {
      query.qualify = query.qualify.concat(
        expr.flat().filter((x) => x)
      );
      return this;
    }
  }
  orderby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.orderby;
    } else {
      query.orderby = query.orderby.concat(
        expr.flat().filter((x) => x).map(asColumn)
      );
      return this;
    }
  }
  limit(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.limit;
    } else {
      query.limit = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  offset(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.offset;
    } else {
      query.offset = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  get subqueries() {
    const { query, cteFor } = this;
    const ctes = ((cteFor == null ? void 0 : cteFor.query) || query).with;
    const cte = ctes == null ? void 0 : ctes.reduce((o, { as, query: query2 }) => (o[as] = query2, o), {});
    const q = [];
    query.from.forEach(({ from }) => {
      if (isQuery(from)) {
        q.push(from);
      } else if (cte[from.table]) {
        const sub = cte[from.table];
        q.push(sub);
      }
    });
    return q;
  }
  toString() {
    const {
      select,
      distinct,
      from,
      sample,
      where,
      groupby,
      having,
      window: window2,
      qualify,
      orderby,
      limit,
      offset,
      with: cte
    } = this.query;
    const sql2 = [];
    if (cte.length) {
      const list = cte.map(({ as, query }) => `"${as}" AS (${query})`);
      sql2.push(`WITH ${list.join(", ")}`);
    }
    const sels = select.map(
      ({ as, expr }) => isColumnRefFor(expr, as) && !expr.table ? `${expr}` : `${expr} AS "${as}"`
    );
    sql2.push(`SELECT${distinct ? " DISTINCT" : ""} ${sels.join(", ")}`);
    if (from.length) {
      const rels = from.map(({ as, from: from2 }) => {
        const rel = isQuery(from2) ? `(${from2})` : `${from2}`;
        return !as || as === from2.table ? rel : `${rel} AS "${as}"`;
      });
      sql2.push(`FROM ${rels.join(", ")}`);
    }
    if (where.length) {
      const clauses = where.map(String).filter((x) => x).join(" AND ");
      if (clauses)
        sql2.push(`WHERE ${clauses}`);
    }
    if (sample) {
      const { rows, perc, method, seed } = sample;
      const size = rows ? `${rows} ROWS` : `${perc} PERCENT`;
      const how = method ? ` (${method}${seed != null ? `, ${seed}` : ""})` : "";
      sql2.push(`USING SAMPLE ${size}${how}`);
    }
    if (groupby.length) {
      sql2.push(`GROUP BY ${groupby.join(", ")}`);
    }
    if (having.length) {
      const clauses = having.map(String).filter((x) => x).join(" AND ");
      if (clauses)
        sql2.push(`HAVING ${clauses}`);
    }
    if (window2.length) {
      const windows = window2.map(({ as, expr }) => `"${as}" AS (${expr})`);
      sql2.push(`WINDOW ${windows.join(", ")}`);
    }
    if (qualify.length) {
      const clauses = qualify.map(String).filter((x) => x).join(" AND ");
      if (clauses)
        sql2.push(`QUALIFY ${clauses}`);
    }
    if (orderby.length) {
      sql2.push(`ORDER BY ${orderby.join(", ")}`);
    }
    if (Number.isFinite(limit)) {
      sql2.push(`LIMIT ${limit}`);
    }
    if (Number.isFinite(offset)) {
      sql2.push(`OFFSET ${offset}`);
    }
    return sql2.join(" ");
  }
};
var SetOperation = class _SetOperation {
  constructor(op, queries) {
    this.op = op;
    this.queries = queries.map((q) => q.clone());
    this.query = { orderby: [] };
  }
  clone() {
    const q = new _SetOperation(this.op, this.queries);
    q.query = { ...this.query };
    return q;
  }
  orderby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.orderby;
    } else {
      query.orderby = query.orderby.concat(
        expr.flat().filter((x) => x).map(asColumn)
      );
      return this;
    }
  }
  limit(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.limit;
    } else {
      query.limit = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  offset(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.offset;
    } else {
      query.offset = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  get subqueries() {
    const { queries, cteFor } = this;
    if (cteFor)
      queries.forEach((q) => q.cteFor = cteFor);
    return queries;
  }
  toString() {
    const { op, queries, query: { orderby, limit, offset } } = this;
    const sql2 = [queries.join(` ${op} `)];
    if (orderby.length) {
      sql2.push(`ORDER BY ${orderby.join(", ")}`);
    }
    if (Number.isFinite(limit)) {
      sql2.push(`LIMIT ${limit}`);
    }
    if (Number.isFinite(offset)) {
      sql2.push(`OFFSET ${offset}`);
    }
    return sql2.join(" ");
  }
};
function isQuery(value) {
  return value instanceof Query || value instanceof SetOperation;
}
function unquote(s) {
  return isDoubleQuoted(s) ? s.slice(1, -1) : s;
}
function isDoubleQuoted(s) {
  return s[0] === '"' && s[s.length - 1] === '"';
}

// ../../node_modules/@evidence-dev/sdk/src/usql/utilities/resolveMaybePromise.js
var resolveMaybePromise = (handler, value, onError) => {
  try {
    const v = typeof value === "function" ? (
      /** @type {() => import("../types.js").MaybePromise<T>} */
      value()
    ) : value;
    if (v instanceof Promise) {
      return v.then((v2) => handler(v2, true)).catch((e) => {
        const error = e instanceof Error ? e : new Error("Unknown Error", { cause: e });
        if (onError)
          return onError(error, true);
        throw error;
      });
    } else {
      return handler(v, false);
    }
  } catch (e) {
    const error = e instanceof Error ? e : new Error("Unknown Error", { cause: e });
    if (onError)
      return onError(error, false);
    else
      throw error;
  }
};

// ../../node_modules/@evidence-dev/sdk/src/usql/query/queryScore.js
var getQueryScore = (length2, columns) => {
  const scorePerRow = columns.reduce(
    (a, v) => a + columnTypeToScore(v.column_type),
    columns.length * 4
    // include overhead for each column
  );
  return Math.abs(scorePerRow * length2);
};
function isObjectType(columnType) {
  return columnType.startsWith("STRUCT") || columnType.endsWith("[]");
}
function isDecimalType(columnType) {
  return columnType.startsWith("DECIMAL");
}
function columnTypeToScore(columnType) {
  const roundedColumnScores = {
    string: 2 * 15,
    number: 12,
    boolean: 4,
    date: 48
  };
  if (isObjectType(columnType)) {
    console.warn(
      "[!] Evidence does not support DuckDB Struct or Array\nIf you need to use one, convert it to JSON in your query, and then manually parse it in your project"
    );
    return roundedColumnScores.string;
  }
  if (isDecimalType(columnType))
    return roundedColumnScores.number;
  switch (columnType) {
    case "BOOLEAN":
      return roundedColumnScores.boolean;
    case "BIGINT":
    case "DOUBLE":
    case "FLOAT":
    case "INTEGER":
    case "SMALLINT":
    case "TINYINT":
    case "UBIGINT":
    case "UINTEGER":
    case "USMALLINT":
    case "UTINYINT":
    case "HUGEINT":
      return roundedColumnScores.number;
    case "UUID":
    case "VARCHAR":
      return roundedColumnScores.string;
    case "DATE":
    case "TIMESTAMP":
    case "TIMESTAMP_S":
    case "TIMESTAMP_MS":
    case "TIMESTAMP_NS":
    case "TIMESTAMP WITH TIME ZONE":
      return roundedColumnScores.date;
    case "INTERVAL":
    case "TIME":
    case "TIME WITH TIME ZONE":
    case "BLOB":
    case "BIT":
      return roundedColumnScores.string;
    default:
      console.error(`Column type ${columnType} is not supported`);
      return roundedColumnScores.string;
  }
}

// ../../node_modules/@evidence-dev/sdk/src/build-dev/vite/constants.js
var VITE_EVENTS = Object.freeze({
  SOURCE_END: "evidence:source-end",
  SOURCE_START: "evidence:source-start",
  SOURCE_ERROR: "evidence:source-error",
  RESET_QUERIES: "evidence:reset-queries"
});

// ../../node_modules/@evidence-dev/sdk/src/usql/query/sterilizeQuery.js
var unescapedComment = /--([^']|'.*')+$/;
var inlinedMultilineComments = /(\/\*.*\*\/)/g;
var sterilizeQuery = (query) => {
  const lines = query.split("\n");
  let inMultilineComment = false;
  for (let i = lines.length; i > 0; i--) {
    let line = lines[i - 1];
    let append = "";
    const multilineMatches = Array.from(line.matchAll(inlinedMultilineComments));
    for (const multilineMatch of multilineMatches) {
      const before = line.slice(0, multilineMatch.index);
      const after = line.slice(multilineMatch.index + multilineMatch[0].length);
      line = `${before}${after}`;
    }
    if (inMultilineComment) {
      if (line.includes("/*")) {
        inMultilineComment = false;
        const parts = line.split("/*");
        line = parts.slice(0, -1).join("/*");
        append += "/*" + parts.slice(-1);
      }
    }
    if (line.trim().endsWith("*/")) {
      inMultilineComment = true;
      continue;
    }
    const match = unescapedComment.exec(line);
    if (match) {
      const before = line.slice(0, match.index);
      const trimmed = before.trimEnd();
      if (trimmed.endsWith(";")) {
        const after = line.slice(match.index);
        const mid = before.slice(trimmed.length, before.length);
        line = `${before.slice(0, -1 + -1 * (before.length - trimmed.length))}${mid}${after}`;
      }
    } else {
      const trimmed = line.trimEnd();
      if (trimmed.endsWith(";")) {
        const lastIdx = line.lastIndexOf(";");
        line = line.slice(0, lastIdx) + line.slice(lastIdx + 1);
      }
    }
    for (const multilineMatch of multilineMatches) {
      const before = line.slice(0, multilineMatch.index);
      const after = line.slice(multilineMatch.index);
      line = `${before}${multilineMatch[0]}${after}`;
    }
    if (line !== lines[i - 1]) {
      lines[i - 1] = line + append;
      break;
    }
  }
  lines.push("");
  return lines.join("\n");
};

// ../../node_modules/@evidence-dev/sdk/src/usql/query/Query.js
var _hasInitialData, _value, _data, _dataQueryTime, _length, _lengthQueryTime, _columns, _mockRow, _columnsQueryTime, ___error, _error, error_get, error_set, _query, _originalText, _inFlightQueries, _markInFlight, _globalHandlerMap, _globalEmit, _scoreThreshold, _score, _calculateScore, _sharedDataPromise, _fetchData, _sharedLengthPromise, _fetchLength, _sharedColumnsPromise, _fetchColumns, _buildProxy, _cache, _addToCache, _getFromCache, _cacheCleanup, _devModeBootstrapped, _devModeBootstraps, _debugStatic, _debugStyledStatic, _debug, _debugStyled, _constructing, _id, _hash, _opts, _inheritableOpts, inheritableOpts_get, _executeQuery, _subscribers, _publishIdx, _handlerMap, _emit, _aggFns, _checkAggFn;
var _Query = class _Query {
  // TODO: Score (this should be done in another file)
  // TODO: When dealing with builder functions, add a `select` or similar
  /**
   * @param {QueryBuilder | string} query
   * @param {import('../types.js').Runner} executeQuery
   * @param {import("../types.js").QueryOpts<RowType>} opts
   * @deprecated Use {@link Query.create} instead
   */
  constructor(query, executeQuery, opts = {}) {
    __privateAdd(this, _error);
    /** @type {Pick<import("../types.js").QueryOpts<RowType>, 'autoScore' | 'noResolve' | 'disableCache'>} */
    __privateAdd(this, _inheritableOpts);
    ////////////////////////////
    /// < State Primatives > ///
    ////////////////////////////
    __privateAdd(this, _hasInitialData, false);
    /** @type {QueryValue<RowType>} */
    __privateAdd(this, _value, void 0);
    /// Data
    /** @type {RowType[]} */
    __privateAdd(this, _data, []);
    /** @type {number} */
    __privateAdd(this, _dataQueryTime, -1);
    /// Length
    /** @type {number} */
    __privateAdd(this, _length, 0);
    /** @type {number} */
    __privateAdd(this, _lengthQueryTime, -1);
    /// Columns
    /** @type {import('../../types/duckdb-wellknown.js').DescribeResultRow[]} */
    __privateAdd(this, _columns, []);
    /** @type {Record<keyof RowType, undefined> | undefined} */
    __privateAdd(this, _mockRow, void 0);
    /** @type {number} */
    __privateAdd(this, _columnsQueryTime, -1);
    /**
     * Use the getter/setter for #error instead of this value directly
     * @type {Error | undefined}
     */
    __privateAdd(this, ___error, void 0);
    /** @type {QueryBuilder} */
    __privateAdd(this, _query, void 0);
    /** @type {string} */
    __privateAdd(this, _originalText, void 0);
    /** @type { number } */
    __privateAdd(this, _score, -1);
    __privateAdd(this, _calculateScore, () => {
      if (this.lengthLoaded && this.columnsLoaded) {
        __privateSet(this, _score, getQueryScore(this.length, this.columns));
        if (__privateGet(this, _score) > __privateGet(_Query, _scoreThreshold)) {
          __privateGet(this, _emit).call(this, "highScore", __privateGet(this, _score));
        }
      } else {
        Promise.allSettled([__privateGet(this, _sharedLengthPromise).promise, __privateGet(this, _sharedColumnsPromise).promise]).then(([$lengthRaw, $columnsRaw]) => {
          if ($lengthRaw.status === "rejected" || $columnsRaw.status === "rejected") {
            __privateSet(this, _score, -1);
            return;
          }
          if (!__privateGet(this, _length) || !__privateGet(this, _columns)) {
            __privateSet(this, _score, -1);
            return;
          }
          __privateSet(this, _score, getQueryScore(this.length, this.columns));
          if (__privateGet(this, _score) > __privateGet(_Query, _scoreThreshold)) {
            __privateGet(this, _emit).call(this, "highScore", __privateGet(this, _score));
          }
        }).catch((e) => {
          console.error(`${this.id} | Failed to calculate Query score ${e}`);
        });
      }
    });
    /** @type {ChainableSharedPromise<RowType>} */
    __privateAdd(this, _sharedDataPromise, sharedPromise(
      () => this.publish(`data promise (${__privateGet(this, _sharedDataPromise).state})`)
    ));
    /** @returns {MaybePromise<Query<RowType>>} */
    __privateAdd(this, _fetchData, () => {
      var _a;
      if (__privateGet(this, _sharedDataPromise).state !== "init") {
        return __privateGet(this, _sharedDataPromise).promise;
      }
      if (__privateGet(this, _error, error_get)) {
        __privateGet(this, _debug).call(this, "data error", "Refusing to execute data query, store has an error state");
        return __privateGet(this, _sharedDataPromise).promise;
      }
      if (__privateGet(this, _sharedDataPromise).state !== "init" || this.opts.noResolve)
        return __privateGet(this, _sharedDataPromise).promise;
      __privateGet(this, _sharedDataPromise).start();
      const dataQuery = `
---- Data ${__privateGet(this, _id)} ${__privateGet(this, _hash)}
${this.text.trim()}
        `.trim() + "\n";
      __privateGet(this, _debugStyled).call(this, "data query text", "\n" + dataQuery, "font-family: monospace;");
      const typedRunner = (
        /** @type {import('../types.js').Runner<RowType>} */
        __privateGet(this, _executeQuery)
      );
      __privateGet(_a = _Query, _markInFlight).call(_a, this);
      const before = performance.now();
      const resolved = resolveMaybePromise(
        (result, isPromise) => {
          __privateSet(this, _data, result);
          const after = performance.now();
          if (before - after > 5e3) {
            __privateGet(this, _emit).call(this, "longRun", before - after);
            __privateGet(this, _debug).call(this, "long-running", `Query took ${before - after}ms to execute`);
          }
          __privateSet(this, _dataQueryTime, after - before);
          __privateGet(this, _sharedDataPromise).resolve(this);
          __privateGet(this, _emit).call(this, "dataReady", void 0);
          if (isPromise) {
            return __privateGet(this, _sharedDataPromise).promise;
          } else {
            return this;
          }
        },
        () => typedRunner(dataQuery, `${__privateGet(this, _id)}_data`),
        (e, isPromise) => {
          __privateSet(this, _error, e, error_set);
          __privateGet(this, _sharedDataPromise).reject(e);
          if (isPromise) {
            return __privateGet(this, _sharedDataPromise).promise;
          } else {
            return this;
          }
        }
      );
      return resolved;
    });
    __publicField(this, "fetch", async () => {
      return Promise.allSettled([__privateGet(this, _fetchColumns).call(this), __privateGet(this, _fetchData).call(this), __privateGet(this, _fetchLength).call(this)]).then(
        () => this.value
      );
    });
    /**
     * Executes the query without actually updating the state
     * This is helpful for ensuring that the related parquet files
     * are available, even when SSR is used to initially hydrate the
     * query / page.
     *
     * Does not run on the server, only in browser
     */
    __publicField(this, "backgroundFetch", () => {
      if (typeof window === "undefined") {
        __privateGet(this, _debug).call(this, "background fetch skip", "Did not execute backgroundFetch in SSR");
        return;
      }
      __privateGet(this, _debug).call(this, "background fetch", `Executed backgroundFetch`);
      resolveMaybePromise(
        () => {
        },
        async () => {
          await new Promise((resolve) => setTimeout(resolve, 0));
          return __privateGet(this, _executeQuery).call(this, `--data
${this.text.trim()}`, this.id);
        },
        () => {
        }
      );
    });
    /** @type {ChainableSharedPromise<RowType>} */
    __privateAdd(this, _sharedLengthPromise, sharedPromise(
      () => this.publish(`length promise (${__privateGet(this, _sharedLengthPromise).state})`)
    ));
    /** @returns {MaybePromise<Query<RowType>>} */
    __privateAdd(this, _fetchLength, () => {
      if (__privateGet(this, _data) && __privateGet(this, _sharedDataPromise).state === "resolved" && __privateGet(this, _sharedLengthPromise).state === "init") {
        __privateGet(this, _debug).call(this, "length inferred", "Inferred length from already-resolved data promise", __privateGet(this, _data));
        __privateSet(this, _length, __privateGet(this, _data).length);
        __privateGet(this, _sharedLengthPromise).resolve(this);
        return __privateGet(this, _sharedLengthPromise).promise;
      }
      if (__privateGet(this, _error, error_get)) {
        __privateGet(this, _debug).call(this, "length error", "Refusing to execute length query, store has an error state", __privateGet(this, _error, error_get));
        __privateGet(this, _sharedLengthPromise).reject(__privateGet(this, _error, error_get));
        return __privateGet(this, _sharedLengthPromise).value ?? __privateGet(this, _sharedLengthPromise).promise;
      }
      if (__privateGet(this, _sharedLengthPromise).state !== "init" || this.opts.noResolve)
        return __privateGet(this, _sharedLengthPromise).promise;
      __privateGet(this, _sharedLengthPromise).start();
      const lengthQuery = `
---- Length ${__privateGet(this, _id)} (${__privateGet(this, _hash)})
SELECT COUNT(*) as rowCount FROM (${this.text.trim()})
        `.trim() + "\n";
      const typedRunner = (
        /** @type {import('../types.js').Runner<{rowCount: number}>} */
        __privateGet(this, _executeQuery)
      );
      __privateGet(this, _debugStyled).call(this, "length query text", "\n" + lengthQuery, "font-family: monospace;");
      const before = performance.now();
      const resolved = resolveMaybePromise(
        /** @returns {MaybePromise<Query<RowType>>} */
        (lengthResult, isPromise) => {
          const after = performance.now();
          __privateSet(this, _lengthQueryTime, after - before);
          __privateSet(this, _length, lengthResult[0].rowCount);
          __privateGet(this, _sharedLengthPromise).resolve(this);
          if (isPromise) {
            return __privateGet(this, _sharedLengthPromise).promise;
          } else {
            return this;
          }
        },
        () => typedRunner(lengthQuery, `${__privateGet(this, _id)}_length`),
        /** @returns {MaybePromise<Query<RowType>>} */
        (e, isPromise) => {
          __privateSet(this, _error, e, error_set);
          __privateGet(this, _sharedLengthPromise).reject(e);
          if (isPromise) {
            return __privateGet(this, _sharedLengthPromise).promise;
          } else {
            return this;
          }
        }
      );
      return (
        /** @type {MaybePromise<Query<RowType>>} */
        resolved
      );
    });
    /** @type {ChainableSharedPromise<RowType>} */
    __privateAdd(this, _sharedColumnsPromise, sharedPromise(
      () => this.publish(`columns promise (${__privateGet(this, _sharedColumnsPromise).state})`)
    ));
    /** @returns {MaybePromise<Query<RowType>>} */
    __privateAdd(this, _fetchColumns, () => {
      if (__privateGet(this, _error, error_get)) {
        __privateGet(this, _debug).call(this, "cols query error", "Refusing to execute columns query, store has an error state", __privateGet(this, _error, error_get));
        return __privateGet(this, _sharedColumnsPromise).value ?? __privateGet(this, _sharedColumnsPromise).promise;
      }
      if (__privateGet(this, _sharedColumnsPromise).state !== "init" || this.opts.noResolve)
        return __privateGet(this, _sharedColumnsPromise).promise;
      __privateGet(this, _sharedColumnsPromise).start();
      const metaQuery = `
---- Columns ${__privateGet(this, _id)} (${__privateGet(this, _hash)})
DESCRIBE ${this.text.trim()}
        `.trim() + "\n";
      __privateGet(this, _debugStyled).call(this, "columns query text", "\n" + metaQuery, "font-family: monospace;");
      const typedRunner = (
        /** @type {import('../types.js').Runner<import('../../types/duckdb-wellknown.js').DescribeResultRow>} */
        __privateGet(this, _executeQuery)
      );
      const before = performance.now();
      const resolved = resolveMaybePromise(
        (description, isPromise) => {
          const after = performance.now();
          __privateSet(this, _columnsQueryTime, after - before);
          __privateSet(this, _columns, description);
          __privateGet(this, _sharedColumnsPromise).resolve(this);
          __privateSet(
            this,
            _mockRow,
            /** @type {Record<keyof RowType, undefined>} */
            Object.fromEntries(description.map((d) => [d.column_name, void 0]))
          );
          if (isPromise) {
            return __privateGet(this, _sharedColumnsPromise).promise;
          } else {
            return this;
          }
        },
        () => typedRunner(metaQuery, `${__privateGet(this, _id)}_columns`),
        /** @returns {MaybePromise<Query<RowType>>} */
        (e, isPromise) => {
          __privateSet(this, _error, e, error_set);
          __privateGet(this, _sharedColumnsPromise).reject(e);
          if (isPromise) {
            return __privateGet(this, _sharedColumnsPromise).promise;
          } else {
            return this;
          }
        }
      );
      return (
        /** @type {MaybePromise<Query<RowType>>} */
        resolved
      );
    });
    /** @returns {QueryValue<RowType>} */
    __privateAdd(this, _buildProxy, () => {
      const proxy = (
        /** @type {QueryValue<RowType>} */
        new Proxy(
          /** @type {RowType[]} */
          [],
          {
            getPrototypeOf: () => {
              return Object.getPrototypeOf(__privateGet(this, _data));
            },
            has: (self, prop) => {
              return prop in __privateGet(this, _data) || prop in this;
            },
            get: (_self, rawProp) => {
              let prop = rawProp;
              if (typeof prop === "string" && /^[\d.]+$/.exec(prop))
                prop = parseInt(prop);
              if (typeof prop === "number" || _Query.ProxyFetchTriggers.includes(prop.toString())) {
                if (__privateGet(this, _sharedDataPromise).state === "init") {
                  __privateGet(this, _debug).call(this, "implicit fetch", `Implicit query fetch triggered by ${prop.toString()}`);
                  __privateGet(this, _fetchData).call(this);
                }
              }
              if (prop === "length") {
                __privateGet(this, _fetchLength).call(this);
              }
              if (prop === "constructor")
                return __privateGet(this, _data).constructor;
              if (prop === "toString")
                return __privateGet(this, _data).toString.bind(__privateGet(this, _data));
              const target = prop in this ? this : __privateGet(this, _data) && prop in __privateGet(this, _data) ? __privateGet(this, _data) : null;
              if (target === null)
                if (typeof prop !== "number")
                  return void 0;
                else {
                  if (prop > __privateGet(this, _length))
                    return void 0;
                  return __privateGet(this, _mockRow) ?? {};
                }
              const field = target[
                /** @type {keyof typeof target} */
                prop
              ];
              if (typeof field === "function")
                return field.bind(target);
              else
                return field;
            }
          }
        )
      );
      return proxy;
    });
    __privateAdd(this, _debug, isDebug() ? (label, ...args) => {
      const groupName = `${(performance.now() / 1e3).toFixed(3)} | ${this.id} (${this.hash}) | ${label}`;
      console.groupCollapsed(groupName);
      for (const arg of args) {
        if (typeof arg === "function")
          console.debug(arg());
        else
          console.debug(arg);
      }
      console.groupEnd();
    } : () => {
    });
    __privateAdd(this, _debugStyled, isDebug() ? (label, text, style) => {
      const groupName = `${(performance.now() / 1e3).toFixed(3)} | ${this.id} (${this.hash}) | ${label}`;
      console.groupCollapsed(groupName);
      console.debug(`%c${text}`, style);
      console.groupEnd();
    } : () => {
    });
    /** @type {string} */
    __privateAdd(this, _id, void 0);
    /** @type {string} */
    __privateAdd(this, _hash, void 0);
    /** @type {import('../types.js').QueryOpts<RowType>} */
    __privateAdd(this, _opts, void 0);
    /** @type {import('../types.js').Runner} */
    __privateAdd(this, _executeQuery, void 0);
    /** @type {import('../types.js').QueryOpts} */
    __publicField(this, "opts");
    ////////////////////////////////////
    /// < Implement Store Contract > ///
    ////////////////////////////////////
    /** @type {Set<import('../types.js').Subscriber<QueryValue<RowType>>>} */
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Set());
    /**
     * @param {import('../types.js').Subscriber<QueryValue<RowType>>} fn
     * @returns {() => void} Unsubscribe function
     */
    __publicField(this, "subscribe", (fn) => {
      __privateGet(this, _subscribers).add(fn);
      fn(__privateGet(this, _value));
      return () => __privateGet(this, _subscribers).delete(fn);
    });
    __privateAdd(this, _publishIdx, 0);
    /**
     * @protected
     */
    __publicField(this, "publish", (source) => {
      if (__privateWrapper(this, _publishIdx)._++ > 1e5)
        throw new Error("Query published too many times.");
      __privateGet(this, _debug).call(this, "publish", `Publishing triggered by ${source}`, this);
      __privateGet(this, _subscribers).forEach((fn) => fn(__privateGet(this, _value)));
    });
    //////////////////////////////////////
    /// </ Implement Store Contract /> ///
    //////////////////////////////////////
    ///////////////////////////////////////
    /// < EventEmitter Implementation > ///
    ///////////////////////////////////////
    /** @type {import('../types.js').EventMap<QueryEvents>} */
    __privateAdd(this, _handlerMap, {
      dataReady: /* @__PURE__ */ new Set(),
      error: /* @__PURE__ */ new Set(),
      highScore: /* @__PURE__ */ new Set(),
      longRun: /* @__PURE__ */ new Set()
    });
    /**
     * @template {keyof QueryEvents} Event
     * @param {Event} event
     * @param {QueryEvents[Event]} value
     */
    __privateAdd(this, _emit, (event, value) => {
      __privateGet(this, _handlerMap)[event].forEach((fn) => fn(value, event));
    });
    /**
     * @template {keyof QueryEvents} Event
     * @param {Event} event
     * @param {import('../types.js').EventHandler<QueryEvents, Event>} handler
     */
    __publicField(this, "on", (event, handler) => {
      __privateGet(this, _handlerMap)[event].add(handler);
    });
    /**
     * @template {keyof QueryEvents} Event
     * @param {Event} event
     * @param {import('../types.js').EventHandler<QueryEvents, Event>} handler
     */
    __publicField(this, "off", (event, handler) => {
      __privateGet(this, _handlerMap)[event].delete(handler);
    });
    __publicField(this, "addEventListener", this.on);
    __publicField(this, "removeEventListener", this.off);
    /////////////////////////////////////////
    /// </ EventEmitter Implementation /> ///
    /////////////////////////////////////////
    //////////////////////////////////
    /// < QueryBuilder Interface > ///
    //////////////////////////////////
    /** @param {string} filterStatement */
    __publicField(this, "where", (filterStatement) => _Query.create(__privateGet(this, _query).clone().where(sql`${filterStatement}`), __privateGet(this, _executeQuery), {
      knownColumns: __privateGet(this, _columns),
      noResolve: __privateGet(this, _opts).noResolve
    }));
    /**
     * Attaches an `ordinal` column to the query based on some window statement
     * @example myQuery.withOrdinal('partition by a order by b')
     * @param {string} windowStatement
     * @returns
     */
    __publicField(this, "withOrdinal", (windowStatement) => {
      const newQ = __privateGet(this, _query).clone();
      newQ.select({
        ordinal: sql`row_number() over (${windowStatement})`
      });
      return _Query.create(newQ, __privateGet(this, _executeQuery), {
        ...__privateGet(this, _inheritableOpts, inheritableOpts_get),
        knownColumns: __privateGet(this, _columns)
      });
    });
    /**
     * @param {string} searchTerm
     * @param {string | string[]} searchCol
     * @param {number} searchThreshold
     * @returns {QueryValue<RowType & {similarity: number}>}
     */
    __publicField(this, "search", (searchTerm, searchCol, searchThreshold = 0.5) => {
      const colsWithSimilarity = [
        ...__privateGet(this, _columns),
        { column_name: "similarity", column_type: "INTEGER", nullable: "NO" }
      ];
      const typedCreateFn = _Query.create;
      const escapedSearchTerm = searchTerm.replaceAll("'", "''");
      const cols = Array.isArray(searchCol) ? searchCol : [searchCol];
      const statements = cols.map((col) => {
        const exactMatch = sql`CASE WHEN lower("${col.trim()}") = lower('${escapedSearchTerm}') THEN 2 ELSE 0 END`;
        const similarity = sql`jaccard(lower('${escapedSearchTerm}'), lower("${col}"))`;
        const exactSubMatch = (
          // escapedSearchTerm.length >= 4
          sql`CASE WHEN lower("${col.trim()}") LIKE lower('%${escapedSearchTerm.split(" ").join("%")}%') THEN 1 ELSE 0 END`
        );
        return sql`GREATEST((${exactMatch}), (${similarity}), (${exactSubMatch}))`;
      }).join(",");
      const output = typedCreateFn(
        __privateGet(this, _query).clone().$select(
          {
            similarity: sql`GREATEST(${statements})`
          },
          "*"
        ).where(sql`"similarity" > ${searchThreshold} `).orderby(sql`"similarity" DESC`),
        __privateGet(this, _executeQuery),
        {
          knownColumns: colsWithSimilarity,
          ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
        }
      );
      return output;
    });
    /** @param {number} limit */
    __publicField(this, "limit", (limit) => _Query.create(__privateGet(this, _query).clone().limit(limit), __privateGet(this, _executeQuery), {
      knownColumns: __privateGet(this, _columns),
      ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
    }));
    /** @param {number} offset */
    __publicField(this, "offset", (offset) => _Query.create(__privateGet(this, _query).clone().offset(offset), __privateGet(this, _executeQuery), {
      knownColumns: __privateGet(this, _columns),
      ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
    }));
    /**
     * @param {number} offset
     * @param {number} limit
     */
    __publicField(this, "paginate", (offset, limit) => _Query.create(__privateGet(this, _query).clone().offset(offset).limit(limit), __privateGet(this, _executeQuery), {
      knownColumns: __privateGet(this, _columns),
      ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
    }));
    /**
     * @param {string[]} columns
     * @param {boolean} [withRowCount=true]
     */
    __publicField(this, "groupBy", (columns, withRowCount) => {
      const query = __privateGet(this, _query).clone();
      query.$select(columns);
      if (withRowCount)
        query.select({ rows: count("*") });
      query.$groupby(columns);
      return _Query.create(query, __privateGet(this, _executeQuery), {
        knownColumns: __privateGet(this, _columns),
        ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
      });
    });
    /**
     * @param {AggArgs} cfg
     */
    __publicField(this, "agg", (cfg) => {
      var _a;
      const query = __privateGet(this, _query).clone();
      for (const [aggType, aggArgs] of Object.entries(cfg)) {
        if (!__privateGet(_a = _Query, _checkAggFn).call(_a, aggType))
          throw new Error(`Unknown agg function: ${aggType}`);
        const aggFn = __privateGet(_Query, _aggFns)[aggType];
        const argsArray = Array.isArray(aggArgs) ? aggArgs : [aggArgs];
        for (const colSpec of argsArray) {
          const alias = typeof colSpec === "object" ? colSpec.as : `${aggType}_${colSpec}`;
          const column2 = typeof colSpec === "object" ? colSpec.col : colSpec;
          query.select({
            [alias]: aggFn(column2)
          });
        }
      }
      return _Query.create(query, __privateGet(this, _executeQuery), {
        knownColumns: __privateGet(this, _columns),
        ...__privateGet(this, _inheritableOpts, inheritableOpts_get)
      });
    });
    const {
      id,
      initialData = void 0,
      knownColumns = void 0,
      initialError = void 0
    } = opts;
    this.opts = opts;
    __privateSet(this, _executeQuery, executeQuery);
    if (typeof query !== "string" && !(query instanceof Query)) {
      console.warn(`Query ${id} has no query text`);
      opts.noResolve = true;
    }
    if (!__privateGet(_Query, _constructing)) {
      console.warn(
        "Directly using new Query() is not a recommended use-case. Please use Query.create()"
      );
    }
    __privateSet(_Query, _constructing, false);
    __privateSet(this, _value, __privateGet(this, _buildProxy).call(this));
    __privateSet(this, _originalText, (query == null ? void 0 : query.toString()) ?? "SELECT 'Empty Query' WHERE 0");
    __privateSet(this, _hash, hashQuery(__privateGet(this, _originalText)));
    __privateSet(this, _id, id ?? __privateGet(this, _hash));
    __privateSet(this, _opts, opts);
    if (query && typeof query !== "string")
      __privateSet(this, _query, query);
    else if (query) {
      const q = new Query().from({
        /* 
        	Use of nanoid prevent ambiguity when dealing with nested Queries; 
        	in theory this could be the querystring has but that's kinda gross 
        */
        [`inputQuery-${nanoid(2)}`]: sql`(${sterilizeQuery(query)})`
      }).select("*");
      __privateSet(this, _query, q);
    } else {
      __privateSet(this, _query, new Query());
      __privateSet(this, _error, new Error(`Refusing to create Query: No Query Text provided`), error_set);
      return;
    }
    if (initialError) {
      __privateSet(this, _error, initialError, error_set);
      return;
    }
    if (opts.noResolve) {
      __privateGet(this, _sharedDataPromise).start();
      __privateGet(this, _sharedLengthPromise).start();
      __privateGet(this, _sharedColumnsPromise).start();
      return this;
    } else if (initialData) {
      __privateGet(this, _debug).call(this, "initial data", "Created with initial data", initialData);
      __privateSet(this, _hasInitialData, true);
      resolveMaybePromise(
        (d) => {
          __privateSet(this, _data, d);
          if (opts.initialDataDirty) {
            this.publish("dataDirty");
            __privateGet(this, _fetchData).call(this);
          } else {
            __privateGet(this, _sharedDataPromise).resolve(this);
            __privateGet(this, _fetchLength).call(this);
          }
        },
        initialData,
        (e) => {
          __privateSet(this, _error, e, error_set);
        }
      );
    }
    if (knownColumns) {
      if (!Array.isArray(knownColumns))
        throw new Error(`Expected knownColumns to be an array`, { cause: knownColumns });
      __privateSet(this, _columns, knownColumns);
    } else {
      resolveMaybePromise(
        () => {
        },
        __privateGet(this, _fetchColumns).call(this),
        (e, isPromise) => {
          if (!isPromise)
            throw e;
        }
      );
    }
    resolveMaybePromise(
      () => {
      },
      __privateGet(this, _fetchLength).call(this),
      (e, isPromise) => {
        if (!isPromise)
          throw e;
      }
    );
    if (opts.autoScore) {
      __privateGet(this, _calculateScore).call(this);
    }
  }
  get value() {
    return __privateGet(this, _value);
  }
  get dataLoaded() {
    return ["resolved", "rejected"].includes(__privateGet(this, _sharedDataPromise).state);
  }
  get dataLoading() {
    return __privateGet(this, _sharedDataPromise).state === "loading";
  }
  get dataQueryTime() {
    return __privateGet(this, _dataQueryTime);
  }
  get length() {
    return __privateGet(this, _length);
  }
  get lengthLoaded() {
    return ["resolved", "rejected"].includes(__privateGet(this, _sharedLengthPromise).state);
  }
  get lengthLoading() {
    return __privateGet(this, _sharedLengthPromise).state === "loading";
  }
  get lengthQueryTime() {
    return __privateGet(this, _lengthQueryTime);
  }
  get columns() {
    return __privateGet(this, _columns);
  }
  get columnsLoaded() {
    return ["resolved", "rejected"].includes(__privateGet(this, _sharedColumnsPromise).state);
  }
  get columnsLoading() {
    return __privateGet(this, _sharedColumnsPromise).state === "loading";
  }
  get columnsQueryTime() {
    return __privateGet(this, _columnsQueryTime);
  }
  /**
   * True when data, length, and columns have all been fetched
   */
  get ready() {
    return __privateGet(this, _sharedLengthPromise).state === "resolved" && __privateGet(this, _sharedColumnsPromise).state === "resolved" && __privateGet(this, _sharedDataPromise).state === "resolved";
  }
  /**
   * True when data, length, or columns are currently being fetched
   */
  get loading() {
    return __privateGet(this, _sharedLengthPromise).state === "loading" || __privateGet(this, _sharedColumnsPromise).state === "loading" || __privateGet(this, _sharedDataPromise).state === "loading";
  }
  get error() {
    return __privateGet(this, _error, error_get);
  }
  /**
   * The Query text as is was provided
   */
  get originalText() {
    return __privateGet(this, _originalText);
  }
  /**
   * The Query text as it is being executed
   */
  get text() {
    var _a;
    return ((_a = __privateGet(this, _query)) == null ? void 0 : _a.toString()) ?? "SELECT 'Empty Query' WHERE 0";
  }
  static get queriesInFlight() {
    return __privateGet(_Query, _inFlightQueries).size > 0;
  }
  /**
   * @protected
   */
  static resetInFlightQueries() {
    __privateSet(_Query, _inFlightQueries, /* @__PURE__ */ new Set());
  }
  /** @type {QueryGlobalEventEmitter["addEventListener"]} */
  static addEventListener(event, handler) {
    __privateGet(this, _globalHandlerMap)[event].add(handler);
  }
  /** @type {QueryGlobalEventEmitter["removeEventListener"]} */
  static removeEventListener(event, handler) {
    __privateGet(this, _globalHandlerMap)[event].delete(handler);
  }
  get score() {
    return __privateGet(this, _score);
  }
  //////////////////////
  /// </ Fetching /> ///
  //////////////////////
  //////////////////////////
  /// < Type Narrowing > ///
  //////////////////////////
  /**
   * @ignore
   * @private
   */
  get isQuery() {
    return true;
  }
  ////////////////////////////
  /// </ Type Narrowing /> ///
  ////////////////////////////
  /** @param {unknown} v */
  static [Symbol.hasInstance](v) {
    return _Query.isQuery(v);
  }
  /////////////////
  /// < Proxy > ///
  /////////////////
  /** @type {string[]} */
  static get ProxyFetchTriggers() {
    return ["at"];
  }
  static get cacheSize() {
    return __privateGet(this, _cache).size;
  }
  /** @type {string} */
  get id() {
    return __privateGet(this, _id);
  }
  /** @type {string} */
  get hash() {
    return __privateGet(this, _hash);
  }
  ////////////////////////////////////
  /// </ QueryBuilder Interface /> ///
  ////////////////////////////////////
};
_hasInitialData = new WeakMap();
_value = new WeakMap();
_data = new WeakMap();
_dataQueryTime = new WeakMap();
_length = new WeakMap();
_lengthQueryTime = new WeakMap();
_columns = new WeakMap();
_mockRow = new WeakMap();
_columnsQueryTime = new WeakMap();
___error = new WeakMap();
_error = new WeakSet();
error_get = function() {
  return __privateGet(this, ___error);
};
error_set = function(v) {
  if (!v)
    return;
  console.error(`${this.id} | Error in Query!`, v == null ? void 0 : v.message);
  __privateGet(this, _emit).call(this, "error", v);
  __privateSet(this, ___error, v);
};
_query = new WeakMap();
_originalText = new WeakMap();
_inFlightQueries = new WeakMap();
_markInFlight = new WeakMap();
_globalHandlerMap = new WeakMap();
_globalEmit = new WeakMap();
_scoreThreshold = new WeakMap();
_score = new WeakMap();
_calculateScore = new WeakMap();
_sharedDataPromise = new WeakMap();
_fetchData = new WeakMap();
_sharedLengthPromise = new WeakMap();
_fetchLength = new WeakMap();
_sharedColumnsPromise = new WeakMap();
_fetchColumns = new WeakMap();
_buildProxy = new WeakMap();
_cache = new WeakMap();
_addToCache = new WeakMap();
_getFromCache = new WeakMap();
_cacheCleanup = new WeakMap();
_devModeBootstrapped = new WeakMap();
_devModeBootstraps = new WeakMap();
_debugStatic = new WeakMap();
_debugStyledStatic = new WeakMap();
_debug = new WeakMap();
_debugStyled = new WeakMap();
_constructing = new WeakMap();
_id = new WeakMap();
_hash = new WeakMap();
_opts = new WeakMap();
_inheritableOpts = new WeakSet();
inheritableOpts_get = function() {
  return {
    autoScore: __privateGet(this, _opts).autoScore,
    noResolve: __privateGet(this, _opts).noResolve,
    disableCache: __privateGet(this, _opts).disableCache
  };
};
_executeQuery = new WeakMap();
_subscribers = new WeakMap();
_publishIdx = new WeakMap();
_handlerMap = new WeakMap();
_emit = new WeakMap();
_aggFns = new WeakMap();
_checkAggFn = new WeakMap();
//////////////////////////////
/// </ State Primatives /> ///
//////////////////////////////
//////////////////////////
/// < Global Loading > ///
//////////////////////////
/** @type {Set<Query>} */
__privateAdd(_Query, _inFlightQueries, /* @__PURE__ */ new Set());
/**
 * @param {Query<any>} q
 */
__privateAdd(_Query, _markInFlight, (q) => {
  var _a;
  if (__privateGet(_Query, _inFlightQueries).size === 0) {
    __privateGet(_a = _Query, _globalEmit).call(_a, "inFlightQueryStart", void 0);
  }
  __privateGet(_Query, _inFlightQueries).add(q);
  __privateGet(q, _sharedDataPromise).promise.finally(() => {
    var _a2;
    __privateGet(_Query, _inFlightQueries).delete(q);
    if (__privateGet(_Query, _inFlightQueries).size === 0) {
      __privateGet(_a2 = _Query, _globalEmit).call(_a2, "inFlightQueryEnd", void 0);
    }
  });
});
/** @type {import("../types.js").EventMap<QueryGlobalEvents>} */
__privateAdd(_Query, _globalHandlerMap, {
  inFlightQueryStart: /* @__PURE__ */ new Set(),
  inFlightQueryEnd: /* @__PURE__ */ new Set(),
  queryCreated: /* @__PURE__ */ new Set()
});
/**
 * @template {keyof QueryGlobalEvents} Event
 * @param {Event} event
 * @param {QueryGlobalEvents[Event]} value
 */
__privateAdd(_Query, _globalEmit, (event, value) => {
  __privateGet(_Query, _globalHandlerMap)[event].forEach((fn) => fn(value, event));
});
/////////////////////////////
/// </ Global Loading />  ///
/////////////////////////////
////////////////////
/// < Fetching > ///
////////////////////
__privateAdd(_Query, _scoreThreshold, 10 * 1024 * 1024);
/**
 * @template {QueryResultRow} RowType
 * @param {unknown} q
 * @returns {q is Query<RowType>}
 */
__publicField(_Query, "isQuery", (q) => {
  if (typeof q !== "object" || !q)
    return false;
  const hasDuckType = "isQuery" in q && q["isQuery"] === true;
  return hasDuckType;
});
///////////////////
/// </ Proxy /> ///
///////////////////
/////////////////////
/// < Factories > ///
/////////////////////
/**
 * This is a fairly arbitrary number that determines how much data
 * the Query will cache internally. The larger the number, the
 * larger the cache will be.
 *
 * The number is based on our Query Score calculation, see
 * queryScore.js for details on how this is calculated.
 *
 * @default 5 * 10 * 1024
 *
 */
__publicField(_Query, "CacheMaxScore", 5 * 10 * 1024);
/**
 * @type {Map<string, {added: number, query: Query<any>}>}
 */
__privateAdd(_Query, _cache, /* @__PURE__ */ new Map());
__publicField(_Query, "emptyCache", () => {
  __privateGet(_Query, _cache).clear();
});
/**
 * @param {Query<any>} q
 */
__privateAdd(_Query, _addToCache, (q) => {
  __privateGet(_Query, _cache).set(q.hash, {
    query: q,
    added: Date.now()
  });
  if (isDebug())
    console.debug(`Added to cache: ${q.hash}`, {
      cacheSize: __privateGet(_Query, _cache).size,
      cacheScore: Array.from(__privateGet(_Query, _cache).values()).reduce((sum2, q2) => sum2 + q2.query.score, 0)
    });
});
/**
 * @template {QueryResultRow} [RowType=QueryResultRow]
 * @param {string} hash
 * @returns {Query<RowType> | null}
 */
__privateAdd(_Query, _getFromCache, (hash) => {
  const cachedValue = __privateGet(_Query, _cache).get(hash);
  if (cachedValue) {
    return cachedValue.query;
  }
  return null;
});
__privateAdd(_Query, _cacheCleanup, () => {
  let sumScore = Array.from(__privateGet(_Query, _cache).values()).reduce((sum2, q) => sum2 + q.query.score, 0);
  const sorted = Array.from(__privateGet(_Query, _cache).values()).sort((a, b) => a.added - b.added);
  while (sumScore > _Query.CacheMaxScore) {
    const oldest = sorted.shift();
    if (!oldest)
      break;
    __privateGet(_Query, _cache).delete(oldest.query.hash);
    sumScore -= oldest.query.score;
  }
});
/**
 *
 * @param {import('../types.js').QueryReactivityOpts<any>} reactiveOpts Callback that is executed when the new query is ready
 * @param {import('../types.js').QueryOpts<any>} [opts]
 * @param {QueryValue<any>} [initialQuery]
 */
__publicField(_Query, "createReactive", (reactiveOpts, opts, initialQuery) => {
  const { loadGracePeriod = 250, callback = () => {
  }, execFn } = reactiveOpts;
  const createFn = _Query.create;
  let activeQuery = initialQuery;
  let changeIdx = 0;
  let unsub;
  const waitFor = (
    /**
     * @param {string | Query} nextQuery
     * @param {import('../types.js').QueryOpts<any>} [newOpts]
     * @returns {Promise<void> | void}
     */
    (nextQuery, newOpts) => {
      var _a;
      if (!activeQuery)
        throw new Error();
      changeIdx += 1;
      const targetChangeIdx = changeIdx;
      __privateGet(_a = _Query, _debugStatic).call(_a, `${activeQuery.id} (${hashQuery(nextQuery)}) | Reactive Updating`, nextQuery, {
        changeIdx,
        targetChangeIdx,
        hash: hashQuery(nextQuery)
      }, {
        initialOpts: opts,
        newOpts
      });
      const newQuery = _Query.isQuery(nextQuery) ? nextQuery : createFn(
        nextQuery,
        execFn,
        Object.assign({}, opts, newOpts, { initialData: void 0, initialError: void 0 })
      );
      const fetched = newQuery.fetch();
      let dataMaybePromise = fetched;
      if (fetched instanceof Promise) {
        dataMaybePromise = Promise.race([
          new Promise((r) => setTimeout(r, loadGracePeriod)),
          newQuery.fetch()
        ]);
      }
      resolveMaybePromise(
        () => {
          var _a2;
          if (changeIdx !== targetChangeIdx) {
            __privateGet(_a2 = _Query, _debugStatic).call(_a2, `changeIdx does not match, results are discarded`);
            return;
          }
          unsub == null ? void 0 : unsub();
          activeQuery = newQuery.value;
          unsub = activeQuery.subscribe(callback);
        },
        dataMaybePromise,
        (e) => {
          console.warn(`Error while attempting to update reactive query: ${e.message}`);
          throw e;
        }
      );
    }
  );
  function removeInitialState() {
    opts = { ...opts, initialData: void 0, initialError: void 0 };
  }
  return (queryText, newOpts) => {
    var _a, _b;
    if (activeQuery) {
      resolveMaybePromise(
        () => {
        },
        waitFor(queryText, newOpts),
        (e) => {
          console.warn(`Error while attempting to update reactive query: ${e.message}`);
        }
      );
      return;
    }
    if ((_b = (_a = import.meta.hot) == null ? void 0 : _a.data) == null ? void 0 : _b.hmr)
      removeInitialState();
    activeQuery = createFn(queryText, execFn, Object.assign({}, opts, newOpts));
    const fetched = activeQuery.fetch();
    resolveMaybePromise(removeInitialState, fetched);
    unsub = activeQuery.subscribe(callback);
    callback(activeQuery);
    return;
  };
});
__privateAdd(_Query, _devModeBootstrapped, false);
__privateAdd(_Query, _devModeBootstraps, () => {
  if (!import.meta.hot || __privateGet(_Query, _devModeBootstrapped))
    return;
  __privateSet(_Query, _devModeBootstrapped, true);
  import.meta.hot.data.hmr = false;
  import.meta.hot.on(VITE_EVENTS.RESET_QUERIES, () => {
    if (import.meta.hot)
      import.meta.hot.data.hmr = true;
    _Query.emptyCache();
  });
});
/**
 * @template {QueryResultRow} [RowType=QueryResultRow]
 * @type {import("../types.js").CreateQuery<RowType>}
 */
__publicField(_Query, "create", (query, executeQuery, optsOrId, maybeOpts) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  if (import.meta.hot) {
    __privateGet(_a = _Query, _devModeBootstraps).call(_a);
  }
  const queryHash = hashQuery(query);
  let opts;
  if (typeof optsOrId === "string") {
    opts = {
      ...maybeOpts,
      id: optsOrId
    };
  } else if (optsOrId) {
    opts = optsOrId;
    if (!opts.id)
      opts.id = queryHash + "-" + Math.random().toString(36).substring(0, 4);
  } else {
    opts = {
      id: queryHash + "-" + Math.random().toString(36).substring(0, 4)
    };
  }
  if (!("autoScore" in opts)) {
    opts.autoScore = true;
  }
  if (!opts.disableCache) {
    const cached = __privateGet(_b = _Query, _getFromCache).call(_b, queryHash);
    __privateGet(_c = _Query, _cacheCleanup).call(_c);
    if (cached) {
      __privateGet(_d = _Query, _debugStatic).call(_d, `${opts.id ?? "[query id missing]"} (${queryHash}) | Using cached query`, { opts, hash: hashQuery(query) }, query, cached);
      return cached.value;
    } else {
      __privateGet(_e = _Query, _debugStatic).call(_e, `${opts.id ?? "[query id missing]"} (${queryHash}) | Cached query not found`, {
        opts,
        hash: hashQuery(query)
      }, query);
    }
  } else
    __privateGet(_f = _Query, _debugStatic).call(_f, `${opts.id ?? "[query id missing]"} (${queryHash}) | cache disabled`, `Cache is disabled for ${opts.id ?? "[query id missing]"}`, { opts, query, hash: hashQuery(query) });
  __privateSet(_Query, _constructing, true);
  const output = new _Query(query, executeQuery, opts);
  __privateGet(_g = _Query, _globalEmit).call(_g, "queryCreated", { raw: output, proxied: output.value });
  if (!opts.disableCache) {
    __privateGet(_h = _Query, _addToCache).call(_h, output);
    __privateGet(_i = _Query, _cacheCleanup).call(_i);
  }
  return output.value;
});
///////////////////////
/// </ Factories /> ///
///////////////////////
__privateAdd(_Query, _debugStatic, isDebug() ? (label, ...args) => {
  const groupName = `${(performance.now() / 1e3).toFixed(3)} | Query | ${label}`;
  console.groupCollapsed(groupName);
  for (const arg of args) {
    if (typeof arg === "function")
      console.debug(arg());
    else
      console.debug(arg);
  }
  console.groupEnd();
} : () => {
});
__privateAdd(_Query, _debugStyledStatic, isDebug() ? (label, text, style) => {
  const groupName = `${(performance.now() / 1e3).toFixed(3)} | Query | ${label}`;
  console.groupCollapsed(groupName);
  console.debug(`%c${text}`, style);
  console.groupEnd();
} : () => {
});
__privateAdd(_Query, _constructing, false);
/**
 * @typedef {Object} AggArgs
 * @property {import("../types.js").MaybeAliasedCol | import("../types.js").MaybeAliasedCol[]} sum
 * @property {import("../types.js").MaybeAliasedCol | import("../types.js").MaybeAliasedCol[]} avg
 * @property {import("../types.js").MaybeAliasedCol | import("../types.js").MaybeAliasedCol[]} min
 * @property {import("../types.js").MaybeAliasedCol | import("../types.js").MaybeAliasedCol[]} max
 * @property {import("../types.js").MaybeAliasedCol | import("../types.js").MaybeAliasedCol[]} median
 */
/**
 * @type {Record<keyof AggArgs, CallableFunction>}
 */
__privateAdd(_Query, _aggFns, {
  sum,
  avg,
  min,
  max,
  median
});
/**
 *
 * @param {string} aggKey
 * @returns {aggKey is keyof AggArgs}
 */
__privateAdd(_Query, _checkAggFn, (aggKey) => {
  return aggKey in __privateGet(_Query, _aggFns);
});
var Query2 = _Query;
var hashQuery = (...args) => {
  const simpleHash = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash &= hash;
    }
    return new Uint32Array([hash])[0].toString(36);
  };
  return simpleHash(JSON.stringify(args));
};

// ../../node_modules/@evidence-dev/sdk/src/usql/utilities/duckdbSerialize.js
var duckdbSerialize = (value, opts = { serializeStrings: true }) => {
  if (value == null)
    return "null";
  if (typeof value === "string") {
    if (opts.serializeStrings !== false)
      return `'${value.replaceAll("'", "''")}'`;
    else {
      return value;
    }
  }
  if (typeof value === "number" || typeof value === "bigint" || typeof value === "boolean")
    return String(value);
  if (value instanceof Date)
    return `'${value.toISOString()}'::TIMESTAMP_MS`;
  if (Array.isArray(value))
    return `[${value.map((x) => duckdbSerialize(x, opts)).join(", ")}]`;
  return JSON.stringify(value);
};

// ../../node_modules/@evidence-dev/sdk/src/usql/setTrackProxy/setTrackProxy.js
var Unset = Symbol("Unset");
var IsSetTracked = Symbol("IsSetTracked");
var GetModKeys = Symbol("GetModKeys");
var setTrackProxy = (defaultStringMap = {}, root = {}, parent = void 0, ownKey = void 0) => {
  if (parent && !parent[IsSetTracked])
    throw new Error(`SetTracked parent must be SetTracked`);
  const wrapped = Object.assign(() => {
  }, root ?? {});
  const modifiedKeys = Object.keys(wrapped);
  const self = new Proxy(wrapped, {
    get(target, prop) {
      switch (prop) {
        case Unset:
          return !(parent == null ? void 0 : parent[GetModKeys].includes(ownKey));
        case GetModKeys:
          return modifiedKeys;
        case IsSetTracked:
          return true;
        case "toJSON":
          return () => ({ ...target });
        case "toString":
        case "toPrimitive":
        case Symbol.toPrimitive:
          if (self[Unset]) {
            if (ownKey && ownKey in defaultStringMap)
              return () => defaultStringMap[ownKey];
            return () => ``;
          } else
            return root.toString.bind(root);
        default:
          if (!(prop in target)) {
            target[prop] = setTrackProxy(defaultStringMap, void 0, self, prop);
          }
          return target[prop];
      }
    },
    set(target, prop, value) {
      modifiedKeys.push(prop);
      if (typeof value === "object") {
        value = setTrackProxy(defaultStringMap, value, self, prop);
      }
      target[prop] = value;
      return true;
    }
  });
  return self;
};
var hasUnsetValues = (strings, ...args) => {
  return args.some((arg) => arg == null ? void 0 : arg[Unset]);
};

export {
  resolveMaybePromise,
  Query2 as Query,
  hashQuery,
  duckdbSerialize,
  Unset,
  IsSetTracked,
  setTrackProxy,
  hasUnsetValues
};
//# sourceMappingURL=chunk-IPRHIPGV.js.map
