import {
  require_node_process
} from "./chunk-6ORU4JVO.js";
import {
  require_fs,
  require_path
} from "./chunk-A5FTJMUP.js";
import {
  __commonJS,
  __toESM
} from "./chunk-BYPFWIQ6.js";

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/ini/ini.js
var require_ini = __commonJS({
  "../../node_modules/ini/ini.js"(exports) {
    exports.parse = exports.decode = decode;
    exports.stringify = exports.encode = encode;
    exports.safe = safe;
    exports.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// ../../node_modules/gitconfiglocal/index.js
var require_gitconfiglocal = __commonJS({
  "../../node_modules/gitconfiglocal/index.js"(exports, module) {
    var fs = require_fs();
    var ini = require_ini();
    var path = require_path();
    module.exports = function(dir, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      findGit(dir, options, function(config) {
        if (!config)
          return cb(new Error("no gitconfig to be found at " + dir));
        fs.readFile(config, function(err, data) {
          if (err)
            return cb(err);
          try {
            var formatted = format(ini.parse(data.toString()));
          } catch (e) {
            return cb(e);
          }
          cb(false, formatted);
        });
      });
    };
    function format(data) {
      var out = {};
      Object.keys(data).forEach(function(k) {
        if (k.indexOf('"') > -1) {
          var parts = k.split('"');
          var parentKey = parts.shift().trim();
          var childKey = parts.shift().trim();
          if (!out[parentKey])
            out[parentKey] = {};
          out[parentKey][childKey] = data[k];
        } else {
          out[k] = merge(out[k], data[k]);
        }
      });
      return out;
    }
    function findGit(dir, options, cb) {
      var folder = path.resolve(dir, options.gitDir || process.env.GIT_DIR || ".git", "config");
      fs.exists(folder, function(exists) {
        if (exists)
          return cb(folder);
        if (dir === path.resolve(dir, ".."))
          return cb(false);
        findGit(path.resolve(dir, ".."), options, cb);
      });
    }
    function merge() {
      var a = {};
      for (var i = arguments.length; i >= 0; --i) {
        Object.keys(arguments[i] || {}).forEach((k) => {
          a[k] = arguments[i][k];
        });
      }
      return a;
    }
  }
});

// ../../node_modules/git-remote-origin-url/index.js
var import_node_util = __toESM(require_node_util());
var import_node_process = __toESM(require_node_process());
var import_gitconfiglocal = __toESM(require_gitconfiglocal());
var pGitconfig = (0, import_node_util.promisify)(import_gitconfiglocal.default);
async function gitRemoteOriginUrl({ cwd = import_node_process.default.cwd(), remoteName = "origin" } = {}) {
  const config = await pGitconfig(cwd);
  const url = config.remote && config.remote[remoteName] && config.remote[remoteName].url;
  if (!url) {
    throw new Error(`Couldn't find ${remoteName} url`);
  }
  return url;
}
export {
  gitRemoteOriginUrl as default
};
//# sourceMappingURL=git-remote-origin-url.js.map
