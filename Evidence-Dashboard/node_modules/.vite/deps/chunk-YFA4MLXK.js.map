{
  "version": 3,
  "sources": ["../../@lukeed/csprng/browser/index.js", "../../@lukeed/uuid/secure/index.js", "../../@segment/analytics-core/dist/esm/emitter/interface.js", "../../@segment/analytics-core/dist/esm/plugins/index.js", "../../@segment/analytics-core/dist/esm/events/interfaces.js", "../../dset/dist/index.mjs", "../../@segment/analytics-core/src/utils/pick.ts", "../../@segment/analytics-core/src/validation/errors.ts", "../../@segment/analytics-core/src/validation/helpers.ts", "../../@segment/analytics-core/src/validation/assertions.ts", "../../@segment/analytics-core/src/events/index.ts", "../../@segment/analytics-core/src/callback/index.ts", "../../@segment/analytics-generic-utils/src/create-deferred/create-deferred.ts", "../../@segment/analytics-generic-utils/src/create-deferred/index.ts", "../../@segment/analytics-generic-utils/src/emitter/emitter.ts", "../../@segment/analytics-generic-utils/src/emitter/index.ts", "../../@segment/analytics-generic-utils/src/index.ts", "../../@segment/analytics-core/src/priority-queue/backoff.ts", "../../@segment/analytics-core/src/priority-queue/index.ts", "../../@lukeed/uuid/dist/index.mjs", "../../@segment/analytics-core/src/logger/index.ts", "../../@segment/analytics-core/src/stats/index.ts", "../../@segment/analytics-core/src/context/index.ts", "../../@segment/analytics-core/src/utils/group-by.ts", "../../@segment/analytics-core/src/utils/is-thenable.ts", "../../@segment/analytics-core/src/task/task-group.ts", "../../@segment/analytics-core/src/queue/delivery.ts", "../../@segment/analytics-core/src/queue/event-queue.ts", "../../@segment/analytics-core/dist/esm/analytics/index.js", "../../@segment/analytics-core/src/analytics/dispatch.ts", "../../@segment/analytics-core/src/utils/bind-all.ts", "../../@segment/analytics-core/src/index.ts", "../../@segment/analytics-node/src/app/settings.ts", "../../@segment/analytics-node/src/generated/version.ts", "../../@segment/analytics-node/src/lib/create-url.ts", "../../@segment/analytics-node/src/lib/uuid.ts", "../../@segment/analytics-node/src/plugins/segmentio/context-batch.ts", "../../jose/dist/browser/runtime/webcrypto.js", "../../jose/dist/browser/runtime/digest.js", "../../jose/dist/browser/lib/buffer_utils.js", "../../jose/dist/browser/runtime/base64url.js", "../../jose/dist/browser/util/errors.js", "../../jose/dist/browser/runtime/random.js", "../../jose/dist/browser/lib/iv.js", "../../jose/dist/browser/lib/check_iv_length.js", "../../jose/dist/browser/runtime/check_cek_length.js", "../../jose/dist/browser/runtime/timing_safe_equal.js", "../../jose/dist/browser/lib/crypto_key.js", "../../jose/dist/browser/lib/invalid_key_input.js", "../../jose/dist/browser/runtime/is_key_like.js", "../../jose/dist/browser/runtime/decrypt.js", "../../jose/dist/browser/lib/is_disjoint.js", "../../jose/dist/browser/lib/is_object.js", "../../jose/dist/browser/runtime/bogus.js", "../../jose/dist/browser/runtime/aeskw.js", "../../jose/dist/browser/runtime/ecdhes.js", "../../jose/dist/browser/lib/check_p2s.js", "../../jose/dist/browser/runtime/pbes2kw.js", "../../jose/dist/browser/runtime/subtle_rsaes.js", "../../jose/dist/browser/runtime/check_key_length.js", "../../jose/dist/browser/runtime/rsaes.js", "../../jose/dist/browser/lib/cek.js", "../../jose/dist/browser/lib/format_pem.js", "../../jose/dist/browser/runtime/asn1.js", "../../jose/dist/browser/runtime/jwk_to_key.js", "../../jose/dist/browser/key/import.js", "../../jose/dist/browser/lib/check_key_type.js", "../../jose/dist/browser/runtime/encrypt.js", "../../jose/dist/browser/lib/aesgcmkw.js", "../../jose/dist/browser/lib/decrypt_key_management.js", "../../jose/dist/browser/lib/validate_crit.js", "../../jose/dist/browser/lib/validate_algorithms.js", "../../jose/dist/browser/jwe/flattened/decrypt.js", "../../jose/dist/browser/jwe/compact/decrypt.js", "../../jose/dist/browser/jwe/general/decrypt.js", "../../jose/dist/browser/runtime/key_to_jwk.js", "../../jose/dist/browser/key/export.js", "../../jose/dist/browser/lib/encrypt_key_management.js", "../../jose/dist/browser/jwe/flattened/encrypt.js", "../../jose/dist/browser/jwe/general/encrypt.js", "../../jose/dist/browser/runtime/subtle_dsa.js", "../../jose/dist/browser/runtime/get_sign_verify_key.js", "../../jose/dist/browser/runtime/verify.js", "../../jose/dist/browser/jws/flattened/verify.js", "../../jose/dist/browser/jws/compact/verify.js", "../../jose/dist/browser/jws/general/verify.js", "../../jose/dist/browser/lib/epoch.js", "../../jose/dist/browser/lib/secs.js", "../../jose/dist/browser/lib/jwt_claims_set.js", "../../jose/dist/browser/jwt/verify.js", "../../jose/dist/browser/jwt/decrypt.js", "../../jose/dist/browser/jwe/compact/encrypt.js", "../../jose/dist/browser/runtime/sign.js", "../../jose/dist/browser/jws/flattened/sign.js", "../../jose/dist/browser/jws/compact/sign.js", "../../jose/dist/browser/jws/general/sign.js", "../../jose/dist/browser/jwt/produce.js", "../../jose/dist/browser/jwt/sign.js", "../../jose/dist/browser/jwt/encrypt.js", "../../jose/dist/browser/jwk/thumbprint.js", "../../jose/dist/browser/jwk/embedded.js", "../../jose/dist/browser/jwks/local.js", "../../jose/dist/browser/runtime/fetch_jwks.js", "../../jose/dist/browser/jwks/remote.js", "../../jose/dist/browser/jwt/unsecured.js", "../../jose/dist/browser/util/base64url.js", "../../jose/dist/browser/util/decode_protected_header.js", "../../jose/dist/browser/util/decode_jwt.js", "../../jose/dist/browser/runtime/generate.js", "../../jose/dist/browser/key/generate_key_pair.js", "../../jose/dist/browser/key/generate_secret.js", "../../jose/dist/browser/runtime/runtime.js", "../../jose/dist/browser/util/runtime.js", "../../jose/dist/browser/index.js", "../../@segment/analytics-node/src/lib/token-manager.ts", "../../@segment/analytics-node/src/plugins/segmentio/publisher.ts", "../../@segment/analytics-node/src/lib/env.ts", "../../@segment/analytics-node/src/plugins/segmentio/index.ts", "../../@segment/analytics-node/src/lib/get-message-id.ts", "../../@segment/analytics-node/src/app/event-factory.ts", "../../@segment/analytics-node/src/app/context.ts", "../../@segment/analytics-node/src/app/dispatch-emit.ts", "../../@segment/analytics-node/src/app/emitter.ts", "../../@segment/analytics-node/src/app/event-queue.ts", "../../@segment/analytics-node/src/lib/abort.ts", "../../@segment/analytics-node/src/lib/fetch.ts", "../../@segment/analytics-node/src/lib/http-client.ts", "../../@segment/analytics-node/src/app/analytics-node.ts", "../../@segment/analytics-node/src/index.common.ts", "../../@segment/analytics-node/src/index.ts", "../../@evidence-dev/telemetry/index.cjs"],
  "sourcesContent": ["function random(len) {\n\treturn crypto.getRandomValues(new Uint8Array(len));\n}\n\nexports.random = random;", "const { random } = require('@lukeed/csprng');\n\nvar SIZE=4096, HEX=[], IDX=0, BUFFER;\n\nfor (; IDX < 256; IDX++) {\n\tHEX[IDX] = (IDX + 256).toString(16).substring(1);\n}\n\nfunction v4() {\n\tif (!BUFFER || ((IDX + 16) > SIZE)) {\n\t\tBUFFER = random(SIZE);\n\t\tIDX = 0;\n\t}\n\n\tvar i=0, tmp, out='';\n\tfor (; i < 16; i++) {\n\t\ttmp = BUFFER[IDX + i];\n\t\tif (i==6) out += HEX[tmp & 15 | 64];\n\t\telse if (i==8) out += HEX[tmp & 63 | 128];\n\t\telse out += HEX[tmp];\n\n\t\tif (i & 1 && i > 1 && i < 11) out += '-';\n\t}\n\n\tIDX += 16;\n\treturn out;\n}\n\nexports.v4 = v4;", "export {};\n//# sourceMappingURL=interface.js.map", "export {};\n//# sourceMappingURL=index.js.map", "export {};\n//# sourceMappingURL=interfaces.js.map", "export function dset(obj, keys, val) {\n\tkeys.split && (keys=keys.split('.'));\n\tvar i=0, l=keys.length, t=obj, x, k;\n\twhile (i < l) {\n\t\tk = keys[i++];\n\t\tif (k === '__proto__' || k === 'constructor' || k === 'prototype') break;\n\t\tt = t[k] = (i === l) ? val : (typeof(x=t[k])===typeof(keys)) ? x : (keys[i]*0 !== 0 || !!~(''+keys[i]).indexOf('.')) ? {} : [];\n\t}\n}\n", "export const pickBy = <T extends object, K extends keyof T>(\n  obj: T,\n  fn: (key: K, v: T[K]) => boolean\n) => {\n  return (Object.keys(obj) as K[])\n    .filter((k) => fn(k, obj[k]))\n    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {} as Partial<T>)\n}\n", "export class ValidationError extends Error {\n  field: string\n\n  constructor(field: string, message: string) {\n    super(`${field} ${message}`)\n    this.field = field\n  }\n}\n", "export function isString(obj: unknown): obj is string {\n  return typeof obj === 'string'\n}\n\nexport function isNumber(obj: unknown): obj is number {\n  return typeof obj === 'number'\n}\n\nexport function isFunction(obj: unknown): obj is Function {\n  return typeof obj === 'function'\n}\n\nexport function exists<T>(val: unknown): val is NonNullable<T> {\n  return val !== undefined && val !== null\n}\n\nexport function isPlainObject(\n  obj: unknown\n): obj is Record<string | symbol | number, unknown> {\n  return (\n    Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() === 'object'\n  )\n}\n", "import { CoreSegmentEvent } from '../events'\nimport { ValidationError } from './errors'\nimport { isString, isPlainObject, exists } from './helpers'\n\nconst stringError = 'is not a string'\nconst objError = 'is not an object'\nconst nilError = 'is nil'\n\n// user identity check could hypothetically could be used in the browser event factory, but not 100% sure -- so this is node only for now\nexport function assertUserIdentity(event: CoreSegmentEvent): void {\n  const USER_FIELD_NAME = '.userId/anonymousId/previousId/groupId'\n\n  const getAnyUserId = (event: CoreSegmentEvent) =>\n    event.userId ?? event.anonymousId ?? event.groupId ?? event.previousId\n\n  const id = getAnyUserId(event)\n  if (!exists(id)) {\n    throw new ValidationError(USER_FIELD_NAME, nilError)\n  } else if (!isString(id)) {\n    throw new ValidationError(USER_FIELD_NAME, stringError)\n  }\n}\n\nexport function assertEventExists(\n  event?: CoreSegmentEvent | null\n): asserts event is CoreSegmentEvent {\n  if (!exists(event)) {\n    throw new ValidationError('Event', nilError)\n  }\n  if (typeof event !== 'object') {\n    throw new ValidationError('Event', objError)\n  }\n}\n\nexport function assertEventType(event: CoreSegmentEvent): void {\n  if (!isString(event.type)) {\n    throw new ValidationError('.type', stringError)\n  }\n}\n\nexport function assertTrackEventName(event: CoreSegmentEvent): void {\n  if (!isString(event.event)) {\n    throw new ValidationError('.event', stringError)\n  }\n}\n\nexport function assertTrackEventProperties(event: CoreSegmentEvent): void {\n  if (!isPlainObject(event.properties)) {\n    throw new ValidationError('.properties', objError)\n  }\n}\n\nexport function assertTraits(event: CoreSegmentEvent): void {\n  if (!isPlainObject(event.traits)) {\n    throw new ValidationError('.traits', objError)\n  }\n}\n\nexport function assertMessageId(event: CoreSegmentEvent): void {\n  if (!isString(event.messageId)) {\n    throw new ValidationError('.messageId', stringError)\n  }\n}\n\nexport function validateEvent(event?: CoreSegmentEvent | null) {\n  assertEventExists(event)\n  assertEventType(event)\n  assertMessageId(event)\n\n  if (event.type === 'track') {\n    assertTrackEventName(event)\n    assertTrackEventProperties(event)\n  }\n\n  if (['group', 'identify'].includes(event.type)) {\n    assertTraits(event)\n  }\n}\n", "export * from './interfaces'\nimport { dset } from 'dset'\nimport { ID } from '../user'\nimport {\n  Integrations,\n  EventProperties,\n  CoreSegmentEvent,\n  CoreOptions,\n  CoreExtraContext,\n  UserTraits,\n  GroupTraits,\n} from './interfaces'\nimport { pickBy } from '../utils/pick'\nimport type { RemoveIndexSignature } from '../utils/ts-helpers'\nimport { validateEvent } from '../validation/assertions'\n\nexport type EventMethodCallHook = ({\n  type,\n  options,\n}: {\n  type: 'track' | 'identify' | 'page' | 'group' | 'alias' | 'screen'\n  options?: CoreOptions\n}) => void\n\nexport type EventHook = (event: CoreSegmentEvent) => void\n\nexport interface EventFactorySettings {\n  /**\n   * Universal `messageId` builder for all events (these must be unique)\n   */\n  createMessageId: () => string\n  /**\n   * Hook to do something with an event right before they are returned from the factory.\n   * This includes event modification or additional validation.\n   */\n  onFinishedEvent?: EventHook\n  /**\n   * Hook whenever an event method is called (track, page, etc.)\n   * Can be used to update Options (or just listen)\n   */\n  onEventMethodCall?: EventMethodCallHook\n}\n\n/**\n * Internal settings object that is used internally by the factory\n */\nclass InternalEventFactorySettings {\n  public createMessageId: EventFactorySettings['createMessageId']\n  public onEventMethodCall: EventMethodCallHook\n  public onFinishedEvent: EventHook\n\n  constructor(public settings: EventFactorySettings) {\n    this.createMessageId = settings.createMessageId\n    this.onEventMethodCall = settings.onEventMethodCall ?? (() => {})\n    this.onFinishedEvent = settings.onFinishedEvent ?? (() => {})\n  }\n}\n\nexport abstract class CoreEventFactory {\n  private settings: InternalEventFactorySettings\n\n  constructor(settings: EventFactorySettings) {\n    this.settings = new InternalEventFactorySettings(settings)\n  }\n\n  track(\n    event: string,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ) {\n    this.settings.onEventMethodCall({ type: 'track', options })\n    return this.normalize({\n      ...this.baseEvent(),\n      event,\n      type: 'track',\n      properties: properties ?? {}, // TODO: why is this not a shallow copy like everywhere else?\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    })\n  }\n\n  page(\n    category: string | null,\n    page: string | null,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    this.settings.onEventMethodCall({ type: 'page', options })\n    const event: CoreSegmentEvent = {\n      type: 'page',\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n      event.properties = event.properties ?? {}\n      event.properties.category = category\n    }\n\n    if (page !== null) {\n      event.name = page\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    })\n  }\n\n  screen(\n    category: string | null,\n    screen: string | null,\n    properties?: EventProperties,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    this.settings.onEventMethodCall({ type: 'screen', options })\n    const event: CoreSegmentEvent = {\n      type: 'screen',\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n    }\n\n    if (screen !== null) {\n      event.name = screen\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    })\n  }\n\n  identify(\n    userId: ID,\n    traits?: UserTraits,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    this.settings.onEventMethodCall({ type: 'identify', options })\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'identify',\n      userId,\n      traits: traits ?? {},\n      options: { ...options },\n      integrations: globalIntegrations,\n    })\n  }\n\n  group(\n    groupId: ID,\n    traits?: GroupTraits,\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    this.settings.onEventMethodCall({ type: 'group', options })\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'group',\n      traits: traits ?? {},\n      options: { ...options }, // this spreading is intentional\n      integrations: { ...globalIntegrations }, //\n      groupId,\n    })\n  }\n\n  alias(\n    to: string,\n    from: string | null, // TODO: can we make this undefined?\n    options?: CoreOptions,\n    globalIntegrations?: Integrations\n  ): CoreSegmentEvent {\n    this.settings.onEventMethodCall({ type: 'alias', options })\n    const base: CoreSegmentEvent = {\n      userId: to,\n      type: 'alias',\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (from !== null) {\n      base.previousId = from\n    }\n\n    if (to === undefined) {\n      return this.normalize({\n        ...base,\n        ...this.baseEvent(),\n      })\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...base,\n    })\n  }\n\n  private baseEvent(): Partial<CoreSegmentEvent> {\n    return {\n      integrations: {},\n      options: {},\n    }\n  }\n\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n  private context(\n    options: CoreOptions\n  ): [CoreExtraContext, Partial<CoreSegmentEvent>] {\n    type CoreOptionKeys = keyof RemoveIndexSignature<CoreOptions>\n    /**\n     * If the event options are known keys from this list, we move them to the top level of the event.\n     * Any other options are moved to context.\n     */\n    const eventOverrideKeys: CoreOptionKeys[] = [\n      'userId',\n      'anonymousId',\n      'timestamp',\n      'messageId',\n    ]\n\n    delete options['integrations']\n    const providedOptionsKeys = Object.keys(options) as Exclude<\n      CoreOptionKeys,\n      'integrations'\n    >[]\n\n    const context = options.context ?? {}\n    const eventOverrides = {}\n\n    providedOptionsKeys.forEach((key) => {\n      if (key === 'context') {\n        return\n      }\n\n      if (eventOverrideKeys.includes(key)) {\n        dset(eventOverrides, key, options[key])\n      } else {\n        dset(context, key, options[key])\n      }\n    })\n\n    return [context, eventOverrides]\n  }\n\n  private normalize(event: CoreSegmentEvent): CoreSegmentEvent {\n    const integrationBooleans = Object.keys(event.integrations ?? {}).reduce(\n      (integrationNames, name) => {\n        return {\n          ...integrationNames,\n          [name]: Boolean(event.integrations?.[name]),\n        }\n      },\n      {} as Record<string, boolean>\n    )\n\n    // filter out any undefined options\n    event.options = pickBy(event.options || {}, (_, value) => {\n      return value !== undefined\n    })\n\n    // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n    const allIntegrations = {\n      // Base config integrations object as booleans\n      ...integrationBooleans,\n\n      // Per event overrides, for things like amplitude sessionId, for example\n      ...event.options?.integrations,\n    }\n\n    const [context, overrides] = event.options\n      ? this.context(event.options)\n      : []\n\n    const { options, ...rest } = event\n\n    const evt: CoreSegmentEvent = {\n      timestamp: new Date(),\n      ...rest,\n      context,\n      integrations: allIntegrations,\n      ...overrides,\n      messageId: options.messageId || this.settings.createMessageId(),\n    }\n\n    this.settings.onFinishedEvent(evt)\n    validateEvent(evt)\n\n    return evt\n  }\n}\n", "import { CoreContext } from '../context'\nimport type { Callback } from '../events'\n\nexport function pTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(Error('Promise timed out'))\n    }, timeout)\n\n    promise\n      .then((val) => {\n        clearTimeout(timeoutId)\n        return resolve(val)\n      })\n      .catch(reject)\n  })\n}\n\nexport function sleep(timeoutInMs: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, timeoutInMs))\n}\n\n/**\n * @param ctx\n * @param callback - the function to invoke\n * @param delay - aka \"timeout\". The amount of time in ms to wait before invoking the callback.\n */\nexport function invokeCallback<Ctx extends CoreContext>(\n  ctx: Ctx,\n  callback: Callback<Ctx>,\n  delay: number\n): Promise<Ctx> {\n  const cb = () => {\n    try {\n      return Promise.resolve(callback(ctx))\n    } catch (err) {\n      return Promise.reject(err)\n    }\n  }\n\n  return (\n    sleep(delay)\n      // pTimeout ensures that the callback can't cause the context to hang\n      .then(() => pTimeout(cb(), 1000))\n      .catch((err) => {\n        ctx?.log('warn', 'Callback Error', { error: err })\n        ctx?.stats.increment('callback_error')\n      })\n      .then(() => ctx)\n  )\n}\n", "/**\n * Return a promise that can be externally resolved\n */\nexport const createDeferred = <T>() => {\n  let resolve!: (value: T | PromiseLike<T>) => void\n  let reject!: (reason: any) => void\n  let settled = false\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = (...args) => {\n      settled = true\n      _resolve(...args)\n    }\n    reject = (...args) => {\n      settled = true\n      _reject(...args)\n    }\n  })\n\n  return {\n    resolve,\n    reject,\n    promise,\n    isSettled: () => settled,\n  }\n}\n", "export * from './create-deferred'\n", "type EventName = string\ntype EventFnArgs = any[]\ntype EmitterContract = Record<EventName, EventFnArgs>\n\nexport interface EmitterOptions {\n  /** How many event listeners for a particular event before emitting a warning (0 = disabled)\n   *  @default 10\n   **/\n  maxListeners?: number\n}\n\n/**\n * Event Emitter that takes the expected contract as a generic\n * @example\n * ```ts\n *  type Contract = {\n *    delivery_success: [DeliverySuccessResponse, Metrics],\n *    delivery_failure: [DeliveryError]\n * }\n *  new Emitter<Contract>()\n *  .on('delivery_success', (res, metrics) => ...)\n *  .on('delivery_failure', (err) => ...)\n * ```\n */\nexport class Emitter<Contract extends EmitterContract = EmitterContract> {\n  maxListeners: number\n  constructor(options?: EmitterOptions) {\n    this.maxListeners = options?.maxListeners ?? 10\n  }\n  private callbacks: Partial<Contract> = {}\n  private warned = false\n\n  private warnIfPossibleMemoryLeak<EventName extends keyof Contract>(\n    event: EventName\n  ) {\n    if (this.warned) {\n      return\n    }\n    if (\n      this.maxListeners &&\n      this.callbacks[event]!.length > this.maxListeners\n    ) {\n      console.warn(\n        `Event Emitter: Possible memory leak detected; ${String(\n          event\n        )} has exceeded ${this.maxListeners} listeners.`\n      )\n      this.warned = true\n    }\n  }\n\n  on<EventName extends keyof Contract>(\n    event: EventName,\n    callback: (...args: Contract[EventName]) => void\n  ): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [callback] as Contract[EventName]\n    } else {\n      this.callbacks[event]!.push(callback)\n      this.warnIfPossibleMemoryLeak(event)\n    }\n    return this\n  }\n\n  once<EventName extends keyof Contract>(\n    event: EventName,\n    callback: (...args: Contract[EventName]) => void\n  ): this {\n    const on = (...args: Contract[EventName]): void => {\n      this.off(event, on)\n      callback.apply(this, args)\n    }\n\n    this.on(event, on)\n    return this\n  }\n\n  off<EventName extends keyof Contract>(\n    event: EventName,\n    callback: (...args: Contract[EventName]) => void\n  ): this {\n    const fns = this.callbacks[event] ?? []\n    const without = fns.filter((fn) => fn !== callback) as Contract[EventName]\n    this.callbacks[event] = without\n    return this\n  }\n\n  emit<EventName extends keyof Contract>(\n    event: EventName,\n    ...args: Contract[EventName]\n  ): this {\n    const callbacks = this.callbacks[event] ?? []\n    callbacks.forEach((callback) => {\n      callback.apply(this, args)\n    })\n    return this\n  }\n}\n", "export * from './emitter'\n", "export * from './create-deferred'\nexport * from './emitter'\n", "type BackoffParams = {\n  /** The number of milliseconds before starting the first retry. Default is 500 */\n  minTimeout?: number\n\n  /** The maximum number of milliseconds between two retries. Default is Infinity */\n  maxTimeout?: number\n\n  /** The exponential factor to use. Default is 2. */\n  factor?: number\n\n  /** The current attempt */\n  attempt: number\n}\n\nexport function backoff(params: BackoffParams): number {\n  const random = Math.random() + 1\n  const {\n    minTimeout = 500,\n    factor = 2,\n    attempt,\n    maxTimeout = Infinity,\n  } = params\n  return Math.min(random * minTimeout * Math.pow(factor, attempt), maxTimeout)\n}\n", "import { Emitter } from '@segment/analytics-generic-utils'\nimport { backoff } from './backoff'\n\n/**\n * @internal\n */\nexport const ON_REMOVE_FROM_FUTURE = 'onRemoveFromFuture'\n\ninterface QueueItem {\n  id: string\n}\n\nexport class PriorityQueue<Item extends QueueItem = QueueItem> extends Emitter {\n  protected future: Item[] = []\n  protected queue: Item[]\n  protected seen: Record<string, number>\n\n  public maxAttempts: number\n\n  constructor(\n    maxAttempts: number,\n    queue: Item[],\n    seen?: Record<string, number>\n  ) {\n    super()\n    this.maxAttempts = maxAttempts\n    this.queue = queue\n    this.seen = seen ?? {}\n  }\n\n  push(...items: Item[]): boolean[] {\n    const accepted = items.map((operation) => {\n      const attempts = this.updateAttempts(operation)\n\n      if (attempts > this.maxAttempts || this.includes(operation)) {\n        return false\n      }\n\n      this.queue.push(operation)\n      return true\n    })\n\n    this.queue = this.queue.sort(\n      (a, b) => this.getAttempts(a) - this.getAttempts(b)\n    )\n    return accepted\n  }\n\n  pushWithBackoff(item: Item): boolean {\n    if (this.getAttempts(item) === 0) {\n      return this.push(item)[0]\n    }\n\n    const attempt = this.updateAttempts(item)\n\n    if (attempt > this.maxAttempts || this.includes(item)) {\n      return false\n    }\n\n    const timeout = backoff({ attempt: attempt - 1 })\n\n    setTimeout(() => {\n      this.queue.push(item)\n      // remove from future list\n      this.future = this.future.filter((f) => f.id !== item.id)\n      // Lets listeners know that a 'future' message is now available in the queue\n      this.emit(ON_REMOVE_FROM_FUTURE)\n    }, timeout)\n\n    this.future.push(item)\n    return true\n  }\n\n  public getAttempts(item: Item): number {\n    return this.seen[item.id] ?? 0\n  }\n\n  public updateAttempts(item: Item): number {\n    this.seen[item.id] = this.getAttempts(item) + 1\n    return this.getAttempts(item)\n  }\n\n  includes(item: Item): boolean {\n    return (\n      this.queue.includes(item) ||\n      this.future.includes(item) ||\n      Boolean(this.queue.find((i) => i.id === item.id)) ||\n      Boolean(this.future.find((i) => i.id === item.id))\n    )\n  }\n\n  pop(): Item | undefined {\n    return this.queue.shift()\n  }\n\n  public get length(): number {\n    return this.queue.length\n  }\n\n  public get todo(): number {\n    return this.queue.length + this.future.length\n  }\n}\n", "var IDX=256, HEX=[], BUFFER;\nwhile (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);\n\nexport function v4() {\n\tvar i=0, num, out='';\n\n\tif (!BUFFER || ((IDX + 16) > 256)) {\n\t\tBUFFER = Array(i=256);\n\t\twhile (i--) BUFFER[i] = 256 * Math.random() | 0;\n\t\ti = IDX = 0;\n\t}\n\n\tfor (; i < 16; i++) {\n\t\tnum = BUFFER[IDX + i];\n\t\tif (i==6) out += HEX[num & 15 | 64];\n\t\telse if (i==8) out += HEX[num & 63 | 128];\n\t\telse out += HEX[num];\n\n\t\tif (i & 1 && i > 1 && i < 11) out += '-';\n\t}\n\n\tIDX++;\n\treturn out;\n}\n", "export type LogLevel = 'debug' | 'info' | 'warn' | 'error'\nexport type LogMessage = {\n  level: LogLevel\n  message: string\n  time?: Date\n  extras?: Record<string, any>\n}\n\nexport interface GenericLogger {\n  log(level: LogLevel, message: string, extras?: object): void\n  flush(): void\n  logs: LogMessage[]\n}\n\nexport class CoreLogger implements GenericLogger {\n  private _logs: LogMessage[] = []\n\n  log(level: LogLevel, message: string, extras?: object) {\n    const time = new Date()\n    this._logs.push({\n      level,\n      message,\n      time,\n      extras,\n    })\n  }\n\n  public get logs(): LogMessage[] {\n    return this._logs\n  }\n\n  public flush(): void {\n    if (this.logs.length > 1) {\n      const formatted = this._logs.reduce((logs, log) => {\n        const line = {\n          ...log,\n          json: JSON.stringify(log.extras, null, ' '),\n          extras: log.extras,\n        }\n\n        delete line['time']\n\n        let key = log.time?.toISOString() ?? ''\n        if (logs[key]) {\n          key = `${key}-${Math.random()}`\n        }\n\n        return {\n          ...logs,\n          [key]: line,\n        }\n      }, {} as Record<string, LogMessage>)\n\n      // ie doesn't like console.table\n      if (console.table) {\n        console.table(formatted)\n      } else {\n        console.log(formatted)\n      }\n    } else {\n      this.logs.forEach((logEntry) => {\n        const { level, message, extras } = logEntry\n\n        if (level === 'info' || level === 'debug') {\n          console.log(message, extras ?? '')\n        } else {\n          console[level](message, extras ?? '')\n        }\n      })\n    }\n\n    this._logs = []\n  }\n}\n", "type CompactMetricType = 'g' | 'c'\n\nexport type CoreMetricType = 'gauge' | 'counter'\n\nexport interface CoreMetric {\n  metric: string\n  value: number\n  type: CoreMetricType\n  tags: string[]\n  timestamp: number // unit milliseconds\n}\n\nexport interface CompactMetric {\n  m: string // metric name\n  v: number // value\n  k: CompactMetricType\n  t: string[] // tags\n  e: number // timestamp in unit milliseconds\n}\n\nconst compactMetricType = (type: CoreMetricType): CompactMetricType => {\n  const enums: Record<CoreMetricType, CompactMetricType> = {\n    gauge: 'g',\n    counter: 'c',\n  }\n  return enums[type]\n}\n\nexport abstract class CoreStats {\n  metrics: CoreMetric[] = []\n  increment(metric: string, by = 1, tags?: string[]): void {\n    this.metrics.push({\n      metric,\n      value: by,\n      tags: tags ?? [],\n      type: 'counter',\n      timestamp: Date.now(),\n    })\n  }\n\n  gauge(metric: string, value: number, tags?: string[]): void {\n    this.metrics.push({\n      metric,\n      value,\n      tags: tags ?? [],\n      type: 'gauge',\n      timestamp: Date.now(),\n    })\n  }\n\n  flush(): void {\n    const formatted = this.metrics.map((m) => ({\n      ...m,\n      tags: m.tags.join(','),\n    }))\n    // ie doesn't like console.table\n    if (console.table) {\n      console.table(formatted)\n    } else {\n      console.log(formatted)\n    }\n    this.metrics = []\n  }\n\n  /**\n   * compact keys for smaller payload\n   */\n  serialize(): CompactMetric[] {\n    return this.metrics.map((m) => {\n      return {\n        m: m.metric,\n        v: m.value,\n        t: m.tags,\n        k: compactMetricType(m.type),\n        e: m.timestamp,\n      }\n    })\n  }\n}\n\nexport class NullStats extends CoreStats {\n  override gauge(..._args: Parameters<CoreStats['gauge']>) {}\n  override increment(..._args: Parameters<CoreStats['increment']>) {}\n  override flush(..._args: Parameters<CoreStats['flush']>) {}\n  override serialize(..._args: Parameters<CoreStats['serialize']>) {\n    return []\n  }\n}\n", "import { CoreSegmentEvent } from '../events/interfaces'\n\nimport { v4 as uuid } from '@lukeed/uuid'\nimport { dset } from 'dset'\nimport { CoreLogger, LogLevel, LogMessage } from '../logger'\nimport { CoreStats, CoreMetric, NullStats } from '../stats'\n\nexport interface SerializedContext {\n  id: string\n  event: CoreSegmentEvent\n  logs: LogMessage[]\n  metrics?: CoreMetric[]\n}\n\nexport interface ContextFailedDelivery {\n  reason: unknown\n}\n\nexport interface CancelationOptions {\n  retry?: boolean\n  reason?: string\n  type?: string\n}\n\nexport class ContextCancelation {\n  retry: boolean\n  type: string\n  reason?: string\n\n  constructor(options: CancelationOptions) {\n    this.retry = options.retry ?? true\n    this.type = options.type ?? 'plugin Error'\n    this.reason = options.reason ?? ''\n  }\n}\n\nexport abstract class CoreContext<\n  Event extends CoreSegmentEvent = CoreSegmentEvent\n> {\n  event: Event\n  logger: CoreLogger\n  stats: CoreStats\n  attempts = 0\n\n  private _failedDelivery?: ContextFailedDelivery\n  private _id: string\n\n  constructor(\n    event: Event,\n    id = uuid(),\n    stats: CoreStats = new NullStats(),\n    logger = new CoreLogger()\n  ) {\n    this.event = event\n    this._id = id\n    this.logger = logger\n    this.stats = stats\n  }\n\n  static system(): void {\n    // This should be overridden by the subclass to return an instance of the subclass.\n  }\n\n  isSame(other: CoreContext): boolean {\n    return other.id === this.id\n  }\n\n  cancel(error?: Error | ContextCancelation): never {\n    if (error) {\n      throw error\n    }\n\n    throw new ContextCancelation({ reason: 'Context Cancel' })\n  }\n\n  log(level: LogLevel, message: string, extras?: object): void {\n    this.logger.log(level, message, extras)\n  }\n\n  get id(): string {\n    return this._id\n  }\n\n  updateEvent(path: string, val: unknown): Event {\n    // Don't allow integrations that are set to false to be overwritten with integration settings.\n    if (path.split('.')[0] === 'integrations') {\n      const integrationName = path.split('.')[1]\n\n      if (this.event.integrations?.[integrationName] === false) {\n        return this.event\n      }\n    }\n\n    dset(this.event, path, val)\n    return this.event\n  }\n\n  failedDelivery(): ContextFailedDelivery | undefined {\n    return this._failedDelivery\n  }\n\n  setFailedDelivery(options: ContextFailedDelivery) {\n    this._failedDelivery = options\n  }\n\n  logs(): LogMessage[] {\n    return this.logger.logs\n  }\n\n  flush(): void {\n    this.logger.flush()\n    this.stats.flush()\n  }\n\n  toJSON(): SerializedContext {\n    return {\n      id: this._id,\n      event: this.event,\n      logs: this.logger.logs,\n      metrics: this.stats.metrics,\n    }\n  }\n}\n", "type Grouper<T> = (obj: T) => string | number\n\nexport function groupBy<T>(\n  collection: T[],\n  grouper: keyof T | Grouper<T>\n): Record<string, T[]> {\n  const results: Record<string, T[]> = {}\n\n  collection.forEach((item) => {\n    let key: string | number | undefined = undefined\n\n    if (typeof grouper === 'string') {\n      const suggestedKey = item[grouper]\n      key =\n        typeof suggestedKey !== 'string'\n          ? JSON.stringify(suggestedKey)\n          : suggestedKey\n    } else if (grouper instanceof Function) {\n      key = grouper(item)\n    }\n\n    if (key === undefined) {\n      return\n    }\n\n    results[key] = [...(results[key] ?? []), item]\n  })\n\n  return results\n}\n", "/**\n *  Check if  thenable\n *  (instanceof Promise doesn't respect realms)\n */\nexport const isThenable = (value: unknown): boolean =>\n  typeof value === 'object' &&\n  value !== null &&\n  'then' in value &&\n  typeof (value as any).then === 'function'\n", "import { isThenable } from '../utils/is-thenable'\n\nexport type TaskGroup = {\n  done: () => Promise<void>\n  run: <Operation extends (...args: any[]) => any>(\n    op: Operation\n  ) => ReturnType<Operation>\n}\n\nexport const createTaskGroup = (): TaskGroup => {\n  let taskCompletionPromise: Promise<void>\n  let resolvePromise: () => void\n  let count = 0\n\n  return {\n    done: () => taskCompletionPromise,\n    run: (op) => {\n      const returnValue = op()\n\n      if (isThenable(returnValue)) {\n        if (++count === 1) {\n          taskCompletionPromise = new Promise((res) => (resolvePromise = res))\n        }\n\n        returnValue.finally(() => --count === 0 && resolvePromise())\n      }\n\n      return returnValue\n    },\n  }\n}\n", "import { CoreContext, ContextCancelation } from '../context'\nimport { CorePlugin } from '../plugins'\n\nasync function tryAsync<T>(fn: () => T | Promise<T>): Promise<T> {\n  try {\n    return await fn()\n  } catch (err) {\n    return Promise.reject(err)\n  }\n}\n\nexport function attempt<Ctx extends CoreContext = CoreContext>(\n  ctx: Ctx,\n  plugin: CorePlugin<Ctx>\n): Promise<Ctx | ContextCancelation | Error> {\n  ctx.log('debug', 'plugin', { plugin: plugin.name })\n  const start = new Date().getTime()\n\n  const hook = plugin[ctx.event.type]\n  if (hook === undefined) {\n    return Promise.resolve(ctx)\n  }\n\n  const newCtx = tryAsync(() => hook.apply(plugin, [ctx]))\n    .then((ctx) => {\n      const done = new Date().getTime() - start\n      ctx.stats.gauge('plugin_time', done, [`plugin:${plugin.name}`])\n\n      return ctx\n    })\n    .catch((err: Error | ContextCancelation) => {\n      if (\n        err instanceof ContextCancelation &&\n        err.type === 'middleware_cancellation'\n      ) {\n        throw err\n      }\n\n      if (err instanceof ContextCancelation) {\n        ctx.log('warn', err.type, {\n          plugin: plugin.name,\n          error: err,\n        })\n\n        return err\n      }\n\n      ctx.log('error', 'plugin Error', {\n        plugin: plugin.name,\n        error: err,\n      })\n      ctx.stats.increment('plugin_error', 1, [`plugin:${plugin.name}`])\n\n      return err\n    })\n\n  return newCtx\n}\n\nexport function ensure<Ctx extends CoreContext = CoreContext>(\n  ctx: Ctx,\n  plugin: CorePlugin<Ctx>\n): Promise<Ctx | undefined> {\n  return attempt(ctx, plugin).then((newContext) => {\n    if (newContext instanceof CoreContext) {\n      return newContext\n    }\n\n    ctx.log('debug', 'Context canceled')\n    ctx.stats.increment('context_canceled')\n    ctx.cancel(newContext)\n  })\n}\n", "import { CoreAnalytics } from '../analytics'\nimport { groupBy } from '../utils/group-by'\nimport { ON_REMOVE_FROM_FUTURE, PriorityQueue } from '../priority-queue'\n\nimport { CoreContext, ContextCancelation } from '../context'\nimport { Emitter } from '@segment/analytics-generic-utils'\nimport { Integrations, JSONObject } from '../events/interfaces'\nimport { CorePlugin } from '../plugins'\nimport { createTaskGroup, TaskGroup } from '../task/task-group'\nimport { attempt, ensure } from './delivery'\n\nexport type EventQueueEmitterContract<Ctx extends CoreContext> = {\n  message_delivered: [ctx: Ctx]\n  message_enriched: [ctx: Ctx, plugin: CorePlugin<Ctx>]\n  delivery_success: [ctx: Ctx]\n  delivery_retry: [ctx: Ctx]\n  delivery_failure: [ctx: Ctx, err: Ctx | Error | ContextCancelation]\n  flush: [ctx: Ctx, delivered: boolean]\n  initialization_failure: [CorePlugin<Ctx>]\n}\n\nexport abstract class CoreEventQueue<\n  Ctx extends CoreContext = CoreContext,\n  Plugin extends CorePlugin<Ctx> = CorePlugin<Ctx>\n> extends Emitter<EventQueueEmitterContract<Ctx>> {\n  /**\n   * All event deliveries get suspended until all the tasks in this task group are complete.\n   * For example: a middleware that augments the event object should be loaded safely as a\n   * critical task, this way, event queue will wait for it to be ready before sending events.\n   *\n   * This applies to all the events already in the queue, and the upcoming ones\n   */\n  criticalTasks: TaskGroup = createTaskGroup()\n  queue: PriorityQueue<Ctx>\n  plugins: Plugin[] = []\n  failedInitializations: string[] = []\n  private flushing = false\n\n  constructor(priorityQueue: PriorityQueue<Ctx>) {\n    super()\n\n    this.queue = priorityQueue\n    this.queue.on(ON_REMOVE_FROM_FUTURE, () => {\n      this.scheduleFlush(0)\n    })\n  }\n\n  async register(\n    ctx: Ctx,\n    plugin: Plugin,\n    instance: CoreAnalytics\n  ): Promise<void> {\n    this.plugins.push(plugin)\n\n    const handleLoadError = (err: any) => {\n      this.failedInitializations.push(plugin.name)\n      this.emit('initialization_failure', plugin)\n      console.warn(plugin.name, err)\n\n      ctx.log('warn', 'Failed to load destination', {\n        plugin: plugin.name,\n        error: err,\n      })\n\n      // Filter out the failed plugin by excluding it from the list\n      this.plugins = this.plugins.filter((p) => p !== plugin)\n    }\n\n    if (plugin.type === 'destination' && plugin.name !== 'Segment.io') {\n      plugin.load(ctx, instance).catch(handleLoadError)\n    } else {\n      // for non-destinations plugins, we do need to wait for them to load\n      // reminder: action destinations can require plugins that are not of type \"destination\".\n      // For example, GA4 loads a type 'before' plugins and addition to a type 'destination' plugin\n      try {\n        await plugin.load(ctx, instance)\n      } catch (err) {\n        handleLoadError(err)\n      }\n    }\n  }\n\n  async deregister(\n    ctx: Ctx,\n    plugin: CorePlugin<Ctx>,\n    instance: CoreAnalytics\n  ): Promise<void> {\n    try {\n      if (plugin.unload) {\n        await Promise.resolve(plugin.unload(ctx, instance))\n      }\n\n      this.plugins = this.plugins.filter((p) => p.name !== plugin.name)\n    } catch (e) {\n      ctx.log('warn', 'Failed to unload destination', {\n        plugin: plugin.name,\n        error: e,\n      })\n    }\n  }\n\n  async dispatch(ctx: Ctx): Promise<Ctx> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.push(ctx)\n    const willDeliver = this.subscribeToDelivery(ctx)\n    this.scheduleFlush(0)\n    return willDeliver\n  }\n\n  private async subscribeToDelivery(ctx: Ctx): Promise<Ctx> {\n    return new Promise((resolve) => {\n      const onDeliver = (flushed: Ctx, delivered: boolean): void => {\n        if (flushed.isSame(ctx)) {\n          this.off('flush', onDeliver)\n          if (delivered) {\n            resolve(flushed)\n          } else {\n            resolve(flushed)\n          }\n        }\n      }\n\n      this.on('flush', onDeliver)\n    })\n  }\n\n  async dispatchSingle(ctx: Ctx): Promise<Ctx> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.updateAttempts(ctx)\n    ctx.attempts = 1\n\n    return this.deliver(ctx).catch((err) => {\n      const accepted = this.enqueuRetry(err, ctx)\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        return ctx\n      }\n\n      return this.subscribeToDelivery(ctx)\n    })\n  }\n\n  isEmpty(): boolean {\n    return this.queue.length === 0\n  }\n\n  private scheduleFlush(timeout = 500): void {\n    if (this.flushing) {\n      return\n    }\n\n    this.flushing = true\n\n    setTimeout(() => {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.flush().then(() => {\n        setTimeout(() => {\n          this.flushing = false\n\n          if (this.queue.length) {\n            this.scheduleFlush(0)\n          }\n        }, 0)\n      })\n    }, timeout)\n  }\n\n  private async deliver(ctx: Ctx): Promise<Ctx> {\n    await this.criticalTasks.done()\n\n    const start = Date.now()\n    try {\n      ctx = await this.flushOne(ctx)\n      const done = Date.now() - start\n      this.emit('delivery_success', ctx)\n      ctx.stats.gauge('delivered', done)\n      ctx.log('debug', 'Delivered', ctx.event)\n      return ctx\n    } catch (err: any) {\n      const error = err as Ctx | Error | ContextCancelation\n      ctx.log('error', 'Failed to deliver', error)\n      this.emit('delivery_failure', ctx, error)\n      ctx.stats.increment('delivery_failed')\n      throw err\n    }\n  }\n\n  private enqueuRetry(err: Error, ctx: Ctx): boolean {\n    const retriable = !(err instanceof ContextCancelation) || err.retry\n    if (!retriable) {\n      return false\n    }\n\n    return this.queue.pushWithBackoff(ctx)\n  }\n\n  async flush(): Promise<Ctx[]> {\n    if (this.queue.length === 0) {\n      return []\n    }\n\n    let ctx = this.queue.pop()\n    if (!ctx) {\n      return []\n    }\n\n    ctx.attempts = this.queue.getAttempts(ctx)\n\n    try {\n      ctx = await this.deliver(ctx)\n      this.emit('flush', ctx, true)\n    } catch (err: any) {\n      const accepted = this.enqueuRetry(err, ctx)\n\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        this.emit('flush', ctx, false)\n      }\n\n      return []\n    }\n\n    return [ctx]\n  }\n\n  private isReady(): boolean {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true\n  }\n\n  private availableExtensions(denyList: Integrations) {\n    const available = this.plugins.filter((p) => {\n      // Only filter out destination plugins or the Segment.io plugin\n      if (p.type !== 'destination' && p.name !== 'Segment.io') {\n        return true\n      }\n\n      let alternativeNameMatch: boolean | JSONObject | undefined = undefined\n      p.alternativeNames?.forEach((name) => {\n        if (denyList[name] !== undefined) {\n          alternativeNameMatch = denyList[name]\n        }\n      })\n\n      // Explicit integration option takes precedence, `All: false` does not apply to Segment.io\n      return (\n        denyList[p.name] ??\n        alternativeNameMatch ??\n        (p.name === 'Segment.io' ? true : denyList.All) !== false\n      )\n    })\n\n    const {\n      before = [],\n      enrichment = [],\n      destination = [],\n      after = [],\n    } = groupBy(available, 'type')\n\n    return {\n      before,\n      enrichment,\n      destinations: destination,\n      after,\n    }\n  }\n\n  private async flushOne(ctx: Ctx): Promise<Ctx> {\n    if (!this.isReady()) {\n      throw new Error('Not ready')\n    }\n\n    if (ctx.attempts > 1) {\n      this.emit('delivery_retry', ctx)\n    }\n\n    const { before, enrichment } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    for (const beforeWare of before) {\n      const temp = await ensure(ctx, beforeWare)\n      if (temp instanceof CoreContext) {\n        ctx = temp\n      }\n\n      this.emit('message_enriched', ctx, beforeWare)\n    }\n\n    for (const enrichmentWare of enrichment) {\n      const temp = await attempt(ctx, enrichmentWare)\n      if (temp instanceof CoreContext) {\n        ctx = temp\n      }\n\n      this.emit('message_enriched', ctx, enrichmentWare)\n    }\n\n    // Enrichment and before plugins can re-arrange the deny list dynamically\n    // so we need to pluck them at the end\n    const { destinations, after } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const attempts = destinations.map((destination) =>\n          attempt(ctx, destination)\n        )\n        Promise.all(attempts).then(resolve).catch(reject)\n      }, 0)\n    })\n\n    ctx.stats.increment('message_delivered')\n\n    this.emit('message_delivered', ctx)\n\n    const afterCalls = after.map((after) => attempt(ctx, after))\n    await Promise.all(afterCalls)\n\n    return ctx\n  }\n}\n", "export {};\n//# sourceMappingURL=index.js.map", "import { CoreContext } from '../context'\nimport { Callback } from '../events/interfaces'\nimport { CoreEventQueue } from '../queue/event-queue'\nimport { invokeCallback } from '../callback'\nimport { Emitter } from '@segment/analytics-generic-utils'\n\nexport type DispatchOptions<Ctx extends CoreContext = CoreContext> = {\n  timeout?: number\n  debug?: boolean\n  callback?: Callback<Ctx>\n}\n\n/* The amount of time in ms to wait before invoking the callback. */\nexport const getDelay = (startTimeInEpochMS: number, timeoutInMS?: number) => {\n  const elapsedTime = Date.now() - startTimeInEpochMS\n  // increasing the timeout increases the delay by almost the same amount -- this is weird legacy behavior.\n  return Math.max((timeoutInMS ?? 300) - elapsedTime, 0)\n}\n/**\n * Push an event into the dispatch queue and invoke any callbacks.\n *\n * @param event - Segment event to enqueue.\n * @param queue - Queue to dispatch against.\n * @param emitter - This is typically an instance of \"Analytics\" -- used for metrics / progress information.\n * @param options\n */\nexport async function dispatch<\n  Ctx extends CoreContext,\n  EQ extends CoreEventQueue<Ctx>\n>(\n  ctx: Ctx,\n  queue: EQ,\n  emitter: Emitter,\n  options?: DispatchOptions<Ctx>\n): Promise<Ctx> {\n  emitter.emit('dispatch_start', ctx)\n\n  const startTime = Date.now()\n  let dispatched: Ctx\n  if (queue.isEmpty()) {\n    dispatched = await queue.dispatchSingle(ctx)\n  } else {\n    dispatched = await queue.dispatch(ctx)\n  }\n\n  if (options?.callback) {\n    dispatched = await invokeCallback(\n      dispatched,\n      options.callback,\n      getDelay(startTime, options.timeout)\n    )\n  }\n  if (options?.debug) {\n    dispatched.flush()\n  }\n\n  return dispatched\n}\n", "export function bindAll<\n  ObjType extends { [key: string]: any },\n  KeyType extends keyof ObjType\n>(obj: ObjType): ObjType {\n  const proto = obj.constructor.prototype\n  for (const key of Object.getOwnPropertyNames(proto)) {\n    if (key !== 'constructor') {\n      const desc = Object.getOwnPropertyDescriptor(\n        obj.constructor.prototype,\n        key\n      )\n      if (!!desc && typeof desc.value === 'function') {\n        obj[key as KeyType] = obj[key].bind(obj)\n      }\n    }\n  }\n\n  return obj\n}\n", "export * from './emitter/interface'\nexport * from './plugins'\nexport * from './events/interfaces'\nexport * from './events'\nexport * from './callback'\nexport * from './priority-queue'\nexport { backoff } from './priority-queue/backoff'\nexport * from './context'\nexport * from './queue/event-queue'\nexport * from './analytics'\nexport * from './analytics/dispatch'\nexport * from './validation/helpers'\nexport * from './validation/errors'\nexport * from './validation/assertions'\nexport * from './utils/bind-all'\nexport * from './stats'\nexport { CoreLogger } from './logger'\nexport * from './queue/delivery'\n", "import { ValidationError } from '@segment/analytics-core'\nimport { HTTPClient, HTTPFetchFn } from '../lib/http-client'\nimport { OAuthSettings } from '../lib/types'\n\nexport interface AnalyticsSettings {\n  /**\n   * Key that corresponds to your Segment.io project\n   */\n  writeKey: string\n  /**\n   * The base URL of the API. Default: \"https://api.segment.io\"\n   */\n  host?: string\n  /**\n   * The API path route. Default: \"/v1/batch\"\n   */\n  path?: string\n  /**\n   * The number of times to retry flushing a batch. Default: 3\n   */\n  maxRetries?: number\n  /**\n   * The number of events to enqueue before flushing. Default: 15.\n   */\n  flushAt?: number\n  /**\n   * @deprecated\n   * The number of events to enqueue before flushing. This is deprecated in favor of `flushAt`. Default: 15.\n   */\n  maxEventsInBatch?: number\n  /**\n   * The number of milliseconds to wait before flushing the queue automatically. Default: 10000\n   */\n  flushInterval?: number\n  /**\n   * The maximum number of milliseconds to wait for an http request. Default: 10000\n   */\n  httpRequestTimeout?: number\n  /**\n   * Disable the analytics library. All calls will be a noop. Default: false.\n   */\n  disable?: boolean\n  /**\n   * Supply a default http client implementation (such as one supporting proxy).\n   * Accepts either an HTTPClient instance or a fetch function.\n   * Default: an HTTP client that uses globalThis.fetch, with node-fetch as a fallback.\n   */\n  httpClient?: HTTPFetchFn | HTTPClient\n  /**\n   * Set up OAuth2 authentication between the client and Segment's endpoints\n   */\n  oauthSettings?: OAuthSettings\n}\n\nexport const validateSettings = (settings: AnalyticsSettings) => {\n  if (!settings.writeKey) {\n    throw new ValidationError('writeKey', 'writeKey is missing.')\n  }\n}\n", "// This file is generated.\nexport const version = '2.1.2'\n", "const stripTrailingSlash = (str: string) => str.replace(/\\/$/, '')\n\n/**\n *\n * @param host e.g. \"http://foo.com\"\n * @param path e.g. \"/bar\"\n * @returns \"e.g.\" \"http://foo.com/bar\"\n */\nexport const tryCreateFormattedUrl = (host: string, path?: string) => {\n  return stripTrailingSlash(new URL(path || '', host).href)\n}\n", "export { v4 as uuid } from '@lukeed/uuid'\n", "import { uuid } from '../../lib/uuid'\nimport type { Context } from '../../app/context'\nimport { SegmentEvent } from '../../app/types'\n\nconst MAX_EVENT_SIZE_IN_KB = 32\nconst MAX_BATCH_SIZE_IN_KB = 480 //  (500 KB is the limit, leaving some padding)\n\ninterface PendingItem {\n  resolver: (ctx: Context) => void\n  context: Context\n}\n\nexport class ContextBatch {\n  public id = uuid()\n  private items: PendingItem[] = []\n  private sizeInBytes = 0\n  private maxEventCount: number\n\n  constructor(maxEventCount: number) {\n    this.maxEventCount = Math.max(1, maxEventCount)\n  }\n  public tryAdd(\n    item: PendingItem\n  ): { success: true } | { success: false; message: string } {\n    if (this.length === this.maxEventCount)\n      return {\n        success: false,\n        message: `Event limit of ${this.maxEventCount} has been exceeded.`,\n      }\n\n    const eventSize = this.calculateSize(item.context)\n    if (eventSize > MAX_EVENT_SIZE_IN_KB * 1024) {\n      return {\n        success: false,\n        message: `Event exceeds maximum event size of ${MAX_EVENT_SIZE_IN_KB} KB`,\n      }\n    }\n\n    if (this.sizeInBytes + eventSize > MAX_BATCH_SIZE_IN_KB * 1024) {\n      return {\n        success: false,\n        message: `Event has caused batch size to exceed ${MAX_BATCH_SIZE_IN_KB} KB`,\n      }\n    }\n\n    this.items.push(item)\n    this.sizeInBytes += eventSize\n    return { success: true }\n  }\n\n  get length(): number {\n    return this.items.length\n  }\n\n  private calculateSize(ctx: Context): number {\n    return encodeURI(JSON.stringify(ctx.event)).split(/%..|i/).length\n  }\n\n  getEvents(): SegmentEvent[] {\n    const events = this.items.map(({ context }) => context.event)\n    return events\n  }\n\n  getContexts(): Context[] {\n    return this.items.map((item) => item.context)\n  }\n\n  resolveEvents(): void {\n    this.items.forEach(({ resolver, context }) => resolver(context))\n  }\n}\n", "export default crypto;\nexport const isCryptoKey = (key) => key instanceof CryptoKey;\n", "import crypto from './webcrypto.js';\nconst digest = async (algorithm, data) => {\n    const subtleDigest = `SHA-${algorithm.slice(-3)}`;\n    return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));\n};\nexport default digest;\n", "import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n", "import { encoder, decoder } from '../lib/buffer_utils.js';\nexport const encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nexport const encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nexport const decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n", "export class JOSEError extends Error {\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n    constructor(message) {\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nexport class JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n", "import crypto from './webcrypto.js';\nexport default crypto.getRandomValues.bind(crypto);\n", "import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n", "import { JWEInvalid } from '../util/errors.js';\nimport { bitLength } from './iv.js';\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== bitLength(enc)) {\n        throw new JWEInvalid('Invalid Initialization Vector length');\n    }\n};\nexport default checkIvLength;\n", "import { JWEInvalid } from '../util/errors.js';\nconst checkCekLength = (cek, expected) => {\n    const actual = cek.byteLength << 3;\n    if (actual !== expected) {\n        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n    }\n};\nexport default checkCekLength;\n", "const timingSafeEqual = (a, b) => {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    if (a.length !== b.length) {\n        throw new TypeError('Input buffers must have the same length');\n    }\n    const len = a.length;\n    let out = 0;\n    let i = -1;\n    while (++i < len) {\n        out |= a[i] ^ b[i];\n    }\n    return out === 0;\n};\nexport default timingSafeEqual;\n", "function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n", "function message(msg, actual, ...types) {\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n", "import { isCryptoKey } from './webcrypto.js';\nexport default (key) => {\n    return isCryptoKey(key);\n};\nexport const types = ['CryptoKey'];\n", "import { concat, uint64be } from '../lib/buffer_utils.js';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport timingSafeEqual from './timing_safe_equal.js';\nimport { JOSENotSupported, JWEDecryptionFailed, JWEInvalid } from '../util/errors.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = timingSafeEqual(tag, expectedTag);\n    }\n    catch {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await crypto.subtle.decrypt({ iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'decrypt');\n        encKey = cek;\n    }\n    try {\n        return new Uint8Array(await crypto.subtle.decrypt({\n            additionalData: aad,\n            iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, concat(ciphertext, tag)));\n    }\n    catch {\n        throw new JWEDecryptionFailed();\n    }\n}\nconst decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    if (!iv) {\n        throw new JWEInvalid('JWE Initialization Vector missing');\n    }\n    if (!tag) {\n        throw new JWEInvalid('JWE Authentication Tag missing');\n    }\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default decrypt;\n", "const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n", "function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n", "const bogusWebCrypto = [\n    { hash: 'SHA-256', name: 'HMAC' },\n    true,\n    ['sign'],\n];\nexport default bogusWebCrypto;\n", "import bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nexport const wrap = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nexport const unwrap = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n};\n", "import { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    if (!isCryptoKey(publicKey)) {\n        throw new TypeError(invalidKeyInput(publicKey, ...types));\n    }\n    checkEncCryptoKey(publicKey, 'ECDH');\n    if (!isCryptoKey(privateKey)) {\n        throw new TypeError(invalidKeyInput(privateKey, ...types));\n    }\n    checkEncCryptoKey(privateKey, 'ECDH', 'deriveBits');\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    let length;\n    if (publicKey.algorithm.name === 'X25519') {\n        length = 256;\n    }\n    else if (publicKey.algorithm.name === 'X448') {\n        length = 448;\n    }\n    else {\n        length =\n            Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;\n    }\n    const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({\n        name: publicKey.algorithm.name,\n        public: publicKey,\n    }, privateKey, length));\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return crypto.subtle.generateKey(key.algorithm, true, ['deriveBits']);\n}\nexport function ecdhAllowed(key) {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    return (['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve) ||\n        key.algorithm.name === 'X25519' ||\n        key.algorithm.name === 'X448');\n}\n", "import { JWEInvalid } from '../util/errors.js';\nexport default function checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n", "import random from './random.js';\nimport { p2s as concatSalt } from '../lib/buffer_utils.js';\nimport { encode as base64url } from './base64url.js';\nimport { wrap, unwrap } from './aeskw.js';\nimport checkP2s from '../lib/check_p2s.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nfunction getCryptoKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n    }\n    if (isCryptoKey(key)) {\n        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');\n        return key;\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\nasync function deriveKey(p2s, alg, p2c, key) {\n    checkP2s(p2s);\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10);\n    const subtleAlg = {\n        hash: `SHA-${alg.slice(8, 11)}`,\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey(key, alg);\n    if (cryptoKey.usages.includes('deriveBits')) {\n        return new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    if (cryptoKey.usages.includes('deriveKey')) {\n        return crypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey', 'unwrapKey']);\n    }\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n}\nexport const encrypt = async (alg, key, cek, p2c = 2048, p2s = random(new Uint8Array(16))) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    const encryptedKey = await wrap(alg.slice(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: base64url(p2s) };\n};\nexport const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    return unwrap(alg.slice(-6), derived, encryptedKey);\n};\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function subtleRsaEs(alg) {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n", "import subtleAlgorithm from './subtle_rsaes.js';\nimport bogusWebCrypto from './bogus.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport checkKeyLength from './check_key_length.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport const encrypt = async (alg, key, cek) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    checkEncCryptoKey(key, alg, 'encrypt', 'wrapKey');\n    checkKeyLength(alg, key);\n    if (key.usages.includes('encrypt')) {\n        return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm(alg), key, cek));\n    }\n    if (key.usages.includes('wrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, key, subtleAlgorithm(alg)));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\nexport const decrypt = async (alg, key, encryptedKey) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    checkEncCryptoKey(key, alg, 'decrypt', 'unwrapKey');\n    checkKeyLength(alg, key);\n    if (key.usages.includes('decrypt')) {\n        return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm(alg), key, encryptedKey));\n    }\n    if (key.usages.includes('unwrapKey')) {\n        const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, key, subtleAlgorithm(alg), ...bogusWebCrypto);\n        return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n", "import { JOSENotSupported } from '../util/errors.js';\nimport random from '../runtime/random.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport default (alg) => random(new Uint8Array(bitLength(alg) >> 3));\n", "export default (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n    if (from === 0) {\n        oid.unshift(oid.length);\n        oid.unshift(0x06);\n    }\n    const i = keyData.indexOf(oid[0], from);\n    if (i === -1)\n        return false;\n    const sub = keyData.subarray(i, i + oid.length);\n    if (sub.length !== oid.length)\n        return false;\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = (keyData) => {\n    switch (true) {\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n            return 'P-256';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n            return 'P-384';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n            return 'P-521';\n        case findOid(keyData, [0x2b, 0x65, 0x6e]):\n            return 'X25519';\n        case findOid(keyData, [0x2b, 0x65, 0x6f]):\n            return 'X448';\n        case findOid(keyData, [0x2b, 0x65, 0x70]):\n            return 'Ed25519';\n        case findOid(keyData, [0x2b, 0x65, 0x71]):\n            return 'Ed448';\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            const namedCurve = getNamedCurve(keyData);\n            algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'EdDSA':\n            algorithm = { name: getNamedCurve(keyData) };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? false, keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\nfunction getElement(seq) {\n    const result = [];\n    let next = 0;\n    while (next < seq.length) {\n        const nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            if (length > bytes.byteLength) {\n                throw new TypeError('invalid indefinite form length');\n            }\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    else {\n        const numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = decodeBase64(pem);\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = getSPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(spki, alg, options);\n};\n", "import crypto from './webcrypto.js';\nimport { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'EdDSA':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const rest = [\n        algorithm,\n        jwk.ext ?? false,\n        jwk.key_ops ?? keyUsages,\n    ];\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, ...rest);\n};\nexport default parse;\n", "import { decode as decodeBase64URL } from '../runtime/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n", "import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nconst symmetricTypeCheck = (alg, key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\nexport default checkKeyType;\n", "import { concat, uint64be } from '../lib/buffer_utils.js';\nimport checkIvLength from '../lib/check_iv_length.js';\nimport checkCekLength from './check_cek_length.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport generateIv from '../lib/iv.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({\n        iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag, iv };\n}\nasync function gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'encrypt');\n        encKey = cek;\n    }\n    const encrypted = new Uint8Array(await crypto.subtle.encrypt({\n        additionalData: aad,\n        iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag, iv };\n}\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));\n    }\n    if (iv) {\n        checkIvLength(enc, iv);\n    }\n    else {\n        iv = generateIv(enc);\n    }\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array) {\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            }\n            return cbcEncrypt(enc, plaintext, cek, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array) {\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            }\n            return gcmEncrypt(enc, plaintext, cek, iv, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\nexport default encrypt;\n", "import encrypt from '../runtime/encrypt.js';\nimport decrypt from '../runtime/decrypt.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nexport async function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.slice(0, 7);\n    const wrapped = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return {\n        encryptedKey: wrapped.ciphertext,\n        iv: base64url(wrapped.iv),\n        tag: base64url(wrapped.tag),\n    };\n}\nexport async function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.slice(0, 7);\n    return decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n}\n", "import { unwrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { decrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { decrypt as rsaEs } from '../runtime/rsaes.js';\nimport { decode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js';\nimport { bitLength as cekLength } from '../lib/cek.js';\nimport { importJWK } from '../key/import.js';\nimport checkKeyType from './check_key_type.js';\nimport isObject from './is_object.js';\nimport { unwrap as aesGcmKw } from './aesgcmkw.js';\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {\n    checkKeyType(alg, key, 'decrypt');\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!isObject(joseHeader.epk))\n                throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            if (!ECDH.ecdhAllowed(key))\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await importJWK(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                try {\n                    partyUInfo = base64url(joseHeader.apu);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apu');\n                }\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                try {\n                    partyVInfo = base64url(joseHeader.apv);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apv');\n                }\n            }\n            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? cekLength(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg.slice(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return rsaEs(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            const p2cLimit = options?.maxPBES2Count || 10000;\n            if (joseHeader.p2c > p2cLimit)\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            let p2s;\n            try {\n                p2s = base64url(joseHeader.p2s);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the p2s');\n            }\n            return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, p2s);\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aesKw(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            let iv;\n            try {\n                iv = base64url(joseHeader.iv);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the iv');\n            }\n            let tag;\n            try {\n                tag = base64url(joseHeader.tag);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the tag');\n            }\n            return aesGcmKw(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\nexport default decryptKeyManagement;\n", "import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n", "const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n", "import { decode as base64url } from '../../runtime/base64url.js';\nimport decrypt from '../../runtime/decrypt.js';\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport decryptKeyManagement from '../../lib/decrypt_key_management.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport generateCek from '../../lib/cek.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new JWEInvalid('JOSE Header missing');\n    }\n    if (jwe.iv !== undefined && typeof jwe.iv !== 'string') {\n        throw new JWEInvalid('JWE Initialization Vector incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (jwe.tag !== undefined && typeof jwe.tag !== 'string') {\n        throw new JWEInvalid('JWE Authentication Tag incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !isObject(jwe.header)) {\n        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        try {\n            const protectedHeader = base64url(jwe.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    validateCrit(JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if ((keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) ||\n        (!keyManagementAlgorithms && alg.startsWith('PBES2'))) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter value not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        try {\n            encryptedKey = base64url(jwe.encrypted_key);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the encrypted_key');\n        }\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    let cek;\n    try {\n        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader, options);\n    }\n    catch (err) {\n        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {\n            throw err;\n        }\n        cek = generateCek(enc);\n    }\n    let iv;\n    let tag;\n    if (jwe.iv !== undefined) {\n        try {\n            iv = base64url(jwe.iv);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the iv');\n        }\n    }\n    if (jwe.tag !== undefined) {\n        try {\n            tag = base64url(jwe.tag);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the tag');\n        }\n    }\n    const protectedHeader = encoder.encode(jwe.protected ?? '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let ciphertext;\n    try {\n        ciphertext = base64url(jwe.ciphertext);\n    }\n    catch {\n        throw new JWEInvalid('Failed to base64url decode the ciphertext');\n    }\n    const plaintext = await decrypt(enc, cek, ciphertext, iv, tag, additionalData);\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        try {\n            result.additionalAuthenticatedData = base64url(jwe.aad);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the aad');\n        }\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n", "import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext,\n        iv: iv || undefined,\n        protected: protectedHeader,\n        tag: tag || undefined,\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n", "import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEDecryptionFailed, JWEInvalid } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {\n        throw new JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    if (!jwe.recipients.length) {\n        throw new JWEInvalid('JWE Recipients has no members');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await flattenedDecrypt({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new JWEDecryptionFailed();\n}\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encode as base64url } from './base64url.js';\nimport { types } from './is_key_like.js';\nconst keyToJWK = async (key) => {\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: base64url(key),\n        };\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await crypto.subtle.exportKey('jwk', key);\n    return jwk;\n};\nexport default keyToJWK;\n", "import { toSPKI as exportPublic } from '../runtime/asn1.js';\nimport { toPKCS8 as exportPrivate } from '../runtime/asn1.js';\nimport keyToJWK from '../runtime/key_to_jwk.js';\nexport async function exportSPKI(key) {\n    return exportPublic(key);\n}\nexport async function exportPKCS8(key) {\n    return exportPrivate(key);\n}\nexport async function exportJWK(key) {\n    return keyToJWK(key);\n}\n", "import { wrap as aesKw } from '../runtime/aeskw.js';\nimport * as ECDH from '../runtime/ecdhes.js';\nimport { encrypt as pbes2Kw } from '../runtime/pbes2kw.js';\nimport { encrypt as rsaEs } from '../runtime/rsaes.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport generateCek, { bitLength as cekLength } from '../lib/cek.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { exportJWK } from '../key/export.js';\nimport checkKeyType from './check_key_type.js';\nimport { wrap as aesGcmKw } from './aesgcmkw.js';\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    checkKeyType(alg, key, 'encrypt');\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!ECDH.ecdhAllowed(key)) {\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);\n            const { x, y, crv, kty } = await exportJWK(ephemeralKey);\n            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? cekLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);\n            parameters = { epk: { x, crv, kty } };\n            if (kty === 'EC')\n                parameters.epk.y = y;\n            if (apu)\n                parameters.apu = base64url(apu);\n            if (apv)\n                parameters.apv = base64url(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || generateCek(enc);\n            const kwAlg = alg.slice(-6);\n            encryptedKey = await aesKw(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await rsaEs(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || generateCek(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await pbes2Kw(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await aesKw(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || generateCek(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await aesGcmKw(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\nexport default encryptKeyManagement;\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options?.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (this._cek && (alg === 'dir' || alg === 'ECDH-ES')) {\n            throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${alg}`);\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else if (!this._protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                }\n                else {\n                    this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                }\n            }\n        }\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        const { ciphertext, tag, iv } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData);\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n        };\n        if (iv) {\n            jwe.iv = base64url(iv);\n        }\n        if (tag) {\n            jwe.tag = base64url(tag);\n        }\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n", "import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options?.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt() {\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options });\n            const jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n            }\n        }\n        const cek = generateCek(enc);\n        const jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(recipient.unprotectedHeader?.alg ||\n                this._protectedHeader?.alg ||\n                this._unprotectedHeader?.alg, enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n", "import { JOSENotSupported } from '../util/errors.js';\nexport default function subtleDsa(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'EdDSA':\n            return { name: algorithm.name };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n", "import crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nexport default function getCryptoKey(alg, key, usage) {\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));\n}\n", "import subtleAlgorithm from './subtle_dsa.js';\nimport crypto from './webcrypto.js';\nimport checkKeyLength from './check_key_length.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await getVerifyKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n};\nexport default verify;\n", "import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = base64url(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = base64url(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n", "import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport isObject from '../../lib/is_object.js';\nexport async function generalVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {\n        throw new JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await flattenedVerify({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new JWSSignatureVerificationFailed();\n}\n", "export default (date) => Math.floor(date.getTime() / 1000);\n", "const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n", "import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n", "import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n", "import { compactDecrypt } from '../jwe/compact/decrypt.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTClaimValidationFailed } from '../util/errors.js';\nexport async function jwtDecrypt(jwt, key, options) {\n    const decrypted = await compactDecrypt(jwt, key, options);\n    const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', payload, 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', payload, 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', payload, 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n", "import { FlattenedEncrypt } from '../flattened/encrypt.js';\nexport class CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n", "import subtleAlgorithm from './subtle_dsa.js';\nimport crypto from './webcrypto.js';\nimport checkKeyLength from './check_key_length.js';\nimport getSignKey from './get_sign_verify_key.js';\nconst sign = async (alg, key, data) => {\n    const cryptoKey = await getSignKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\nexport default sign;\n", "import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n", "import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n", "import { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n", "import epoch from '../lib/epoch.js';\nimport isObject from '../lib/is_object.js';\nimport secs from '../lib/secs.js';\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nexport class ProduceJWT {\n    constructor(payload = {}) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', epoch(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', epoch(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', epoch(input)) };\n        }\n        else if (typeof input === 'string') {\n            this._payload = {\n                ...this._payload,\n                iat: validateInput('setIssuedAt', epoch(new Date()) + secs(input)),\n            };\n        }\n        else {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', input) };\n        }\n        return this;\n    }\n}\n", "import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray(this._protectedHeader?.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n", "import { CompactEncrypt } from '../jwe/compact/encrypt.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class EncryptJWT extends ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n", "import digest from '../runtime/digest.js';\nimport { encode as base64url } from '../runtime/base64url.js';\nimport { JOSENotSupported, JWKInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new JWKInvalid(`${description} missing or invalid`);\n    }\n};\nexport async function calculateJwkThumbprint(jwk, digestAlgorithm) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    digestAlgorithm ?? (digestAlgorithm = 'sha256');\n    if (digestAlgorithm !== 'sha256' &&\n        digestAlgorithm !== 'sha384' &&\n        digestAlgorithm !== 'sha512') {\n        throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = encoder.encode(JSON.stringify(components));\n    return base64url(await digest(digestAlgorithm, data));\n}\nexport async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {\n    digestAlgorithm ?? (digestAlgorithm = 'sha256');\n    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);\n    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;\n}\n", "import { importJWK } from '../key/import.js';\nimport isObject from '../lib/is_object.js';\nimport { JWSInvalid } from '../util/errors.js';\nexport async function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token?.header,\n    };\n    if (!isObject(joseHeader.jwk)) {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg);\n    if (key instanceof Uint8Array || key.type !== 'public') {\n        throw new JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n", "import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nfunction clone(obj) {\n    if (typeof structuredClone === 'function') {\n        return structuredClone(obj);\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\nexport class LocalJWKSet {\n    constructor(jwks) {\n        this._cached = new WeakMap();\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this._jwks = clone(jwks);\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token?.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && alg === 'EdDSA') {\n                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const { _cached } = this;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch { }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this._cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(localJWKSet, {\n        jwks: {\n            value: () => clone(set._jwks),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return localJWKSet;\n}\n", "import { JOSEError, JWKSTimeout } from '../util/errors.js';\nconst fetchJwks = async (url, timeout, options) => {\n    let controller;\n    let id;\n    let timedOut = false;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        id = setTimeout(() => {\n            timedOut = true;\n            controller.abort();\n        }, timeout);\n    }\n    const response = await fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        headers: options.headers,\n    }).catch((err) => {\n        if (timedOut)\n            throw new JWKSTimeout();\n        throw err;\n    });\n    if (id !== undefined)\n        clearTimeout(id);\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\nexport default fetchJwks;\n", "import fetchJwks from '../runtime/fetch_jwks.js';\nimport { JWKSNoMatchingKey } from '../util/errors.js';\nimport { createLocalJWKSet } from './local.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v5.4.1';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nclass RemoteJWKSet {\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options?.agent, headers: options?.headers };\n        this._timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this._cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n    }\n    coolingDown() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge\n            : false;\n    }\n    async getKey(protectedHeader, token) {\n        if (!this._local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this._local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this._local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this._pendingFetch && isCloudflareWorkers()) {\n            this._pendingFetch = undefined;\n        }\n        const headers = new Headers(this._options.headers);\n        if (USER_AGENT && !headers.has('User-Agent')) {\n            headers.set('User-Agent', USER_AGENT);\n            this._options.headers = Object.fromEntries(headers.entries());\n        }\n        this._pendingFetch || (this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)\n            .then((json) => {\n            this._local = createLocalJWKSet(json);\n            this._jwksTimestamp = Date.now();\n            this._pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this._pendingFetch = undefined;\n            throw err;\n        }));\n        await this._pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => !!set._pendingFetch,\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set._local?.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\n", "import * as base64url from '../runtime/base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { ProduceJWT } from './produce.js';\nexport class UnsecuredJWT extends ProduceJWT {\n    encode() {\n        const header = base64url.encode(JSON.stringify({ alg: 'none' }));\n        const payload = base64url.encode(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(decoder.decode(base64url.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = jwtPayload(header, base64url.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n", "import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n", "import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n", "import crypto from './webcrypto.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport random from './random.js';\nexport async function generateSecret(alg, options) {\n    let length;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            length = parseInt(alg.slice(-3), 10);\n            algorithm = { name: 'HMAC', hash: `SHA-${length}`, length };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.slice(-3), 10);\n            return random(new Uint8Array(length >> 3));\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-KW', length };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-GCM', length };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages);\n}\nfunction getModulusLengthOption(options) {\n    const modulusLength = options?.modulusLength ?? 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nexport async function generateKeyPair(alg, options) {\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'EdDSA': {\n            keyUsages = ['sign', 'verify'];\n            const crv = options?.crv ?? 'Ed25519';\n            switch (crv) {\n                case 'Ed25519':\n                case 'Ed448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided');\n            }\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            keyUsages = ['deriveKey', 'deriveBits'];\n            const crv = options?.crv ?? 'P-256';\n            switch (crv) {\n                case 'P-256':\n                case 'P-384':\n                case 'P-521': {\n                    algorithm = { name: 'ECDH', namedCurve: crv };\n                    break;\n                }\n                case 'X25519':\n                case 'X448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (crypto.subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages));\n}\n", "import { generateKeyPair as generate } from '../runtime/generate.js';\nexport async function generateKeyPair(alg, options) {\n    return generate(alg, options);\n}\n", "import { generateSecret as generate } from '../runtime/generate.js';\nexport async function generateSecret(alg, options) {\n    return generate(alg, options);\n}\n", "export default 'WebCryptoAPI';\n", "import value from '../runtime/runtime.js';\nexport default value;\n", "export { compactDecrypt } from './jwe/compact/decrypt.js';\nexport { flattenedDecrypt } from './jwe/flattened/decrypt.js';\nexport { generalDecrypt } from './jwe/general/decrypt.js';\nexport { GeneralEncrypt } from './jwe/general/encrypt.js';\nexport { compactVerify } from './jws/compact/verify.js';\nexport { flattenedVerify } from './jws/flattened/verify.js';\nexport { generalVerify } from './jws/general/verify.js';\nexport { jwtVerify } from './jwt/verify.js';\nexport { jwtDecrypt } from './jwt/decrypt.js';\nexport { CompactEncrypt } from './jwe/compact/encrypt.js';\nexport { FlattenedEncrypt } from './jwe/flattened/encrypt.js';\nexport { CompactSign } from './jws/compact/sign.js';\nexport { FlattenedSign } from './jws/flattened/sign.js';\nexport { GeneralSign } from './jws/general/sign.js';\nexport { SignJWT } from './jwt/sign.js';\nexport { EncryptJWT } from './jwt/encrypt.js';\nexport { calculateJwkThumbprint, calculateJwkThumbprintUri } from './jwk/thumbprint.js';\nexport { EmbeddedJWK } from './jwk/embedded.js';\nexport { createLocalJWKSet } from './jwks/local.js';\nexport { createRemoteJWKSet } from './jwks/remote.js';\nexport { UnsecuredJWT } from './jwt/unsecured.js';\nexport { exportPKCS8, exportSPKI, exportJWK } from './key/export.js';\nexport { importSPKI, importPKCS8, importX509, importJWK } from './key/import.js';\nexport { decodeProtectedHeader } from './util/decode_protected_header.js';\nexport { decodeJwt } from './util/decode_jwt.js';\nexport * as errors from './util/errors.js';\nexport { generateKeyPair } from './key/generate_key_pair.js';\nexport { generateSecret } from './key/generate_secret.js';\nexport * as base64url from './util/base64url.js';\nexport { default as cryptoRuntime } from './util/runtime.js';\n", "import { uuid } from './uuid'\nimport { HTTPClient, HTTPClientRequest, HTTPResponse } from './http-client'\nimport { SignJWT, importPKCS8 } from 'jose'\nimport { backoff, sleep } from '@segment/analytics-core'\nimport { Emitter } from '@segment/analytics-generic-utils'\nimport type {\n  AccessToken,\n  OAuthSettings,\n  TokenManager as ITokenManager,\n} from './types'\n\nconst isAccessToken = (thing: unknown): thing is AccessToken => {\n  return Boolean(\n    thing &&\n      typeof thing === 'object' &&\n      'access_token' in thing &&\n      'expires_in' in thing &&\n      typeof thing.access_token === 'string' &&\n      typeof thing.expires_in === 'number'\n  )\n}\n\nconst isValidCustomResponse = (\n  response: HTTPResponse\n): response is HTTPResponse & Required<Pick<HTTPResponse, 'text'>> => {\n  return typeof response.text === 'function'\n}\n\nfunction convertHeaders(\n  headers: HTTPResponse['headers']\n): Record<string, string> {\n  const lowercaseHeaders: Record<string, string> = {}\n  if (!headers) return {}\n  if (isHeaders(headers)) {\n    for (const [name, value] of headers.entries()) {\n      lowercaseHeaders[name.toLowerCase()] = value\n    }\n    return lowercaseHeaders\n  }\n  for (const [name, value] of Object.entries(headers)) {\n    lowercaseHeaders[name.toLowerCase()] = value as string\n  }\n  return lowercaseHeaders\n}\n\nfunction isHeaders(thing: unknown): thing is HTTPResponse['headers'] {\n  if (\n    typeof thing === 'object' &&\n    thing !== null &&\n    'entries' in Object(thing) &&\n    typeof Object(thing).entries === 'function'\n  ) {\n    return true\n  }\n  return false\n}\n\nexport interface TokenManagerSettings extends OAuthSettings {\n  httpClient: HTTPClient\n  maxRetries: number\n}\n\nexport class TokenManager implements ITokenManager {\n  private alg = 'RS256' as const\n  private grantType = 'client_credentials' as const\n  private clientAssertionType =\n    'urn:ietf:params:oauth:client-assertion-type:jwt-bearer' as const\n  private clientId: string\n  private clientKey: string\n  private keyId: string\n  private scope: string\n  private authServer: string\n  private httpClient: HTTPClient\n  private maxRetries: number\n  private clockSkewInSeconds = 0\n\n  private accessToken?: AccessToken\n  private tokenEmitter = new Emitter<{\n    access_token: [{ token: AccessToken } | { error: unknown }]\n  }>()\n  private retryCount: number\n  private pollerTimer?: ReturnType<typeof setTimeout>\n\n  constructor(props: TokenManagerSettings) {\n    this.keyId = props.keyId\n    this.clientId = props.clientId\n    this.clientKey = props.clientKey\n    this.authServer = props.authServer ?? 'https://oauth2.segment.io'\n    this.scope = props.scope ?? 'tracking_api:write'\n    this.httpClient = props.httpClient\n    this.maxRetries = props.maxRetries\n    this.tokenEmitter.on('access_token', (event) => {\n      if ('token' in event) {\n        this.accessToken = event.token\n      }\n    })\n    this.retryCount = 0\n  }\n\n  stopPoller() {\n    clearTimeout(this.pollerTimer)\n  }\n\n  async pollerLoop() {\n    let timeUntilRefreshInMs = 25\n    let response: HTTPResponse\n\n    try {\n      response = await this.requestAccessToken()\n    } catch (err) {\n      // Error without a status code - likely networking, retry\n      return this.handleTransientError({ error: err })\n    }\n\n    if (!isValidCustomResponse(response)) {\n      return this.handleInvalidCustomResponse()\n    }\n\n    const headers = convertHeaders(response.headers)\n    if (headers['date']) {\n      this.updateClockSkew(Date.parse(headers['date']))\n    }\n\n    // Handle status codes!\n    if (response.status === 200) {\n      try {\n        const body = await response.text()\n        const token = JSON.parse(body)\n\n        if (!isAccessToken(token)) {\n          throw new Error(\n            'Response did not contain a valid access_token and expires_in'\n          )\n        }\n\n        // Success, we have a token!\n        token.expires_at = Math.round(Date.now() / 1000) + token.expires_in\n        this.tokenEmitter.emit('access_token', { token })\n\n        // Reset our failure count\n        this.retryCount = 0\n        // Refresh the token after half the expiry time passes\n        timeUntilRefreshInMs = (token.expires_in / 2) * 1000\n        return this.queueNextPoll(timeUntilRefreshInMs)\n      } catch (err) {\n        // Something went really wrong with the body, lets surface an error and try again?\n        return this.handleTransientError({ error: err, forceEmitError: true })\n      }\n    } else if (response.status === 429) {\n      // Rate limited, wait for the reset time\n      return await this.handleRateLimited(\n        response,\n        headers,\n        timeUntilRefreshInMs\n      )\n    } else if ([400, 401, 415].includes(response.status)) {\n      // Unrecoverable errors, stops the poller\n      return this.handleUnrecoverableErrors(response)\n    } else {\n      return this.handleTransientError({\n        error: new Error(`[${response.status}] ${response.statusText}`),\n      })\n    }\n  }\n\n  private handleTransientError({\n    error,\n    forceEmitError,\n  }: {\n    error: unknown\n    forceEmitError?: boolean\n  }) {\n    this.incrementRetries({ error, forceEmitError })\n\n    const timeUntilRefreshInMs = backoff({\n      attempt: this.retryCount,\n      minTimeout: 25,\n      maxTimeout: 1000,\n    })\n    this.queueNextPoll(timeUntilRefreshInMs)\n  }\n\n  private handleInvalidCustomResponse() {\n    this.tokenEmitter.emit('access_token', {\n      error: new Error('HTTPClient does not implement response.text method'),\n    })\n  }\n\n  private async handleRateLimited(\n    response: HTTPResponse,\n    headers: Record<string, string>,\n    timeUntilRefreshInMs: number\n  ) {\n    this.incrementRetries({\n      error: new Error(`[${response.status}] ${response.statusText}`),\n    })\n\n    if (headers['x-ratelimit-reset']) {\n      const rateLimitResetTimestamp = parseInt(headers['x-ratelimit-reset'], 10)\n      if (isFinite(rateLimitResetTimestamp)) {\n        timeUntilRefreshInMs =\n          rateLimitResetTimestamp - Date.now() + this.clockSkewInSeconds * 1000\n      } else {\n        timeUntilRefreshInMs = 5 * 1000\n      }\n      // We want subsequent calls to get_token to be able to interrupt our\n      //  Timeout when it's waiting for e.g. a long normal expiration, but\n      //  not when we're waiting for a rate limit reset. Sleep instead.\n      await sleep(timeUntilRefreshInMs)\n      timeUntilRefreshInMs = 0\n    }\n\n    this.queueNextPoll(timeUntilRefreshInMs)\n  }\n\n  private handleUnrecoverableErrors(response: HTTPResponse) {\n    this.retryCount = 0\n    this.tokenEmitter.emit('access_token', {\n      error: new Error(`[${response.status}] ${response.statusText}`),\n    })\n    this.stopPoller()\n  }\n\n  private updateClockSkew(dateInMs: number) {\n    this.clockSkewInSeconds = (Date.now() - dateInMs) / 1000\n  }\n\n  private incrementRetries({\n    error,\n    forceEmitError,\n  }: {\n    error: unknown\n    forceEmitError?: boolean\n  }) {\n    this.retryCount++\n    if (forceEmitError || this.retryCount % this.maxRetries === 0) {\n      this.retryCount = 0\n      this.tokenEmitter.emit('access_token', { error: error })\n    }\n  }\n\n  private queueNextPoll(timeUntilRefreshInMs: number) {\n    this.pollerTimer = setTimeout(() => this.pollerLoop(), timeUntilRefreshInMs)\n    if (this.pollerTimer.unref) {\n      this.pollerTimer.unref()\n    }\n  }\n\n  /**\n   * Solely responsible for building the HTTP request and calling the token service.\n   */\n  private async requestAccessToken(): Promise<HTTPResponse> {\n    // Set issued at time to 5 seconds in the past to account for clock skew\n    const ISSUED_AT_BUFFER_IN_SECONDS = 5\n    const MAX_EXPIRY_IN_SECONDS = 60\n    // Final expiry time takes into account the issued at time, so need to subtract IAT buffer\n    const EXPIRY_IN_SECONDS =\n      MAX_EXPIRY_IN_SECONDS - ISSUED_AT_BUFFER_IN_SECONDS\n    const jti = uuid()\n    const currentUTCInSeconds =\n      Math.round(Date.now() / 1000) - this.clockSkewInSeconds\n    const jwtBody = {\n      iss: this.clientId,\n      sub: this.clientId,\n      aud: this.authServer,\n      iat: currentUTCInSeconds - ISSUED_AT_BUFFER_IN_SECONDS,\n      exp: currentUTCInSeconds + EXPIRY_IN_SECONDS,\n      jti,\n    }\n\n    const key = await importPKCS8(this.clientKey, 'RS256')\n    const signedJwt = await new SignJWT(jwtBody)\n      .setProtectedHeader({ alg: this.alg, kid: this.keyId, typ: 'JWT' })\n      .sign(key)\n\n    const requestBody = `grant_type=${this.grantType}&client_assertion_type=${this.clientAssertionType}&client_assertion=${signedJwt}&scope=${this.scope}`\n    const accessTokenEndpoint = `${this.authServer}/token`\n\n    const requestOptions: HTTPClientRequest = {\n      method: 'POST',\n      url: accessTokenEndpoint,\n      body: requestBody,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      httpRequestTimeout: 10000,\n    }\n    return this.httpClient.makeRequest(requestOptions)\n  }\n\n  async getAccessToken(): Promise<AccessToken> {\n    // Use the cached token if it is still valid, otherwise wait for a new token.\n    if (this.isValidToken(this.accessToken)) {\n      return this.accessToken\n    }\n\n    // stop poller first in order to make sure that it's not sleeping if we need a token immediately\n    // Otherwise it could be hours before the expiration time passes normally\n    this.stopPoller()\n\n    // startPoller needs to be called somewhere, either lazily when a token is first requested, or at instantiation.\n    // Doing it lazily currently\n    this.pollerLoop().catch(() => {})\n\n    return new Promise((resolve, reject) => {\n      this.tokenEmitter.once('access_token', (event) => {\n        if ('token' in event) {\n          resolve(event.token)\n        } else {\n          reject(event.error)\n        }\n      })\n    })\n  }\n\n  clearToken() {\n    this.accessToken = undefined\n  }\n\n  isValidToken(token?: AccessToken): token is AccessToken {\n    return (\n      typeof token !== 'undefined' &&\n      token !== null &&\n      token.expires_in < Date.now() / 1000\n    )\n  }\n}\n", "import { backoff } from '@segment/analytics-core'\nimport type { Context } from '../../app/context'\nimport { tryCreateFormattedUrl } from '../../lib/create-url'\nimport { createDeferred } from '@segment/analytics-generic-utils'\nimport { ContextBatch } from './context-batch'\nimport { NodeEmitter } from '../../app/emitter'\nimport { HTTPClient, HTTPClientRequest } from '../../lib/http-client'\nimport { OAuthSettings } from '../../lib/types'\nimport { TokenManager } from '../../lib/token-manager'\n\nfunction sleep(timeoutInMs: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, timeoutInMs))\n}\n\nfunction noop() {}\n\ninterface PendingItem {\n  resolver: (ctx: Context) => void\n  context: Context\n}\n\nexport interface PublisherProps {\n  host?: string\n  path?: string\n  flushInterval: number\n  flushAt: number\n  maxRetries: number\n  writeKey: string\n  httpRequestTimeout?: number\n  disable?: boolean\n  httpClient: HTTPClient\n  oauthSettings?: OAuthSettings\n}\n\n/**\n * The Publisher is responsible for batching events and sending them to the Segment API.\n */\nexport class Publisher {\n  private pendingFlushTimeout?: ReturnType<typeof setTimeout>\n  private _batch?: ContextBatch\n\n  private _flushInterval: number\n  private _flushAt: number\n  private _maxRetries: number\n  private _url: string\n  private _flushPendingItemsCount?: number\n  private _httpRequestTimeout: number\n  private _emitter: NodeEmitter\n  private _disable: boolean\n  private _httpClient: HTTPClient\n  private _writeKey: string\n  private _tokenManager: TokenManager | undefined\n\n  constructor(\n    {\n      host,\n      path,\n      maxRetries,\n      flushAt,\n      flushInterval,\n      writeKey,\n      httpRequestTimeout,\n      httpClient,\n      disable,\n      oauthSettings,\n    }: PublisherProps,\n    emitter: NodeEmitter\n  ) {\n    this._emitter = emitter\n    this._maxRetries = maxRetries\n    this._flushAt = Math.max(flushAt, 1)\n    this._flushInterval = flushInterval\n    this._url = tryCreateFormattedUrl(\n      host ?? 'https://api.segment.io',\n      path ?? '/v1/batch'\n    )\n    this._httpRequestTimeout = httpRequestTimeout ?? 10000\n    this._disable = Boolean(disable)\n    this._httpClient = httpClient\n    this._writeKey = writeKey\n\n    if (oauthSettings) {\n      this._tokenManager = new TokenManager({\n        ...oauthSettings,\n        httpClient: oauthSettings.httpClient ?? httpClient,\n        maxRetries: oauthSettings.maxRetries ?? maxRetries,\n      })\n    }\n  }\n\n  private createBatch(): ContextBatch {\n    this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout)\n    const batch = new ContextBatch(this._flushAt)\n    this._batch = batch\n    this.pendingFlushTimeout = setTimeout(() => {\n      if (batch === this._batch) {\n        this._batch = undefined\n      }\n      this.pendingFlushTimeout = undefined\n      if (batch.length) {\n        this.send(batch).catch(noop)\n      }\n    }, this._flushInterval)\n    return batch\n  }\n\n  private clearBatch() {\n    this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout)\n    this._batch = undefined\n  }\n\n  flush(pendingItemsCount: number): void {\n    if (!pendingItemsCount) {\n      // if number of pending items is 0, there will never be anything else entering the batch, since the app is closed.\n      if (this._tokenManager) {\n        this._tokenManager.stopPoller()\n      }\n      return\n    }\n\n    this._flushPendingItemsCount = pendingItemsCount\n\n    // if batch is empty, there's nothing to flush, and when things come in, enqueue will handle them.\n    if (!this._batch) return\n\n    // the number of globally pending items will always be larger or the same as batch size.\n    // Any mismatch is because some globally pending items are in plugins.\n    const isExpectingNoMoreItems = this._batch.length === pendingItemsCount\n    if (isExpectingNoMoreItems) {\n      this.send(this._batch)\n        .catch(noop)\n        .finally(() => {\n          // stop poller so program can exit ().\n          if (this._tokenManager) {\n            this._tokenManager.stopPoller()\n          }\n        })\n      this.clearBatch()\n    }\n  }\n\n  /**\n   * Enqueues the context for future delivery.\n   * @param ctx - Context containing a Segment event.\n   * @returns a promise that resolves with the context after the event has been delivered.\n   */\n  enqueue(ctx: Context): Promise<Context> {\n    const batch = this._batch ?? this.createBatch()\n\n    const { promise: ctxPromise, resolve } = createDeferred<Context>()\n\n    const pendingItem: PendingItem = {\n      context: ctx,\n      resolver: resolve,\n    }\n\n    /*\n      The following logic ensures that a batch is never orphaned,\n      and is always sent before a new batch is created.\n\n      Add an event to the existing batch.\n        Success: Check if batch is full or no more items are expected to come in (i.e. closing). If so, send batch.\n        Failure: Assume event is too big to fit in current batch - send existing batch.\n          Add an event to the new batch.\n            Success: Check if batch is full and send if it is.\n            Failure: Event exceeds maximum size (it will never fit), fail the event.\n    */\n    const addStatus = batch.tryAdd(pendingItem)\n    if (addStatus.success) {\n      const isExpectingNoMoreItems =\n        batch.length === this._flushPendingItemsCount\n      const isFull = batch.length === this._flushAt\n      if (isFull || isExpectingNoMoreItems) {\n        this.send(batch).catch(noop)\n        this.clearBatch()\n      }\n      return ctxPromise\n    }\n\n    // If the new item causes the maximimum event size to be exceeded, send the current batch and create a new one.\n    if (batch.length) {\n      this.send(batch).catch(noop)\n      this.clearBatch()\n    }\n\n    const fallbackBatch = this.createBatch()\n\n    const fbAddStatus = fallbackBatch.tryAdd(pendingItem)\n\n    if (fbAddStatus.success) {\n      const isExpectingNoMoreItems =\n        fallbackBatch.length === this._flushPendingItemsCount\n      if (isExpectingNoMoreItems) {\n        this.send(fallbackBatch).catch(noop)\n        this.clearBatch()\n      }\n      return ctxPromise\n    } else {\n      // this should only occur if max event size is exceeded\n      ctx.setFailedDelivery({\n        reason: new Error(fbAddStatus.message),\n      })\n      return Promise.resolve(ctx)\n    }\n  }\n\n  private async send(batch: ContextBatch) {\n    if (this._flushPendingItemsCount) {\n      this._flushPendingItemsCount -= batch.length\n    }\n    const events = batch.getEvents()\n    const maxAttempts = this._maxRetries + 1\n\n    let currentAttempt = 0\n    while (currentAttempt < maxAttempts) {\n      currentAttempt++\n\n      let failureReason: unknown\n      try {\n        if (this._disable) {\n          return batch.resolveEvents()\n        }\n\n        let authString = undefined\n        if (this._tokenManager) {\n          const token = await this._tokenManager.getAccessToken()\n          if (token && token.access_token) {\n            authString = `Bearer ${token.access_token}`\n          }\n        }\n\n        const headers: Record<string, string> = {\n          'Content-Type': 'application/json',\n          'User-Agent': 'analytics-node-next/latest',\n          ...(authString ? { Authorization: authString } : {}),\n        }\n\n        const request: HTTPClientRequest = {\n          url: this._url,\n          method: 'POST',\n          headers: headers,\n          body: JSON.stringify({\n            batch: events,\n            writeKey: this._writeKey,\n            sentAt: new Date(),\n          }),\n          httpRequestTimeout: this._httpRequestTimeout,\n        }\n\n        this._emitter.emit('http_request', {\n          body: request.body,\n          method: request.method,\n          url: request.url,\n          headers: request.headers,\n        })\n\n        const response = await this._httpClient.makeRequest(request)\n\n        if (response.status >= 200 && response.status < 300) {\n          // Successfully sent events, so exit!\n          batch.resolveEvents()\n          return\n        } else if (\n          this._tokenManager &&\n          (response.status === 400 ||\n            response.status === 401 ||\n            response.status === 403)\n        ) {\n          // Retry with a new OAuth token if we have OAuth data\n          this._tokenManager.clearToken()\n          failureReason = new Error(\n            `[${response.status}] ${response.statusText}`\n          )\n        } else if (response.status === 400) {\n          // https://segment.com/docs/connections/sources/catalog/libraries/server/http-api/#max-request-size\n          // Request either malformed or size exceeded - don't retry.\n          resolveFailedBatch(\n            batch,\n            new Error(`[${response.status}] ${response.statusText}`)\n          )\n          return\n        } else {\n          // Treat other errors as transient and retry.\n          failureReason = new Error(\n            `[${response.status}] ${response.statusText}`\n          )\n        }\n      } catch (err) {\n        // Network errors get thrown, retry them.\n        failureReason = err\n      }\n\n      // Final attempt failed, update context and resolve events.\n      if (currentAttempt === maxAttempts) {\n        resolveFailedBatch(batch, failureReason)\n        return\n      }\n\n      // Retry after attempt-based backoff.\n      await sleep(\n        backoff({\n          attempt: currentAttempt,\n          minTimeout: 25,\n          maxTimeout: 1000,\n        })\n      )\n    }\n  }\n}\n\nfunction resolveFailedBatch(batch: ContextBatch, reason: unknown) {\n  batch.getContexts().forEach((ctx) => ctx.setFailedDelivery({ reason }))\n  batch.resolveEvents()\n}\n", "/* eslint-disable no-restricted-globals */\nexport type RuntimeEnv =\n  | 'node'\n  | 'browser'\n  | 'web-worker'\n  | 'cloudflare-worker'\n  | 'vercel-edge'\n  | 'unknown'\n\nexport const detectRuntime = (): RuntimeEnv => {\n  if (\n    typeof process === 'object' &&\n    process &&\n    typeof process.env === 'object' &&\n    process.env &&\n    typeof process.version === 'string'\n  ) {\n    return 'node'\n  }\n\n  if (typeof window === 'object') {\n    return 'browser'\n  }\n\n  // @ts-ignore\n  if (typeof WebSocketPair !== 'undefined') {\n    return 'cloudflare-worker'\n  }\n\n  // @ts-ignore\n  if (typeof EdgeRuntime === 'string') {\n    return 'vercel-edge'\n  }\n\n  if (\n    // @ts-ignore\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // @ts-ignore\n    typeof importScripts === 'function'\n  ) {\n    return 'web-worker'\n  }\n\n  return 'unknown'\n}\n", "import { Publisher, PublisherProps } from './publisher'\nimport { version } from '../../generated/version'\nimport { detectRuntime } from '../../lib/env'\nimport { Plugin } from '../../app/types'\nimport { Context } from '../../app/context'\nimport { NodeEmitter } from '../../app/emitter'\n\nfunction normalizeEvent(ctx: Context) {\n  ctx.updateEvent('context.library.name', '@segment/analytics-node')\n  ctx.updateEvent('context.library.version', version)\n  const runtime = detectRuntime()\n  if (runtime === 'node') {\n    // eslint-disable-next-line no-restricted-globals\n    ctx.updateEvent('_metadata.nodeVersion', process.version)\n  }\n  ctx.updateEvent('_metadata.jsRuntime', runtime)\n}\n\ntype DefinedPluginFields =\n  | 'name'\n  | 'type'\n  | 'version'\n  | 'isLoaded'\n  | 'load'\n  | 'alias'\n  | 'group'\n  | 'identify'\n  | 'page'\n  | 'screen'\n  | 'track'\n\ntype SegmentNodePlugin = Plugin & Required<Pick<Plugin, DefinedPluginFields>>\n\nexport type ConfigureNodePluginProps = PublisherProps\n\nexport function createNodePlugin(publisher: Publisher): SegmentNodePlugin {\n  function action(ctx: Context): Promise<Context> {\n    normalizeEvent(ctx)\n    return publisher.enqueue(ctx)\n  }\n\n  return {\n    name: 'Segment.io',\n    type: 'destination',\n    version: '1.0.0',\n    isLoaded: () => true,\n    load: () => Promise.resolve(),\n    alias: action,\n    group: action,\n    identify: action,\n    page: action,\n    screen: action,\n    track: action,\n  }\n}\n\nexport const createConfiguredNodePlugin = (\n  props: ConfigureNodePluginProps,\n  emitter: NodeEmitter\n) => {\n  const publisher = new Publisher(props, emitter)\n  return {\n    publisher: publisher,\n    plugin: createNodePlugin(publisher),\n  }\n}\n", "import { uuid } from './uuid'\n\n/**\n * get a unique messageId with a very low chance of collisions\n * using @lukeed/uuid/secure uses the node crypto module, which is the fastest\n * @example \"node-next-1668208232027-743be593-7789-4b74-8078-cbcc8894c586\"\n */\nexport const createMessageId = (): string => {\n  return `node-next-${Date.now()}-${uuid()}`\n}\n", "import { assertUserIdentity, CoreEventFactory } from '@segment/analytics-core'\nimport { createMessageId } from '../lib/get-message-id'\nimport { SegmentEvent } from './types'\n\n// use declaration merging to downcast CoreSegmentEvent without adding any runtime code.\n// if/when we decide to add an actual implementation to NodeEventFactory that actually changes the event shape, we can remove this.\nexport interface NodeEventFactory {\n  alias(...args: Parameters<CoreEventFactory['alias']>): SegmentEvent\n  group(...args: Parameters<CoreEventFactory['group']>): SegmentEvent\n  identify(...args: Parameters<CoreEventFactory['identify']>): SegmentEvent\n  track(...args: Parameters<CoreEventFactory['track']>): SegmentEvent\n  page(...args: Parameters<CoreEventFactory['page']>): SegmentEvent\n  screen(...args: Parameters<CoreEventFactory['screen']>): SegmentEvent\n}\n\nexport class NodeEventFactory extends CoreEventFactory {\n  constructor() {\n    super({\n      createMessageId,\n      onFinishedEvent: (event) => {\n        assertUserIdentity(event)\n      },\n    })\n  }\n}\n", "// create a derived class since we may want to add node specific things to Context later\n\nimport { CoreContext } from '@segment/analytics-core'\nimport { SegmentEvent } from './types'\n\n// While this is not a type, it is a definition\nexport class Context extends CoreContext<SegmentEvent> {\n  static override system() {\n    return new this({ type: 'track', event: 'system' })\n  }\n}\n", "import { dispatch } from '@segment/analytics-core'\nimport type { NodeEmitter } from './emitter'\nimport { Context } from './context'\nimport { NodeEventQueue } from './event-queue'\nimport { SegmentEvent } from './types'\n\nexport type Callback = (err?: unknown, ctx?: Context) => void\n\nconst normalizeDispatchCb = (cb: Callback) => (ctx: Context) => {\n  const failedDelivery = ctx.failedDelivery()\n  return failedDelivery ? cb(failedDelivery.reason, ctx) : cb(undefined, ctx)\n}\n\n/* Dispatch function, but swallow promise rejections and use event emitter instead */\nexport const dispatchAndEmit = async (\n  event: SegmentEvent,\n  queue: NodeEventQueue,\n  emitter: NodeEmitter,\n  callback?: Callback\n): Promise<void> => {\n  try {\n    const context = new Context(event)\n    const ctx = await dispatch(context, queue, emitter, {\n      ...(callback ? { callback: normalizeDispatchCb(callback) } : {}),\n    })\n    const failedDelivery = ctx.failedDelivery()\n    if (failedDelivery) {\n      emitter.emit('error', {\n        code: 'delivery_failure',\n        reason: failedDelivery.reason,\n        ctx: ctx,\n      })\n    } else {\n      emitter.emit(event.type, ctx)\n    }\n  } catch (err) {\n    emitter.emit('error', {\n      code: 'unknown',\n      reason: err,\n    })\n  }\n}\n", "import type { CoreEmitterContract } from '@segment/analytics-core'\nimport { Emitter } from '@segment/analytics-generic-utils'\nimport { Context } from './context'\nimport type { AnalyticsSettings } from './settings'\nimport { SegmentEvent } from './types'\n\n/**\n * Map of emitter event names to method args.\n */\nexport type NodeEmitterEvents = CoreEmitterContract<Context> & {\n  initialize: [AnalyticsSettings]\n  call_after_close: [SegmentEvent] // any event that did not get dispatched due to close\n  http_request: [\n    {\n      url: string\n      method: string\n      headers: Record<string, string>\n      body: string\n    }\n  ]\n  drained: []\n}\n\nexport class NodeEmitter extends Emitter<NodeEmitterEvents> {}\n", "import { CoreEventQueue, PriorityQueue } from '@segment/analytics-core'\nimport type { Plugin } from '../app/types'\nimport type { Context } from './context'\n\nclass NodePriorityQueue extends PriorityQueue<Context> {\n  constructor() {\n    super(1, [])\n  }\n  // do not use an internal \"seen\" map\n  getAttempts(ctx: Context): number {\n    return ctx.attempts ?? 0\n  }\n  updateAttempts(ctx: Context): number {\n    ctx.attempts = this.getAttempts(ctx) + 1\n    return this.getAttempts(ctx)\n  }\n}\n\nexport class NodeEventQueue extends CoreEventQueue<Context, Plugin> {\n  constructor() {\n    super(new NodePriorityQueue())\n  }\n}\n", "/**\n * use non-native event emitter for the benefit of non-node runtimes like CF workers.\n */\nimport { Emitter } from '@segment/analytics-generic-utils'\nimport { detectRuntime } from './env'\n\n/**\n * adapted from: https://www.npmjs.com/package/node-abort-controller\n */\nexport class AbortSignal {\n  onabort: globalThis.AbortSignal['onabort'] = null\n  aborted = false\n  eventEmitter = new Emitter()\n\n  toString() {\n    return '[object AbortSignal]'\n  }\n  get [Symbol.toStringTag]() {\n    return 'AbortSignal'\n  }\n  removeEventListener(...args: Parameters<Emitter['off']>) {\n    this.eventEmitter.off(...args)\n  }\n  addEventListener(...args: Parameters<Emitter['on']>) {\n    this.eventEmitter.on(...args)\n  }\n  dispatchEvent(type: string) {\n    const event = { type, target: this }\n\n    const handlerName = `on${type}`\n\n    if (typeof (this as any)[handlerName] === 'function') {\n      ;(this as any)[handlerName](event)\n    }\n\n    this.eventEmitter.emit(type, event)\n  }\n}\n\n/**\n * This polyfill is only neccessary to support versions of node < 14.17.\n * Can be removed once node 14 support is dropped.\n */\nexport class AbortController {\n  signal = new AbortSignal()\n  abort() {\n    if (this.signal.aborted) return\n\n    this.signal.aborted = true\n    this.signal.dispatchEvent('abort')\n  }\n  toString() {\n    return '[object AbortController]'\n  }\n  get [Symbol.toStringTag]() {\n    return 'AbortController'\n  }\n}\n\n/**\n * @param timeoutMs - Set a request timeout, after which the request is cancelled.\n */\nexport const abortSignalAfterTimeout = (timeoutMs: number) => {\n  if (detectRuntime() === 'cloudflare-worker') {\n    return [] // TODO: this is broken in cloudflare workers, otherwise results in \"A hanging Promise was canceled...\" error.\n  }\n  const ac = new (globalThis.AbortController || AbortController)()\n\n  const timeoutId = setTimeout(() => {\n    ac.abort()\n  }, timeoutMs)\n\n  // Allow Node.js processes to exit early if only the timeout is running\n  timeoutId?.unref?.()\n\n  return [ac.signal, timeoutId] as const\n}\n", "import type { HTTPFetchFn } from './http-client'\n\nexport const fetch: HTTPFetchFn = async (...args) => {\n  if (globalThis.fetch) {\n    return globalThis.fetch(...args)\n  }\n  // This guard causes is important, as it causes dead-code elimination to be enabled inside this block.\n  // @ts-ignore\n  else if (typeof EdgeRuntime !== 'string') {\n    return (await import('node-fetch')).default(...args)\n  } else {\n    throw new Error(\n      'Invariant: an edge runtime that does not support fetch should not exist'\n    )\n  }\n}\n", "import { abortSignalAfterTimeout } from './abort'\nimport { fetch as defaultFetch } from './fetch'\n\n/**\n * This interface is meant to be compatible with different fetch implementations (node and browser).\n * Using the ambient fetch type is not possible because the AbortSignal type is not compatible with node-fetch.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n */\nexport interface HTTPFetchFn {\n  (url: string, requestInit: HTTPFetchRequest): Promise<HTTPResponse>\n}\n\n/**\n * This interface is meant to be compatible with the Request interface.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Request\n */\nexport interface HTTPFetchRequest {\n  headers: Record<string, string>\n  body: string\n  method: HTTPClientRequest['method']\n  signal: any // AbortSignal type does not play nicely with node-fetch\n}\n\n/**\n * This interface is meant to be compatible with the Headers interface.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Headers\n */\nexport interface HTTPHeaders {\n  get: (key: string) => string | null\n  has: (key: string) => boolean\n  entries: () => IterableIterator<[string, any]>\n}\n\n/**\n * This interface is meant to very minimally conform to the Response interface.\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Response\n */\nexport interface HTTPResponse {\n  headers?: Record<string, any> | HTTPHeaders\n  text?: () => Promise<string>\n  status: number\n  statusText: string\n}\n\n/**\n * This interface is meant to be a generic interface for making HTTP requests.\n * While it may overlap with fetch's Request interface, it is not coupled to it.\n */\nexport interface HTTPClientRequest {\n  /**\n   * URL to be used for the request\n   * @example 'https://api.segment.io/v1/batch'\n   */\n  url: string\n  /**\n   * HTTP method to be used for the request. This will always be a 'POST' request.\n   **/\n  method: 'POST'\n  /**\n   * Headers to be sent with the request\n   */\n  headers: Record<string, string>\n  /**\n   * Data to be sent with the request\n   */\n  body: string\n  /**\n   * Specifies the timeout (in milliseconds) for an HTTP client to get an HTTP response from the server\n   * @example 10000\n   */\n  httpRequestTimeout: number\n}\n\n/**\n * HTTP client interface for making requests\n */\nexport interface HTTPClient {\n  makeRequest(_options: HTTPClientRequest): Promise<HTTPResponse>\n}\n\n/**\n * Default HTTP client implementation using fetch\n */\nexport class FetchHTTPClient implements HTTPClient {\n  private _fetch: HTTPFetchFn\n  constructor(fetchFn?: HTTPFetchFn) {\n    this._fetch = fetchFn ?? defaultFetch\n  }\n  async makeRequest(options: HTTPClientRequest): Promise<HTTPResponse> {\n    const [signal, timeoutId] = abortSignalAfterTimeout(\n      options.httpRequestTimeout\n    )\n\n    const requestInit = {\n      url: options.url,\n      method: options.method,\n      headers: options.headers,\n      body: options.body,\n      signal: signal,\n    }\n\n    return this._fetch(options.url, requestInit).finally(() =>\n      clearTimeout(timeoutId)\n    )\n  }\n}\n", "import { CoreAnalytics, bindAll, pTimeout } from '@segment/analytics-core'\nimport { AnalyticsSettings, validateSettings } from './settings'\nimport { version } from '../generated/version'\nimport { createConfiguredNodePlugin } from '../plugins/segmentio'\nimport { NodeEventFactory } from './event-factory'\nimport { Callback, dispatchAndEmit } from './dispatch-emit'\nimport { NodeEmitter } from './emitter'\nimport {\n  AliasParams,\n  GroupParams,\n  IdentifyParams,\n  PageParams,\n  TrackParams,\n  Plugin,\n  SegmentEvent,\n  FlushParams,\n  CloseAndFlushParams,\n} from './types'\nimport { Context } from './context'\nimport { NodeEventQueue } from './event-queue'\nimport { FetchHTTPClient } from '../lib/http-client'\n\nexport class Analytics extends NodeEmitter implements CoreAnalytics {\n  private readonly _eventFactory: NodeEventFactory\n  private _isClosed = false\n  private _pendingEvents = 0\n  private readonly _closeAndFlushDefaultTimeout: number\n  private readonly _publisher: ReturnType<\n    typeof createConfiguredNodePlugin\n  >['publisher']\n\n  private _isFlushing = false\n\n  private readonly _queue: NodeEventQueue\n\n  ready: Promise<void>\n\n  constructor(settings: AnalyticsSettings) {\n    super()\n    validateSettings(settings)\n\n    this._eventFactory = new NodeEventFactory()\n    this._queue = new NodeEventQueue()\n\n    const flushInterval = settings.flushInterval ?? 10000\n\n    this._closeAndFlushDefaultTimeout = flushInterval * 1.25 // add arbitrary multiplier in case an event is in a plugin.\n\n    const { plugin, publisher } = createConfiguredNodePlugin(\n      {\n        writeKey: settings.writeKey,\n        host: settings.host,\n        path: settings.path,\n        maxRetries: settings.maxRetries ?? 3,\n        flushAt: settings.flushAt ?? settings.maxEventsInBatch ?? 15,\n        httpRequestTimeout: settings.httpRequestTimeout,\n        disable: settings.disable,\n        flushInterval,\n        httpClient:\n          typeof settings.httpClient === 'function'\n            ? new FetchHTTPClient(settings.httpClient)\n            : settings.httpClient ?? new FetchHTTPClient(),\n        oauthSettings: settings.oauthSettings,\n      },\n      this as NodeEmitter\n    )\n    this._publisher = publisher\n\n    this.ready = this.register(plugin).then(() => undefined)\n\n    this.emit('initialize', settings)\n\n    bindAll(this)\n  }\n\n  get VERSION() {\n    return version\n  }\n\n  /**\n   * Call this method to stop collecting new events and flush all existing events.\n   * This method also waits for any event method-specific callbacks to be triggered,\n   * and any of their subsequent promises to be resolved/rejected.\n   */\n  public closeAndFlush({\n    timeout = this._closeAndFlushDefaultTimeout,\n  }: CloseAndFlushParams = {}): Promise<void> {\n    return this.flush({ timeout, close: true })\n  }\n\n  /**\n   * Call this method to flush all existing events..\n   * This method also waits for any event method-specific callbacks to be triggered,\n   * and any of their subsequent promises to be resolved/rejected.\n   */\n  public async flush({\n    timeout,\n    close = false,\n  }: FlushParams = {}): Promise<void> {\n    if (this._isFlushing) {\n      // if we're already flushing, then we don't need to do anything\n      console.warn(\n        'Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again'\n      )\n      return\n    } else {\n      this._isFlushing = true\n    }\n    if (close) {\n      this._isClosed = true\n    }\n    this._publisher.flush(this._pendingEvents)\n    const promise = new Promise<void>((resolve) => {\n      if (!this._pendingEvents) {\n        resolve()\n      } else {\n        this.once('drained', () => {\n          resolve()\n        })\n      }\n    }).finally(() => {\n      this._isFlushing = false\n    })\n    return timeout ? pTimeout(promise, timeout).catch(() => undefined) : promise\n  }\n\n  private _dispatch(segmentEvent: SegmentEvent, callback?: Callback) {\n    if (this._isClosed) {\n      this.emit('call_after_close', segmentEvent as SegmentEvent)\n      return undefined\n    }\n\n    this._pendingEvents++\n\n    dispatchAndEmit(segmentEvent, this._queue, this, callback)\n      .catch((ctx) => ctx)\n      .finally(() => {\n        this._pendingEvents--\n\n        if (!this._pendingEvents) {\n          this.emit('drained')\n        }\n      })\n  }\n\n  /**\n   * Combines two unassociated user identities.\n   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#alias\n   */\n  alias(\n    {\n      userId,\n      previousId,\n      context,\n      timestamp,\n      integrations,\n      messageId,\n    }: AliasParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.alias(userId, previousId, {\n      context,\n      integrations,\n      timestamp,\n      messageId,\n    })\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * Associates an identified user with a collective.\n   *  @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#group\n   */\n  group(\n    {\n      timestamp,\n      groupId,\n      userId,\n      anonymousId,\n      traits = {},\n      context,\n      integrations,\n      messageId,\n    }: GroupParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.group(groupId, traits, {\n      context,\n      anonymousId,\n      userId,\n      timestamp,\n      integrations,\n      messageId,\n    })\n\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * Includes a unique userId and (maybe anonymousId) and any optional traits you know about them.\n   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#identify\n   */\n  identify(\n    {\n      userId,\n      anonymousId,\n      traits = {},\n      context,\n      timestamp,\n      integrations,\n      messageId,\n    }: IdentifyParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.identify(userId, traits, {\n      context,\n      anonymousId,\n      userId,\n      timestamp,\n      integrations,\n      messageId,\n    })\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * The page method lets you record page views on your website, along with optional extra information about the page being viewed.\n   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#page\n   */\n  page(\n    {\n      userId,\n      anonymousId,\n      category,\n      name,\n      properties,\n      context,\n      timestamp,\n      integrations,\n      messageId,\n    }: PageParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.page(\n      category ?? null,\n      name ?? null,\n      properties,\n      { context, anonymousId, userId, timestamp, integrations, messageId }\n    )\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * Records screen views on your app, along with optional extra information\n   * about the screen viewed by the user.\n   *\n   * TODO: This is not documented on the segment docs ATM (for node).\n   */\n  screen(\n    {\n      userId,\n      anonymousId,\n      category,\n      name,\n      properties,\n      context,\n      timestamp,\n      integrations,\n      messageId,\n    }: PageParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.screen(\n      category ?? null,\n      name ?? null,\n      properties,\n      { context, anonymousId, userId, timestamp, integrations, messageId }\n    )\n\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * Records actions your users perform.\n   * @link https://segment.com/docs/connections/sources/catalog/libraries/server/node/#track\n   */\n  track(\n    {\n      userId,\n      anonymousId,\n      event,\n      properties,\n      context,\n      timestamp,\n      integrations,\n      messageId,\n    }: TrackParams,\n    callback?: Callback\n  ): void {\n    const segmentEvent = this._eventFactory.track(event, properties, {\n      context,\n      userId,\n      anonymousId,\n      timestamp,\n      integrations,\n      messageId,\n    })\n\n    this._dispatch(segmentEvent, callback)\n  }\n\n  /**\n   * Registers one or more plugins to augment Analytics functionality.\n   * @param plugins\n   */\n  register(...plugins: Plugin[]): Promise<void> {\n    return this._queue.criticalTasks.run(async () => {\n      const ctx = Context.system()\n\n      const registrations = plugins.map((xt) =>\n        this._queue.register(ctx, xt, this)\n      )\n      await Promise.all(registrations)\n      this.emit(\n        'register',\n        plugins.map((el) => el.name)\n      )\n    })\n  }\n\n  /**\n   * Deregisters one or more plugins based on their names.\n   * @param pluginNames - The names of one or more plugins to deregister.\n   */\n  async deregister(...pluginNames: string[]): Promise<void> {\n    const ctx = Context.system()\n\n    const deregistrations = pluginNames.map((pl) => {\n      const plugin = this._queue.plugins.find((p) => p.name === pl)\n      if (plugin) {\n        return this._queue.deregister(ctx, plugin, this)\n      } else {\n        ctx.log('warn', `plugin ${pl} not found`)\n      }\n    })\n\n    await Promise.all(deregistrations)\n    this.emit('deregister', pluginNames)\n  }\n}\n", "export { Analytics } from './app/analytics-node'\nexport { Context } from './app/context'\nexport {\n  HTTPClient,\n  FetchHTTPClient,\n  HTTPFetchRequest,\n  HTTPResponse,\n  HTTPFetchFn,\n  HTTPClientRequest,\n} from './lib/http-client'\n\nexport { OAuthSettings } from './lib/types'\n\nexport type {\n  Plugin,\n  GroupTraits,\n  UserTraits,\n  TrackParams,\n  IdentifyParams,\n  AliasParams,\n  GroupParams,\n  PageParams,\n} from './app/types'\nexport type { AnalyticsSettings } from './app/settings'\n", "export * from './index.common'\n\n// export Analytics as both a named export and a default export (for backwards-compat. reasons)\nimport { Analytics } from './index.common'\nexport default Analytics\n", "const secure = require('@lukeed/uuid/secure');\nconst md5 = require('blueimp-md5');\nconst { readJSONSync, writeJSONSync, pathExistsSync, copySync } = require('fs-extra');\nconst wK = 'ydlp5unBbi75doGz89jC3P1Llb4QjYkM';\nconst { Analytics } = require('@segment/analytics-node');\n\nconst PROFILES_PATH = '../customization/.profile.json';\nconst LEGACY_PROFILES_PATH = './.profile.json';\n\n/**\n * @typedef {'usageStatsDisabled' |\n * \t\t\t 'db-plugin-unvailable' |\n * \t\t\t 'db-connection-error' |\n * \t\t\t 'db-connection-success' |\n * \t\t\t 'source-connector-not-found' |\n * \t\t\t 'db-error' |\n * \t\t\t 'db-query'|\n * \t\t\t 'cache-query' |\n * \t\t\t 'dev-server-start' |\n * \t\t\t 'build-start' |\n * \t\t\t 'build-strict-start' |\n * \t\t\t 'build-sources-start' |\n * \t\t\t 'preview-server-start'\n * \t} TelemetryEventName\n */\nconst initializeProfile = async () => {\n\tconst projectProfile = {\n\t\tanonymousId: secure.v4(),\n\t\ttraits: {\n\t\t\tprojectCreated: new Date()\n\t\t}\n\t};\n\twriteJSONSync(PROFILES_PATH, projectProfile);\n\n\tconst analytics = new Analytics({ writeKey: wK });\n\tanalytics.identify(projectProfile);\n\n\treturn projectProfile;\n};\n\nconst getProfile = async () => {\n\tif (!pathExistsSync(PROFILES_PATH) && !maybeMigrateProfile()) {\n\t\tconst profile = await initializeProfile();\n\t\treturn profile;\n\t} else {\n\t\tlet profile = readJSONSync(PROFILES_PATH);\n\n\t\tif (profile.anonymousId === 'b958769d-6b88-43f3-978a-b970a146ffd2') {\n\t\t\t// This anon ID was incorrectly committed to the template project, replace with a fresh ID going forward\n\t\t\tprofile = await initializeProfile();\n\t\t}\n\t\treturn profile;\n\t}\n};\n\n/**\n * TODO issue-1344 consider splitting this up into a separate handlers instead of taking all possible params (e.g separate handler for DB events)\n * @param {TelemetryEventName} eventName\n * @param {boolean} dev\n * @param {any} settings\n * @param {string | undefined} [databaseName]\n * @param {string | undefined} [sourceName]\n * @param {string | undefined} [queryName]\n */\nconst logEvent = async (\n\teventName,\n\tdev,\n\tsettings,\n\tdatabaseName = undefined,\n\tsourceName = undefined,\n\tqueryName = undefined\n) => {\n\ttry {\n\t\tlet usageStats = settings\n\t\t\t? settings.send_anonymous_usage_stats ?? 'yes'\n\t\t\t: process.env['SEND_ANONYMOUS_USAGE_STATS'] ??\n\t\t\t\tprocess.env['send_anonymous_usage_stats'] ??\n\t\t\t\t'yes';\n\t\tlet repo;\n\t\tlet database;\n\t\tlet demoDb;\n\n\t\tif (settings) {\n\t\t\tif (settings.gitRepo) {\n\t\t\t\trepo = md5(settings.gitRepo);\n\t\t\t}\n\n\t\t\tif (databaseName) {\n\t\t\t\tdatabase = databaseName;\n\t\t\t} else if (settings.database) {\n\t\t\t\t//legacy - remove this post migration\n\t\t\t\tdatabase = settings.database;\n\t\t\t}\n\n\t\t\tif (settings.credentials?.filename) {\n\t\t\t\tdemoDb = md5(settings.credentials.filename) === md5('needful_things.duckdb');\n\t\t\t}\n\t\t}\n\n\t\tlet homeDirectory = undefined;\n\t\tlet codespaces = false;\n\n\t\tif (process.env) {\n\t\t\tconst { HOME, CODESPACES } = process.env;\n\t\t\thomeDirectory = HOME;\n\t\t\tif (CODESPACES) {\n\t\t\t\tcodespaces = CODESPACES === 'true';\n\t\t\t}\n\t\t}\n\n\t\tif (usageStats === 'yes') {\n\t\t\tconst projectProfile = await getProfile();\n\t\t\tconst analytics = new Analytics({ writeKey: wK });\n\t\t\tconst payload = {\n\t\t\t\tanonymousId: projectProfile.anonymousId,\n\t\t\t\tevent: eventName,\n\t\t\t\tproperties: {\n\t\t\t\t\tdevMode: dev,\n\t\t\t\t\trepoHash: repo,\n\t\t\t\t\tdatabase: database, // logs database type (postgres, snowflake, etc.)\n\t\t\t\t\tsourceNameHash: sourceName ? md5(sourceName) : undefined, //logs the hashed name of the source this is associated with (e.g md5('pet-store')))\n\t\t\t\t\tqueryNameHash: queryName ? md5(queryName) : undefined, //logs the hashed name of the query this is associated with (e.g md5('pet-store')))\n\t\t\t\t\toperatingSystem: process.platform, // logs operating system name\n\t\t\t\t\tnodeVersion: process.version, // logs active version of NodeJS\n\t\t\t\t\tarch: process.arch,\n\t\t\t\t\tdirectoryHash: homeDirectory ? md5(homeDirectory) : undefined,\n\t\t\t\t\tdemoDb: demoDb,\n\t\t\t\t\tcodespaces: codespaces,\n\t\t\t\t\tpostUSQL: true\n\t\t\t\t}\n\t\t\t};\n\t\t\tanalytics.track(payload);\n\t\t}\n\t} catch {\n\t\t// do nothing\n\t}\n};\n\n/**\n * Logs an event emiited from source queries\n * @param {TelemetryEventName} eventName\n * @param {string | undefined} [databaseName]\n * @param {string | undefined} [sourceName]\n * @param {string | undefined} [queryName]\n */\nconst logQueryEvent = async (eventName, databaseName, sourceName, queryName, dev = false) => {\n\t//TODO there is no concept of dev mode when running npm run sources\n\ttry {\n\t\tawait logEvent(eventName, dev, loadSettings(), databaseName, sourceName, queryName);\n\t} catch (e) {\n\t\t//do nothing\n\t}\n};\n\nfunction loadSettings() {\n\tlet settings = {};\n\ttry {\n\t\tsettings = readJSONSync('evidence.settings.json');\n\t} catch (e) {\n\t\t//do nothing\n\t}\n\treturn settings;\n}\n\n/**\n * Checks for existance of legacy profile and then moves it to the new location\n * @returns {boolean} true if profile was migrated\n */\nfunction maybeMigrateProfile() {\n\tif (pathExistsSync(LEGACY_PROFILES_PATH)) {\n\t\tcopySync(LEGACY_PROFILES_PATH, PROFILES_PATH);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nmodule.exports = {\n\tlogEvent,\n\tlogQueryEvent\n};\n"],
  "mappings": "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",
  "names": ["HEX", "IDX", "BUFFER", "v4", "ValidationError", "message", "event", "_a", "_b", "InternalEventFactorySettings", "_a", "_b", "CoreEventFactory", "init_create_deferred", "Emitter", "_a", "init_emitter", "init_create_deferred", "init_emitter", "_a", "_b", "attempt", "PriorityQueue", "attempt", "_a", "init_dist", "CoreLogger", "message", "_b", "_a", "CoreStats", "NullStats", "init_dist", "ContextCancelation", "_a", "_b", "CoreContext", "message", "_a", "_a", "ctx", "CoreEventQueue", "_a", "_c", "_b", "after", "_a", "_a", "init_esm", "init_esm", "init_dist", "init_errors", "message", "_a", "init_errors", "init_errors", "init_errors", "types", "_a", "init_errors", "init_errors", "init_errors", "init_errors", "getNamedCurve", "init_errors", "init_errors", "init_errors", "init_errors", "init_errors", "init_errors", "init_decrypt", "init_errors", "init_decrypt", "init_errors", "init_decrypt", "init_errors", "init_errors", "init_encrypt", "init_errors", "init_encrypt", "init_errors", "init_errors", "init_verify", "init_errors", "init_verify", "init_errors", "init_verify", "init_errors", "init_errors", "init_verify", "init_errors", "init_decrypt", "init_errors", "init_encrypt", "init_sign", "init_errors", "init_sign", "init_sign", "init_errors", "init_sign", "init_errors", "_a", "init_encrypt", "init_errors", "init_errors", "init_errors", "init_errors", "init_errors", "init_errors", "base64url_exports", "decode", "encode", "init_base64url", "init_base64url", "init_base64url", "init_errors", "init_errors", "init_runtime", "init_decrypt", "init_encrypt", "init_verify", "init_sign", "init_errors", "init_base64url", "init_runtime", "init_esm", "sleep", "init_esm", "init_esm", "init_context", "init_esm", "init_esm", "init_context", "init_emitter", "init_event_queue", "init_esm", "AbortController", "_a", "fetch", "fetch", "init_esm", "init_emitter", "init_context", "init_event_queue", "init_context", "init_esm", "Analytics", "_a"]
}
